From f37a14fd0fcc1000624e78a463c439b778e772b5 Mon Sep 17 00:00:00 2001
From: kreijstal <rainb@tfwno.gf>
Date: Tue, 9 Sep 2025 07:50:51 +0200
Subject: [PATCH] Remove illegal specialization for compilation on clang on
 windows

---
 src/include/cppduals/duals/dual | 9 ++-------
 1 file changed, 2 insertions(+), 7 deletions(-)

diff --git a/src/include/cppduals/duals/dual b/src/include/cppduals/duals/dual
index 4cb227e84..25529445d 100644
--- a/src/include/cppduals/duals/dual
+++ b/src/include/cppduals/duals/dual
@@ -485,9 +485,6 @@ struct is_arithmetic<duals::dual<T>> : is_arithmetic<T> {};
 
 #endif // CPPDUALS_ENABLE_IS_ARITHMETIC
 
-/// Duals are compound types.
-template <class T>
-struct is_compound<duals::dual<T>> : true_type {};
 
 // Modification of std::numeric_limits<> per
 // C++03 17.4.3.1/1, and C++11 18.3.2.3/1.
@@ -693,14 +690,12 @@ template <class T> std::complex<T> dpart(const std::complex<dual<T>> & x)
 
 /// Get a non-dual's real part.
 template <class T,
-          CPPDUALS_ENABLE_IF((std::is_arithmetic<T>::value &&
-                              !std::is_compound<T>::value) || is_complex<T>::value)>
+          CPPDUALS_ENABLE_IF(std::is_arithmetic<T>::value || is_complex<T>::value)>
 T rpart(const T & x) { return x; }
 
 /// Get a non-dual's dual part := zero.
 template <class T,
-          CPPDUALS_ENABLE_IF((std::is_arithmetic<T>::value &&
-                              !std::is_compound<T>::value) || is_complex<T>::value)>
+          CPPDUALS_ENABLE_IF(std::is_arithmetic<T>::value || is_complex<T>::value)>
 T dpart(const T & ) { return T(0); }
 
 #ifndef PARSED_BY_DOXYGEN
-- 
2.51.0

