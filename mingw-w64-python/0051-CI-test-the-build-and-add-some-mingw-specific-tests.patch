From 48b49059f17bca7730cfabb9281e60ebe0459aa9 Mon Sep 17 00:00:00 2001
From: Naveen M K <naveen521kk@gmail.com>
Date: Fri, 18 Jun 2021 17:51:59 +0530
Subject: [PATCH 051/N] CI: test the build and add some mingw specific tests

Co-authored-by: Christoph Reiter <reiter.christoph@gmail.com>
---
 mingw_ignorefile.txt        |  33 ++++
 mingw_ignorefile_msvcrt.txt |  20 ++
 mingw_smoketests.py         | 353 ++++++++++++++++++++++++++++++++++++
 3 files changed, 406 insertions(+)
 create mode 100644 mingw_ignorefile.txt
 create mode 100644 mingw_ignorefile_msvcrt.txt
 create mode 100644 mingw_smoketests.py

diff --git a/mingw_ignorefile.txt b/mingw_ignorefile.txt
new file mode 100644
index 0000000..3807fc9
--- /dev/null
+++ b/mingw_ignorefile.txt
@@ -0,0 +1,33 @@
+test.test_ctypes.test_loading.LoaderTest.test_load_dll_with_flags
+test.test_import.ImportTests.test_dll_dependency_import
+test.test_site.CommandLineTests.test_no_args
+test.test_site.HelperFunctionsTests.test_getsitepackages
+test.test_regrtest.ProgramsTestCase.test_pcbuild_rt
+test.test_regrtest.ProgramsTestCase.test_tools_buildbot_test
+test.test_venv.BasicTest.test_activate_shell_script_has_no_dos_newlines
+test.test_venv.BasicTest.test_defaults_with_pathlike
+test.test_venv.BasicTest.test_defaults_with_str_path
+test.test_venv.BasicTest.test_executable
+test.test_venv.BasicTest.test_executable_symlinks
+test.test_venv.BasicTest.test_failed_symlink
+test.test_venv.BasicTest.test_multiprocessing
+test.test_venv.BasicTest.test_multiprocessing_recursion
+test.test_venv.BasicTest.test_prefixes
+test.test_venv.BasicTest.test_special_chars_windows
+test.test_venv.BasicTest.test_symlinking
+test.test_venv.BasicTest.test_sysconfig
+test.test_venv.BasicTest.test_sysconfig_symlinks
+test.test_venv.BasicTest.test_unicode_in_batch_file
+test.test_venv.BasicTest.test_unoverwritable_fails
+test.test_venv.BasicTest.test_upgrade
+test.test_venv.BasicTest.test_upgrade_dependencies
+test.test_venv.BasicTest.test_venvwlauncher
+test.test_venv.EnsurePipTest.test_explicit_no_pip
+test.test_venv.EnsurePipTest.test_no_pip_by_default
+test.test_multiprocessing_spawn.test_manager.WithManagerTestMyManager.*
+test.test_external_inspection.*
+test.test_capi.test_object.CAPITest.test_is_unique_temporary
+test.test_audit.AuditTest.test_sys_remote_exec
+test.test_remote_pdb.PdbAttachTestCase.test_attach_to_process_with_colors
+test.test_remote_pdb.PdbAttachTestCase.test_attach_to_process_without_colors
+test.test_sys.TestRemoteExec.*
\ No newline at end of file
diff --git a/mingw_ignorefile_msvcrt.txt b/mingw_ignorefile_msvcrt.txt
new file mode 100644
index 0000000..6d22b2b
--- /dev/null
+++ b/mingw_ignorefile_msvcrt.txt
@@ -0,0 +1,20 @@
+test.datetimetester.TestDate_Fast.*
+test.datetimetester.TestDate_Pure.*
+test.datetimetester.TestDateTime_Fast.*
+test.datetimetester.TestDateTime_Pure.*
+test.datetimetester.TestDateTimeTZ_Fast.*
+test.datetimetester.TestDateTimeTZ_Pure.*
+test.datetimetester.TestSubclassDateTime_Fast.*
+test.datetimetester.TestSubclassDateTime_Pure.*
+test.test_cmath.CMathTests.test_specific_values
+test.test_math.MathTests.*
+test.test_locale.TestRealLocales.test_setlocale_long_encoding
+test.test_math.FMATests.test_fma_infinities
+test.test_math.FMATests.test_fma_overflow
+test.test_math.FMATests.test_fma_zero_result
+test.test_math.FMATests.test_random
+test.test_strftime.Y1900Tests.test_y_before_1900
+test.test_strptime.CalculationTests.*
+test.test_strptime.StrptimeTests.test_weekday
+test.test_strptime.TimeRETests.test_compile
+test.test_tools.test_i18n.Test_pygettext.test_POT_Creation_Date
\ No newline at end of file
diff --git a/mingw_smoketests.py b/mingw_smoketests.py
new file mode 100644
index 0000000..7aff2d4
--- /dev/null
+++ b/mingw_smoketests.py
@@ -0,0 +1,353 @@
+#!/usr/bin/env python3
+# Copyright 2017 Christoph Reiter
+#
+# Permission is hereby granted, free of charge, to any person obtaining
+# a copy of this software and associated documentation files (the
+# "Software"), to deal in the Software without restriction, including
+# without limitation the rights to use, copy, modify, merge, publish,
+# distribute, sublicense, and/or sell copies of the Software, and to
+# permit persons to whom the Software is furnished to do so, subject to
+# the following conditions:
+#
+# The above copyright notice and this permission notice shall be included
+# in all copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+"""The goal of this test suite is collect tests for update regressions
+and to test msys2 related modifications like for path handling.
+Feel free to extend.
+"""
+
+import sys
+import os
+import unittest
+import sysconfig
+
+if sys._use_alt_sep:
+    SEP = "/"
+else:
+    SEP = "\\"
+
+_UCRT = 'ucrt' in sysconfig.get_platform()
+
+
+class Tests(unittest.TestCase):
+
+    def test_zoneinfo(self):
+        # https://github.com/msys2-contrib/cpython-mingw/issues/32
+        import zoneinfo
+        self.assertTrue(any(os.path.exists(p) for p in zoneinfo.TZPATH))
+        zoneinfo.ZoneInfo("America/Sao_Paulo")
+
+    def test_userdir_path_sep(self):
+        # Make sure os.path and pathlib use the same path separators
+        from unittest import mock
+        from os.path import expanduser
+        from pathlib import Path
+
+        profiles = ["C:\\foo", "C:/foo"]
+        for profile in profiles:
+            with mock.patch.dict(os.environ, {"USERPROFILE": profile}):
+                self.assertEqual(expanduser("~"), os.path.normpath(expanduser("~")))
+                self.assertEqual(str(Path("~").expanduser()), expanduser("~"))
+                self.assertEqual(str(Path.home()), expanduser("~"))
+
+    def test_ctypes_find_library(self):
+        from ctypes.util import find_library
+        from ctypes import cdll
+        self.assertTrue(cdll.msvcrt)
+        if _UCRT:
+            self.assertIsNone(find_library('c'))
+        else:
+            self.assertEqual(find_library('c'), 'msvcrt.dll')
+
+    def test_ctypes_dlopen(self):
+        import ctypes
+        self.assertEqual(ctypes.RTLD_GLOBAL, 0)
+        self.assertEqual(ctypes.RTLD_GLOBAL,  ctypes.RTLD_LOCAL)
+        self.assertFalse(hasattr(sys, 'setdlopenflags'))
+        self.assertFalse(hasattr(sys, 'getdlopenflags'))
+        self.assertFalse([n for n in dir(os) if n.startswith("RTLD_")])
+
+    def test_time_no_unix_stuff(self):
+        import time
+        self.assertFalse([n for n in dir(time) if n.startswith("clock_")])
+        self.assertFalse([n for n in dir(time) if n.startswith("CLOCK_")])
+        self.assertFalse([n for n in dir(time) if n.startswith("pthread_")])
+        self.assertFalse(hasattr(time, 'tzset'))
+
+    def test_strftime(self):
+        import time
+        with self.assertRaises(ValueError):
+            time.strftime('%Y', (12345,) + (0,) * 8)
+
+    def test_sep(self):
+        self.assertEqual(os.sep, SEP)
+
+    def test_module_file_path(self):
+        import asyncio
+        import zlib
+        self.assertEqual(zlib.__file__, os.path.normpath(zlib.__file__))
+        self.assertEqual(asyncio.__file__, os.path.normpath(asyncio.__file__))
+
+    def test_importlib_frozen_path_sep(self):
+        import importlib._bootstrap_external
+        self.assertEqual(importlib._bootstrap_external.path_sep, SEP)
+
+    def test_os_commonpath(self):
+        self.assertEqual(
+            os.path.commonpath(
+                [os.path.join("C:", os.sep, "foo", "bar"),
+                 os.path.join("C:", os.sep, "foo")]),
+                 os.path.join("C:", os.sep, "foo"))
+
+    def test_pathlib(self):
+        import pathlib
+
+        p = pathlib.Path("foo") / pathlib.Path("foo")
+        self.assertEqual(str(p), os.path.normpath(p))
+
+    def test_modules_import(self):
+        import sqlite3
+        import ssl
+        import ctypes
+        import curses
+
+    def test_c_modules_import(self):
+        import _decimal
+
+    def test_socket_inet_ntop(self):
+        import socket
+        self.assertTrue(hasattr(socket, "inet_ntop"))
+
+    def test_socket_inet_pton(self):
+        import socket
+        self.assertTrue(hasattr(socket, "inet_pton"))
+
+    def test_multiprocessing_queue(self):
+        from multiprocessing import Queue
+        Queue(0)
+
+    #def test_socket_timout_normal_error(self):
+    #    import urllib.request
+    #    from urllib.error import URLError
+
+    #    try:
+    #        urllib.request.urlopen(
+    #            'http://localhost', timeout=0.0001).close()
+    #    except URLError:
+    #        pass
+
+    def test_threads(self):
+        from concurrent.futures import ThreadPoolExecutor
+
+        with ThreadPoolExecutor(1) as pool:
+            for res in pool.map(lambda *x: None, range(10000)):
+                pass
+
+    def test_sysconfig(self):
+        # This should be able to execute without exceptions
+        sysconfig.get_config_vars()
+
+    def test_sqlite_enable_load_extension(self):
+        # Make sure --enable-loadable-sqlite-extensions is used
+        import sqlite3
+        self.assertTrue(sqlite3.Connection.enable_load_extension)
+
+    def test_venv_creation(self):
+        import tempfile
+        import venv
+        import subprocess
+        import shutil
+        with tempfile.TemporaryDirectory() as tmp:
+            builder = venv.EnvBuilder()
+            builder.create(tmp)
+            abiflags = sysconfig.get_config_var('ABIFLAGS')
+            assert os.path.exists(os.path.join(tmp, "bin", "activate"))
+            assert os.path.exists(os.path.join(tmp, "bin", "python" + abiflags + ".exe"))
+            assert os.path.exists(os.path.join(tmp, "bin", "pythonw" + abiflags + ".exe"))
+            subprocess.check_call([shutil.which("bash.exe"), os.path.join(tmp, "bin", "activate")])
+
+            # This will not work in in-tree build
+            if not sysconfig.is_python_build():
+                op = subprocess.check_output(
+                    [
+                        os.path.join(tmp, "bin", "python" + abiflags + ".exe"),
+                        "-c",
+                        "print('Hello World')"
+                    ],
+                    cwd=tmp,
+                )
+                assert op.decode().strip() == "Hello World"
+
+    def test_has_mktime(self):
+        from time import mktime, gmtime
+        mktime(gmtime())
+
+    def test_platform_things(self):
+        import platform
+        import importlib.machinery
+        import tempfile
+        import venv
+        import subprocess
+        self.assertEqual(sys.implementation.name, "cpython")
+        self.assertEqual(sys.platform, "win32")
+        self.assertTrue(sysconfig.get_platform().startswith("mingw"))
+        soabi = sysconfig.get_config_var('SOABI')
+        self.assertTrue(soabi.startswith("cp" + f'{sys.version_info.major}{sys.version_info.minor}'))
+        ext_suffix = sysconfig.get_config_var('EXT_SUFFIX')
+        abiflags = sysconfig.get_config_var('ABIFLAGS')
+        self.assertTrue("." + soabi + "." in ext_suffix)
+        self.assertTrue(ext_suffix.endswith(".pyd"))
+        self.assertTrue("mingw" in ext_suffix)
+        self.assertEqual(sysconfig.get_config_var('SHLIB_SUFFIX'), ".pyd")
+        ext_suffixes = importlib.machinery.EXTENSION_SUFFIXES
+        self.assertTrue(ext_suffix in ext_suffixes)
+        untagged_ext = abiflags + '.pyd'
+        self.assertTrue(untagged_ext in ext_suffixes)
+        if sysconfig.get_platform().startswith('mingw_i686'):
+             self.assertEqual(sys.winver, ".".join(map(str, sys.version_info[:2])) + '-32')
+        elif sysconfig.get_platform().startswith('mingw_aarch64'):
+            self.assertEqual(sys.winver, ".".join(map(str, sys.version_info[:2])) + '-arm64')
+        elif sysconfig.get_platform().startswith('mingw_armv7'):
+            self.assertEqual(sys.winver, ".".join(map(str, sys.version_info[:2])) + '-arm32')
+        else:
+            self.assertEqual(sys.winver, ".".join(map(str, sys.version_info[:2])))
+        self.assertEqual(platform.python_implementation(), "CPython")
+        self.assertEqual(platform.system(), "Windows")
+        self.assertTrue(isinstance(sys.api_version, int) and sys.api_version > 0)
+
+        with tempfile.TemporaryDirectory() as tmp:
+            builder = venv.EnvBuilder()
+            builder.create(tmp)
+            # This will not work in in-tree build
+            if not sysconfig.is_python_build():
+                op = subprocess.check_output(
+                    [
+                        os.path.join(tmp, "bin", 'python' + abiflags + '.exe'),
+                        "-c",
+                        "import sysconfig; print(sysconfig.get_config_var('LIBDIR'))"
+                    ],
+                    cwd=tmp,
+                )
+                self.assertTrue(op.decode().strip().startswith(sys.base_prefix))
+
+    def test_sys_getpath(self):
+        # everything sourced from getpath.py
+
+        def assertNormpath(path):
+            self.assertEqual(path, os.path.normpath(path))
+
+        assertNormpath(sys.executable)
+        assertNormpath(sys._base_executable)
+        assertNormpath(sys.prefix)
+        assertNormpath(sys.base_prefix)
+        assertNormpath(sys.exec_prefix)
+        assertNormpath(sys.base_exec_prefix)
+        assertNormpath(sys.platlibdir)
+        assertNormpath(sys._stdlib_dir)
+        for p in sys.path:
+            assertNormpath(p)
+
+    def test_site(self):
+        import site
+
+        self.assertEqual(len(site.getsitepackages()), 1)
+
+    def test_c_ext_build(self):
+        import tempfile
+        import subprocess
+        import textwrap
+        import venv
+        from pathlib import Path
+
+        if sysconfig.is_python_build():
+            pydir = os.path.dirname(sys._base_executable).replace('\\', '/')
+            os.environ["LDFLAGS"] = "-L " + pydir
+
+        with tempfile.TemporaryDirectory() as tmppro:
+            builder = venv.EnvBuilder(with_pip=True)
+            builder.create(tmppro)
+            venv_exe = os.path.join(tmppro, "bin", os.path.basename(sys.executable))
+
+            with Path(tmppro, "setup.py").open("w") as f:
+                f.write(
+                    textwrap.dedent(
+                        """\
+                                    from setuptools import setup, Extension
+
+                                    setup(
+                                        name='cwrapper',
+                                        version='1.0',
+                                        ext_modules=[
+                                            Extension(
+                                                'cwrapper',
+                                                sources=['cwrapper.c']),
+                                        ],
+                                    )
+                                """
+                    )
+                )
+            with Path(tmppro, "cwrapper.c").open("w") as f:
+                f.write(
+                    textwrap.dedent(
+                        """\
+                                    #include <Python.h>
+                                    static PyObject *
+                                    helloworld(PyObject *self, PyObject *args)
+                                    {
+                                        printf("Hello World\\n");
+                                        Py_RETURN_NONE;
+                                    }
+                                    static PyMethodDef
+                                    myMethods[] = {
+                                        { "helloworld", helloworld, METH_NOARGS, "Prints Hello World" },
+                                        { NULL, NULL, 0, NULL }
+                                    };
+                                    static struct PyModuleDef cwrapper = {
+                                        PyModuleDef_HEAD_INIT,
+                                        "cwrapper",
+                                        "Test Module",
+                                        -1,
+                                        myMethods
+                                    };
+
+                                    PyMODINIT_FUNC
+                                    PyInit_cwrapper(void)
+                                    {
+                                        return PyModule_Create(&cwrapper);
+                                    }
+                                """
+                    )
+                )
+            subprocess.check_call(
+                [venv_exe, "-c", "import struct"],
+            )
+            subprocess.check_call(
+                [
+                    venv_exe,
+                    "-m",
+                    "pip",
+                    "install",
+                    tmppro,
+                ],
+            )
+            subprocess.check_call(
+                [venv_exe, "-c", "import cwrapper"],
+            )
+
+
+
+def suite():
+    return unittest.TestLoader().loadTestsFromName(__name__)
+
+
+if __name__ == '__main__':
+    unittest.main(defaultTest='suite')
