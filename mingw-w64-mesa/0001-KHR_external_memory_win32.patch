From 9ecc3ed26ba74a7da00df4eb5b44833428db6a7c Mon Sep 17 00:00:00 2001
From: Hernan Martinez <hmartinez82@pm.me>
Date: Thu, 24 Apr 2025 22:39:34 -0600
Subject: [PATCH] Trying

---
 src/gallium/frontends/lavapipe/lvp_device.c  | 126 +++++++++++++++++++
 src/gallium/frontends/lavapipe/lvp_formats.c |  16 +++
 src/gallium/frontends/lavapipe/lvp_private.h |   4 +
 3 files changed, 146 insertions(+)

diff --git a/src/gallium/frontends/lavapipe/lvp_device.c b/src/gallium/frontends/lavapipe/lvp_device.c
index 934c501e231..c9d156845f1 100644
--- a/src/gallium/frontends/lavapipe/lvp_device.c
+++ b/src/gallium/frontends/lavapipe/lvp_device.c
@@ -54,6 +54,10 @@
 #include "vk_android.h"
 #endif
 
+#if DETECT_OS_WINDOWS
+#include <Windows.h>
+#endif
+
 #if defined(VK_USE_PLATFORM_WAYLAND_KHR) || \
     defined(VK_USE_PLATFORM_WIN32_KHR) || \
     defined(VK_USE_PLATFORM_XCB_KHR) || \
@@ -132,6 +136,9 @@ static const struct vk_device_extension_table lvp_device_extensions_supported =
    .KHR_external_memory                   = true,
 #ifdef PIPE_MEMORY_FD
    .KHR_external_memory_fd                = true,
+#endif
+#ifdef VK_USE_PLATFORM_WIN32_KHR
+   .KHR_external_memory_win32             = true,
 #endif
    .KHR_external_semaphore                = true,
    .KHR_shader_float_controls             = true,
@@ -284,6 +291,10 @@ assert_memhandle_type(VkExternalMemoryHandleTypeFlags types)
    unsigned valid[] = {
       VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
       VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
+#ifdef VK_USE_PLATFORM_WIN32_KHR
+      VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
+      VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
+#endif
    };
    for (unsigned i = 0; i < ARRAY_SIZE(valid); i++) {
       if (types & valid[i])
@@ -1927,6 +1938,17 @@ VKAPI_ATTR VkResult VKAPI_CALL lvp_AllocateMemory(
          import_info = (VkImportMemoryFdInfoKHR*)ext;
          assert_memhandle_type(import_info->handleType);
          break;
+#ifdef VK_USE_PLATFORM_WIN32_KHR
+      case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR: {
+         VkImportMemoryWin32HandleInfoKHR *import_info_win32 = (VkImportMemoryWin32HandleInfoKHR*)ext;
+         assert_memhandle_type(import_info_win32->handleType);
+         import_info = (VkImportMemoryFdInfoKHR*)import_info_win32;
+         break;
+      }
+      case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
+         /* Nothing to do here - just mark that we found this struct */
+         break;
+#endif
       case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT: {
          VkMemoryPriorityAllocateInfoEXT *prio = (VkMemoryPriorityAllocateInfoEXT*)ext;
          priority = get_mem_priority(prio->priority);
@@ -1948,6 +1970,18 @@ VKAPI_ATTR VkResult VKAPI_CALL lvp_AllocateMemory(
       return vk_error(device->instance, VK_ERROR_INVALID_EXTERNAL_HANDLE);
    }
 #endif
+#ifdef VK_USE_PLATFORM_WIN32_KHR
+   VkImportMemoryWin32HandleInfoKHR *import_info_win32 = NULL;
+   vk_foreach_struct_const(ext, pAllocateInfo->pNext) {
+      if (ext->sType == VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR) {
+         import_info_win32 = (VkImportMemoryWin32HandleInfoKHR*)ext;
+         break;
+      }
+   }
+   if (import_info_win32 != NULL && import_info_win32->handle == NULL && import_info_win32->name == NULL) {
+      return vk_error(device->instance, VK_ERROR_INVALID_EXTERNAL_HANDLE);
+   }
+#endif
 
    mem = vk_alloc2(&device->vk.alloc, pAllocator, sizeof(*mem), 8,
                    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT);
@@ -2020,6 +2054,42 @@ VKAPI_ATTR VkResult VKAPI_CALL lvp_AllocateMemory(
       mem->map = device->pscreen->map_memory(device->pscreen, mem->pmem);
       mem->memory_type = dmabuf ? LVP_DEVICE_MEMORY_TYPE_DMA_BUF : LVP_DEVICE_MEMORY_TYPE_OPAQUE_FD;
    }
+#endif
+#ifdef VK_USE_PLATFORM_WIN32_KHR
+   else if(import_info_win32 && import_info_win32->handleType) {
+      bool is_nt_handle = import_info_win32->handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+      uint64_t size;
+
+      // For Windows, we'll use the same fd-based functions but with the Windows handle
+      int fd = (int)(intptr_t)import_info_win32->handle;
+      if(!device->pscreen->import_memory_fd(device->pscreen, fd, &mem->pmem, &size, false)) {
+         error = VK_ERROR_INVALID_EXTERNAL_HANDLE;
+         goto fail;
+      }
+      if(size < pAllocateInfo->allocationSize) {
+         device->pscreen->free_memory_fd(device->pscreen, mem->pmem);
+         goto fail;
+      }
+
+      // Store the handle for later use
+      mem->backed_fd = fd;
+      mem->size = size;
+      mem->map = device->pscreen->map_memory(device->pscreen, mem->pmem);
+      mem->memory_type = is_nt_handle ? LVP_DEVICE_MEMORY_TYPE_OPAQUE_WIN32 : LVP_DEVICE_MEMORY_TYPE_OPAQUE_WIN32_KMT;
+   }
+   else if (export_info && (export_info->handleTypes & (VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT |
+                                                       VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT))) {
+      bool is_nt_handle = export_info->handleTypes & VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT;
+
+      // For Windows, we'll use the same fd-based functions
+      mem->pmem = device->pscreen->allocate_memory_fd(device->pscreen, pAllocateInfo->allocationSize, &mem->backed_fd, false);
+      if (!mem->pmem || mem->backed_fd < 0) {
+          goto fail;
+      }
+
+      mem->map = device->pscreen->map_memory(device->pscreen, mem->pmem);
+      mem->memory_type = is_nt_handle ? LVP_DEVICE_MEMORY_TYPE_OPAQUE_WIN32 : LVP_DEVICE_MEMORY_TYPE_OPAQUE_WIN32_KMT;
+   }
 #endif
    else {
       mem->pmem = device->pscreen->allocate_memory(device->pscreen, pAllocateInfo->allocationSize);
@@ -2070,6 +2140,14 @@ VKAPI_ATTR void VKAPI_CALL lvp_FreeMemory(
       if(mem->backed_fd >= 0)
          close(mem->backed_fd);
       break;
+#endif
+#ifdef VK_USE_PLATFORM_WIN32_KHR
+   case LVP_DEVICE_MEMORY_TYPE_OPAQUE_WIN32:
+   case LVP_DEVICE_MEMORY_TYPE_OPAQUE_WIN32_KMT:
+      device->pscreen->free_memory_fd(device->pscreen, mem->pmem);
+      if(mem->backed_fd >= 0)
+         CloseHandle((HANDLE)(intptr_t)mem->backed_fd);
+      break;
 #endif
    case LVP_DEVICE_MEMORY_TYPE_USER_PTR:
    default:
@@ -2414,6 +2492,54 @@ lvp_GetMemoryFdPropertiesKHR(VkDevice _device,
 
 #endif
 
+#ifdef VK_USE_PLATFORM_WIN32_KHR
+
+VKAPI_ATTR VkResult VKAPI_CALL
+lvp_GetMemoryWin32HandleKHR(VkDevice _device,
+                            const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo,
+                            HANDLE *pHandle)
+{
+   LVP_FROM_HANDLE(lvp_device, device, _device);
+   LVP_FROM_HANDLE(lvp_device_memory, memory, pGetWin32HandleInfo->memory);
+
+   assert(pGetWin32HandleInfo->sType == VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR);
+   assert_memhandle_type(pGetWin32HandleInfo->handleType);
+
+   if (memory->backed_fd == -1)
+      return vk_error(device, VK_ERROR_INVALID_EXTERNAL_HANDLE);
+
+   if (!DuplicateHandle(GetCurrentProcess(),
+                        (HANDLE)(intptr_t)memory->backed_fd,
+                        GetCurrentProcess(),
+                        pHandle,
+                        0,
+                        FALSE,
+                        DUPLICATE_SAME_ACCESS))
+      return vk_error(device, VK_ERROR_OUT_OF_HOST_MEMORY);
+
+   return VK_SUCCESS;
+}
+
+VKAPI_ATTR VkResult VKAPI_CALL
+lvp_GetMemoryWin32HandlePropertiesKHR(VkDevice _device,
+                                      VkExternalMemoryHandleTypeFlagBits handleType,
+                                      HANDLE handle,
+                                      VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties)
+{
+   LVP_FROM_HANDLE(lvp_device, device, _device);
+
+   assert(pMemoryWin32HandleProperties->sType == VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR);
+
+   if (assert_memhandle_type(handleType)) {
+      // There is only one memoryType so select this one
+      pMemoryWin32HandleProperties->memoryTypeBits = 1;
+   }
+   else
+      return vk_error(device->instance, VK_ERROR_INVALID_EXTERNAL_HANDLE);
+   return VK_SUCCESS;
+}
+
+#endif
 VKAPI_ATTR VkResult VKAPI_CALL lvp_CreateEvent(
    VkDevice                                    _device,
    const VkEventCreateInfo*                    pCreateInfo,
diff --git a/src/gallium/frontends/lavapipe/lvp_formats.c b/src/gallium/frontends/lavapipe/lvp_formats.c
index 2f2f3a19565..7e3fd951886 100644
--- a/src/gallium/frontends/lavapipe/lvp_formats.c
+++ b/src/gallium/frontends/lavapipe/lvp_formats.c
@@ -491,6 +491,14 @@ VKAPI_ATTR VkResult VKAPI_CALL lvp_GetPhysicalDeviceImageFormatProperties2(
          export_flags = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
          compat_flags = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
          break;
+#endif
+#ifdef VK_USE_PLATFORM_WIN32_KHR
+      case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+      case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+         flags = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT | VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;
+         export_flags = external_info->handleType;
+         compat_flags = external_info->handleType;
+         break;
 #endif
       case VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT:
          flags = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;
@@ -652,6 +660,14 @@ VKAPI_ATTR void VKAPI_CALL lvp_GetPhysicalDeviceExternalBufferProperties(
       export_flags = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
       compat_flags = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT;
       break;
+#endif
+#ifdef VK_USE_PLATFORM_WIN32_KHR
+   case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT:
+   case VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT:
+      flags = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT | VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;
+      export_flags = pExternalBufferInfo->handleType;
+      compat_flags = pExternalBufferInfo->handleType;
+      break;
 #endif
    case VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT:
       flags = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT;
diff --git a/src/gallium/frontends/lavapipe/lvp_private.h b/src/gallium/frontends/lavapipe/lvp_private.h
index 81b85cc152a..c454d3b8ec5 100644
--- a/src/gallium/frontends/lavapipe/lvp_private.h
+++ b/src/gallium/frontends/lavapipe/lvp_private.h
@@ -232,6 +232,10 @@ enum lvp_device_memory_type {
    LVP_DEVICE_MEMORY_TYPE_USER_PTR,
    LVP_DEVICE_MEMORY_TYPE_OPAQUE_FD,
    LVP_DEVICE_MEMORY_TYPE_DMA_BUF,
+#ifdef VK_USE_PLATFORM_WIN32_KHR
+   LVP_DEVICE_MEMORY_TYPE_OPAQUE_WIN32,
+   LVP_DEVICE_MEMORY_TYPE_OPAQUE_WIN32_KMT,
+#endif
 };
 
 struct lvp_device_memory {
-- 
2.49.0

