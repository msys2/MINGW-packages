diff -bur libsigsegv-2.14-o/src/handler-win32.c libsigsegv-2.14/src/handler-win32.c
--- libsigsegv-2.14-o/src/handler-win32.c	2025-04-17 10:07:26.629191300 -0600
+++ libsigsegv-2.14/src/handler-win32.c	2025-04-17 10:18:31.875370700 -0600
@@ -167,6 +167,82 @@
 #endif
      )
 #ifdef _WIN64
+  #if defined(_M_ARM64) || defined(__aarch64__)
+  {
+  #if 0 /* for debugging only */
+      printf ("Exception!\n");
+      printf ("Code = 0x%x\n",
+              ExceptionInfo->ExceptionRecord->ExceptionCode);
+      printf ("Flags = 0x%x\n",
+              ExceptionInfo->ExceptionRecord->ExceptionFlags);
+      printf ("Address = 0x%x\n",
+              ExceptionInfo->ExceptionRecord->ExceptionAddress);
+      printf ("Params:");
+      {
+        DWORD i;
+        for (i = 0; i < ExceptionInfo->ExceptionRecord->NumberParameters; i++)
+          printf (" 0x%x,",
+                  ExceptionInfo->ExceptionRecord->ExceptionInformation[i]);
+      }
+      printf ("\n");
+      printf ("Registers:\n");
+      printf ("pc = 0x%x\n", ExceptionInfo->ContextRecord->Pc);
+      printf ("sp = 0x%x\n", ExceptionInfo->ContextRecord->Sp);
+      printf ("fp = 0x%x\n", ExceptionInfo->ContextRecord->Fp);
+  #endif
+      if (ExceptionInfo->ExceptionRecord->NumberParameters == 2)
+      {
+        if (stk_user_handler
+            && ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_STACK_OVERFLOW)
+          {
+            char *address = (char *) ExceptionInfo->ExceptionRecord->ExceptionInformation[1];
+            /* Restart the program, giving it a sane value for sp.
+              At the same time, copy the contents of
+              ExceptionInfo->ContextRecord (which, on Windows, happens
+              to be allocated in the guard page, where it will be
+              inaccessible as soon as we restore the PAGE_GUARD bit!) to
+              this new stack.  */
+            uintptr_t faulting_page_address = (uintptr_t)address & -0x1000;
+            uintptr_t new_safe_sp = ((stk_extra_stack + stk_extra_stack_size) & -16);
+            CONTEXT *orig_context = ExceptionInfo->ContextRecord;
+            CONTEXT *safe_context = (CONTEXT *) (new_safe_sp -= sizeof (CONTEXT)); /* make room */
+            memcpy (safe_context, orig_context, sizeof (CONTEXT));
+            new_safe_sp -= 16; /* make room for arguments */
+            new_safe_sp &= -16; /* align */
+            ExceptionInfo->ContextRecord->Sp = new_safe_sp;
+            /* Call stack_overflow_handler(faulting_page_address,safe_context).  */
+            ExceptionInfo->ContextRecord->Pc = (uintptr_t)&stack_overflow_handler;
+            *(uintptr_t *)(new_safe_sp) = faulting_page_address;
+            *(uintptr_t *)(new_safe_sp + 8) = (uintptr_t) safe_context;
+            return EXCEPTION_CONTINUE_EXECUTION;
+          }
+    #if !MIXING_UNIX_SIGSEGV_AND_WIN32_STACKOVERFLOW_HANDLING || OLD_CYGWIN_WORKAROUND
+        if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
+          {
+    #if MIXING_UNIX_SIGSEGV_AND_WIN32_STACKOVERFLOW_HANDLING
+            /* Store the fault address.  Then pass control to Cygwin's
+              exception filter, which will decide whether to recognize
+              a fault inside a "system call" (and return errno = EFAULT)
+              or to pass it on to the program (by invoking the Unix signal
+              handler).  */
+            last_seen_fault_address = (void *) ExceptionInfo->ExceptionRecord->ExceptionInformation[1];
+    #else
+            if (user_handler != (sigsegv_handler_t) NULL)
+              {
+                /* ExceptionInfo->ExceptionRecord->ExceptionInformation[0] is
+                  1 if it's a write access, 0 if it's a read access. But we
+                  don't need this info because we don't have it on Unix
+                  either.  */
+                void *address = (void *) ExceptionInfo->ExceptionRecord->ExceptionInformation[1];
+                if ((*user_handler) (address, 1))
+                  return EXCEPTION_CONTINUE_EXECUTION;
+              }
+    #endif
+          }
+    #endif
+      }
+    }
+#else
     {
 #if 0 /* for debugging only */
       printf ("Exception!\n");
@@ -248,6 +324,7 @@
 #endif
         }
     }
+#endif
   return EXCEPTION_CONTINUE_SEARCH;
 }
 #else
