diff --git a/Source/cmake/OptionsCommon.cmake b/Source/cmake/OptionsCommon.cmake
index 9c4f00e..5ee4550 100644
--- a/Source/cmake/OptionsCommon.cmake
+++ b/Source/cmake/OptionsCommon.cmake
@@ -31,7 +31,7 @@ set_property(GLOBAL PROPERTY USE_FOLDERS ON)
 if (COMPILER_IS_GCC_OR_CLANG)
     set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fno-exceptions -fno-strict-aliasing")
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-exceptions -fno-strict-aliasing -fno-rtti")
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++17")
 endif ()
 
 if (COMPILER_IS_CLANG AND CMAKE_GENERATOR STREQUAL "Ninja")
diff --git a/Source/JavaScriptCore/jit/BinarySwitch.cpp b/Source/JavaScriptCore/jit/BinarySwitch.cpp
index f3ddcfc..e7e0b36 100644
--- a/Source/JavaScriptCore/jit/BinarySwitch.cpp
+++ b/Source/JavaScriptCore/jit/BinarySwitch.cpp
@@ -31,6 +31,9 @@
 #include "JSCInlines.h"
 #include <wtf/ListDump.h>
 
+#include <algorithm>
+#include <random>
+
 namespace JSC {
 
 static const bool verbose = false;
@@ -193,13 +196,9 @@ void BinarySwitch::build(unsigned start, bool hardStart, unsigned end)
         for (unsigned i = 0; i < size; ++i)
             localCaseIndices.append(start + i);
         
-        std::random_shuffle(
-            localCaseIndices.begin(), localCaseIndices.end(),
-            [this] (unsigned n) {
-                // We use modulo to get a random number in the range we want fully knowing that
-                // this introduces a tiny amount of bias, but we're fine with such tiny bias.
-                return m_weakRandom.getUint32() % n;
-            });
+        std::random_device rd;
+        std::mt19937 g(rd());
+        std::shuffle(localCaseIndices.begin(), localCaseIndices.end(), g);
         
         for (unsigned i = 0; i < size - 1; ++i) {
             append(BranchCode(NotEqualToPush, localCaseIndices[i]));
diff --git a/Source/JavaScriptCore/jit/RegisterAtOffset.cpp b/Source/JavaScriptCore/jit/RegisterAtOffset.cpp
index 16a639c..afd48a8 100644
--- a/Source/JavaScriptCore/jit/RegisterAtOffset.cpp
+++ b/Source/JavaScriptCore/jit/RegisterAtOffset.cpp
@@ -30,7 +30,7 @@
 
 namespace JSC {
 
-#if !COMPILER(MSVC)
+#if !OS(WINDOWS)
 static_assert(sizeof(RegisterAtOffset) == sizeof(ptrdiff_t), "RegisterAtOffset should be small.");
 #endif
 
diff --git a/Source/WebKit2/NetworkProcess/NetworkResourceLoadParameters.cpp b/Source/WebKit2/NetworkProcess/NetworkResourceLoadParameters.cpp
index b56b2f7..a41d0ab 100644
--- a/Source/WebKit2/NetworkProcess/NetworkResourceLoadParameters.cpp
+++ b/Source/WebKit2/NetworkProcess/NetworkResourceLoadParameters.cpp
@@ -45,7 +45,7 @@ NetworkResourceLoadParameters::NetworkResourceLoadParameters()
     , shouldClearReferrerOnHTTPSToHTTPRedirect(true)
     , defersLoading(false)
     , needsCertificateInfo(false)
-    , maximumBufferingTime(0_ms)
+    , maximumBufferingTime(0ms)
 {
 }
 
diff --git a/Source/WebKit2/NetworkProcess/NetworkResourceLoader.cpp b/Source/WebKit2/NetworkProcess/NetworkResourceLoader.cpp
index cef04f3..e1aafe1 100644
--- a/Source/WebKit2/NetworkProcess/NetworkResourceLoader.cpp
+++ b/Source/WebKit2/NetworkProcess/NetworkResourceLoader.cpp
@@ -192,7 +192,7 @@ void NetworkResourceLoader::startNetworkLoad(const ResourceRequest& request)
 {
     consumeSandboxExtensions();
 
-    if (isSynchronous() || m_parameters.maximumBufferingTime > 0_ms)
+    if (isSynchronous() || m_parameters.maximumBufferingTime > 0ms)
         m_bufferedData = SharedBuffer::create();
 
 #if ENABLE(NETWORK_CACHE)
diff --git a/Source/WebKit2/NetworkProcess/cache/NetworkCache.cpp b/Source/WebKit2/NetworkProcess/cache/NetworkCache.cpp
index 9ea0d3f..fe79e53 100644
--- a/Source/WebKit2/NetworkProcess/cache/NetworkCache.cpp
+++ b/Source/WebKit2/NetworkProcess/cache/NetworkCache.cpp
@@ -193,7 +193,7 @@ static bool responseHasExpired(const WebCore::ResourceResponse& response, std::c
     auto age = WebCore::computeCurrentAge(response, timestamp);
     auto lifetime = WebCore::computeFreshnessLifetimeForHTTPFamily(response, timestamp);
 
-    auto maximumStaleness = maxStale ? maxStale.value() : 0_ms;
+    auto maximumStaleness = maxStale ? maxStale.value() : 0ms;
     bool hasExpired = age - lifetime > maximumStaleness;
 
 #ifndef LOG_DISABLED
@@ -210,7 +210,7 @@ static bool responseNeedsRevalidation(const WebCore::ResourceResponse& response,
     if (requestDirectives.noCache)
         return true;
     // For requests we ignore max-age values other than zero.
-    if (requestDirectives.maxAge && requestDirectives.maxAge.value() == 0_ms)
+    if (requestDirectives.maxAge && requestDirectives.maxAge.value() == 0ms)
         return true;
 
     return responseHasExpired(response, timestamp, requestDirectives.maxStale);
@@ -325,7 +325,7 @@ static StoreDecision makeStoreDecision(const WebCore::ResourceRequest& originalR
     bool storeUnconditionallyForHistoryNavigation = isMainResource || originalRequest.priority() == WebCore::ResourceLoadPriority::VeryHigh;
     if (!storeUnconditionallyForHistoryNavigation) {
         auto now = std::chrono::system_clock::now();
-        bool hasNonZeroLifetime = !response.cacheControlContainsNoCache() && WebCore::computeFreshnessLifetimeForHTTPFamily(response, now) > 0_ms;
+        bool hasNonZeroLifetime = !response.cacheControlContainsNoCache() && WebCore::computeFreshnessLifetimeForHTTPFamily(response, now) > 0ms;
 
         bool possiblyReusable = response.hasCacheValidatorFields() || hasNonZeroLifetime;
         if (!possiblyReusable)
diff --git a/Source/WebKit2/NetworkProcess/cache/NetworkCacheSpeculativeLoadManager.cpp b/Source/WebKit2/NetworkProcess/cache/NetworkCacheSpeculativeLoadManager.cpp
index 0275911..9949f1b 100644
--- a/Source/WebKit2/NetworkProcess/cache/NetworkCacheSpeculativeLoadManager.cpp
+++ b/Source/WebKit2/NetworkProcess/cache/NetworkCacheSpeculativeLoadManager.cpp
@@ -106,7 +106,7 @@ static bool responseNeedsRevalidation(const ResourceResponse& response, std::chr
 
     auto age = computeCurrentAge(response, timestamp);
     auto lifetime = computeFreshnessLifetimeForHTTPFamily(response, timestamp);
-    return age - lifetime > 0_ms;
+    return age - lifetime > 0ms;
 }
 
 class SpeculativeLoadManager::ExpiringEntry {
diff --git a/Source/WebKit2/NetworkProcess/cache/NetworkCacheStorage.cpp b/Source/WebKit2/NetworkProcess/cache/NetworkCacheStorage.cpp
index 1f650bf..ad8c538 100644
--- a/Source/WebKit2/NetworkProcess/cache/NetworkCacheStorage.cpp
+++ b/Source/WebKit2/NetworkProcess/cache/NetworkCacheStorage.cpp
@@ -572,7 +572,7 @@ void Storage::dispatchReadOperation(std::unique_ptr<ReadOperation> readOperation
     m_activeReadOperations.add(WTFMove(readOperationPtr));
 
     // I/O pressure may make disk operations slow. If they start taking very long time we rather go to network.
-    const auto readTimeout = 1500_ms;
+    const auto readTimeout = 1500ms;
     m_readOperationTimeoutTimer.startOneShot(readTimeout);
 
     bool shouldGetBodyBlob = mayContainBlob(readOperation.key);
diff --git a/Source/WebKit2/WebProcess/Network/WebLoaderStrategy.cpp b/Source/WebKit2/WebProcess/Network/WebLoaderStrategy.cpp
index ad042e5..8decb68 100644
--- a/Source/WebKit2/WebProcess/Network/WebLoaderStrategy.cpp
+++ b/Source/WebKit2/WebProcess/Network/WebLoaderStrategy.cpp
@@ -90,11 +90,11 @@ RefPtr<NetscapePlugInStreamLoader> WebLoaderStrategy::schedulePluginStreamLoad(F
 static std::chrono::milliseconds maximumBufferingTime(CachedResource* resource)
 {
 #if !ENABLE(NETWORK_CACHE)
-    return 0_ms;
+    return 0ms;
 #endif
 
     if (!resource)
-        return 0_ms;
+        return 0ms;
 
     switch (resource->type()) {
     case CachedResource::CSSStyleSheet:
@@ -105,7 +105,7 @@ static std::chrono::milliseconds maximumBufferingTime(CachedResource* resource)
     case CachedResource::FontResource:
         return std::chrono::milliseconds::max();
     case CachedResource::ImageResource:
-        return 500_ms;
+        return 500ms;
     case CachedResource::MainResource:
     case CachedResource::RawResource:
     case CachedResource::SVGDocumentResource:
@@ -119,11 +119,11 @@ static std::chrono::milliseconds maximumBufferingTime(CachedResource* resource)
 #if ENABLE(XSLT)
     case CachedResource::XSLStyleSheet:
 #endif
-        return 0_ms;
+        return 0ms;
     }
 
     ASSERT_NOT_REACHED();
-    return 0_ms;
+    return 0ms;
 }
 
 void WebLoaderStrategy::scheduleLoad(ResourceLoader* resourceLoader, CachedResource* resource, bool shouldClearReferrerOnHTTPSToHTTPRedirect)
diff --git a/Source/WTF/wtf/MathExtras.h b/Source/WTF/wtf/MathExtras.h
index e4399f8..939d245 100644
--- a/Source/WTF/wtf/MathExtras.h
+++ b/Source/WTF/wtf/MathExtras.h
@@ -260,28 +260,6 @@ template<typename T> inline bool isGreaterThanNonZeroPowerOfTwo(T value, unsigne
 #endif
 #endif
 
-#if COMPILER(MINGW64) && (!defined(__MINGW64_VERSION_RC) || __MINGW64_VERSION_RC < 1)
-inline double wtf_pow(double x, double y)
-{
-    // MinGW-w64 has a custom implementation for pow.
-    // This handles certain special cases that are different.
-    if ((x == 0.0 || std::isinf(x)) && std::isfinite(y)) {
-        double f;
-        if (modf(y, &f) != 0.0)
-            return ((x == 0.0) ^ (y > 0.0)) ? std::numeric_limits<double>::infinity() : 0.0;
-    }
-
-    if (x == 2.0) {
-        int yInt = static_cast<int>(y);
-        if (y == yInt)
-            return ldexp(1.0, yInt);
-    }
-
-    return pow(x, y);
-}
-#define pow(x, y) wtf_pow(x, y)
-#endif // COMPILER(MINGW64) && (!defined(__MINGW64_VERSION_RC) || __MINGW64_VERSION_RC < 1)
-
 
 // decompose 'number' to its sign, exponent, and mantissa components.
 // The result is interpreted as:
diff --git a/Source/WTF/wtf/StdLibExtras.h b/Source/WTF/wtf/StdLibExtras.h
index d872097..0111e81 100644
--- a/Source/WTF/wtf/StdLibExtras.h
+++ b/Source/WTF/wtf/StdLibExtras.h
@@ -292,7 +292,7 @@ inline void* operator new(size_t, NotNullTag, void* location)
 // This adds various C++14 features for versions of the STL that may not yet have them.
 namespace std {
 // MSVC 2013 supports std::make_unique already.
-#if !defined(_MSC_VER) || _MSC_VER < 1800
+#if !defined(_WIN32) || (defined(_MSC_VER) && _MSC_VER < 1800)
 template<class T> struct _Unique_if {
     typedef unique_ptr<T> _Single_object;
 };
@@ -323,7 +323,7 @@ make_unique(Args&&...) = delete;
 #endif
 
 // MSVC 2015 supports these functions.
-#if !COMPILER(MSVC) || _MSC_VER < 1900
+#if !defined(_WIN32) || (defined(_MSC_VER) && _MSC_VER < 1900)
 // Compile-time integer sequences
 // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3658.html
 // (Note that we only implement index_sequence, and not the more generic integer_sequence).
@@ -354,24 +354,6 @@ T exchange(T& t, U&& newValue)
 }
 #endif
 
-#if COMPILER_SUPPORTS(CXX_USER_LITERALS)
-// These literals are available in C++14, so once we require C++14 compilers we can get rid of them here.
-// (User-literals need to have a leading underscore so we add it here - the "real" literals don't have underscores).
-namespace literals {
-namespace chrono_literals {
-    constexpr inline chrono::seconds operator"" _s(unsigned long long s)
-    {
-        return chrono::seconds(static_cast<chrono::seconds::rep>(s));
-    }
-
-    constexpr chrono::milliseconds operator"" _ms(unsigned long long ms)
-    {
-        return chrono::milliseconds(static_cast<chrono::milliseconds::rep>(ms));
-    }
-}
-}
-#endif
-
 template<WTF::CheckMoveParameterTag, typename T>
 ALWAYS_INLINE constexpr typename remove_reference<T>::type&& move(T&& value)
 {
@@ -401,7 +383,7 @@ using WTF::safeCast;
 
 #if COMPILER_SUPPORTS(CXX_USER_LITERALS)
 // We normally don't want to bring in entire std namespaces, but literals are an exception.
-using namespace std::literals::chrono_literals;
+using namespace std::chrono_literals;
 #endif
 
 #endif // WTF_StdLibExtras_h
