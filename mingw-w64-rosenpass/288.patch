diff --git a/Cargo.lock b/Cargo.lock
index b56249c..bdfc91f 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1,6 +1,6 @@
 # This file is automatically @generated by Cargo.
 # It is not intended for manual editing.
-version = 3
+version = 4
 
 [[package]]
 name = "addr2line"
@@ -173,17 +173,17 @@ checksum = "9d297deb1925b89f2ccc13d7635fa0714f12c87adce1c75356b39ca9b7178567"
 
 [[package]]
 name = "bindgen"
-version = "0.68.1"
+version = "0.69.5"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "726e4313eb6ec35d2730258ad4e15b547ee75d6afaa1361a922e78e59b7d8078"
+checksum = "271383c67ccabffb7381723dea0672a673f292304fcb45c01cc648c7a8d58088"
 dependencies = [
  "bitflags 2.5.0",
  "cexpr",
  "clang-sys",
+ "itertools",
  "lazy_static",
  "lazycell",
  "log",
- "peeking_take_while",
  "prettyplease",
  "proc-macro2",
  "quote",
@@ -962,6 +962,12 @@ dependencies = [
  "generic-array",
 ]
 
+[[package]]
+name = "ipnet"
+version = "2.9.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8f518f335dce6725a761382244631d86cf0ccb2863413590b31338feb467f9c3"
+
 [[package]]
 name = "is-terminal"
 version = "0.4.12"
@@ -1042,7 +1048,7 @@ source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "0c2a198fb6b0eada2a8df47933734e6d35d350665a33a3593d7164fa52c75c19"
 dependencies = [
  "cfg-if",
- "windows-targets 0.52.5",
+ "windows-targets 0.48.5",
 ]
 
 [[package]]
@@ -1302,9 +1308,9 @@ checksum = "c08d65885ee38876c4f86fa503fb49d7b507c2b62552df7c70b2fce627e06381"
 
 [[package]]
 name = "oqs-sys"
-version = "0.9.1+liboqs-0.9.0"
+version = "0.10.0+liboqs-0.12.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "afa79adc3c10f8e01d0b134c159254e5843ec3f91c0bd868e57777beb3329e17"
+checksum = "13a5ba992d8a152252e11fb8ebb859923fa8b941f5e374d3b6c21b18d24fff81"
 dependencies = [
  "bindgen",
  "build-deps",
@@ -1339,7 +1345,7 @@ dependencies = [
  "libc",
  "redox_syscall",
  "smallvec",
- "windows-targets 0.52.5",
+ "windows-targets 0.52.6",
 ]
 
 [[package]]
@@ -1348,12 +1354,6 @@ version = "1.0.14"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c"
 
-[[package]]
-name = "peeking_take_while"
-version = "0.1.2"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "19b17cddbe7ec3f8bc800887bab5e717348c95ea2ca0b1bf0837fb964dc67099"
-
 [[package]]
 name = "pin-project-lite"
 version = "0.2.14"
@@ -1674,6 +1674,7 @@ dependencies = [
  "futures",
  "futures-util",
  "genetlink",
+ "ipnet",
  "netlink-packet-core",
  "netlink-packet-generic",
  "netlink-packet-wireguard",
@@ -1686,6 +1687,7 @@ dependencies = [
  "stacker",
  "tempfile",
  "tokio",
+ "wireguard-nt",
  "x25519-dalek",
  "zeroize",
 ]
@@ -2194,6 +2196,12 @@ dependencies = [
  "rustix",
 ]
 
+[[package]]
+name = "widestring"
+version = "0.4.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c168940144dd21fd8046987c16a46a33d5fc84eec29ef9dcddc2ac9e31526b7c"
+
 [[package]]
 name = "winapi"
 version = "0.3.9"
@@ -2249,7 +2257,16 @@ version = "0.52.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
 dependencies = [
- "windows-targets 0.52.5",
+ "windows-targets 0.52.6",
+]
+
+[[package]]
+name = "windows-sys"
+version = "0.59.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
+dependencies = [
+ "windows-targets 0.52.6",
 ]
 
 [[package]]
@@ -2284,18 +2301,18 @@ dependencies = [
 
 [[package]]
 name = "windows-targets"
-version = "0.52.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "6f0713a46559409d202e70e28227288446bf7841d3211583a4b53e3f6d96e7eb"
+checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
 dependencies = [
- "windows_aarch64_gnullvm 0.52.5",
- "windows_aarch64_msvc 0.52.5",
- "windows_i686_gnu 0.52.5",
+ "windows_aarch64_gnullvm 0.52.6",
+ "windows_aarch64_msvc 0.52.6",
+ "windows_i686_gnu 0.52.6",
  "windows_i686_gnullvm",
- "windows_i686_msvc 0.52.5",
- "windows_x86_64_gnu 0.52.5",
- "windows_x86_64_gnullvm 0.52.5",
- "windows_x86_64_msvc 0.52.5",
+ "windows_i686_msvc 0.52.6",
+ "windows_x86_64_gnu 0.52.6",
+ "windows_x86_64_gnullvm 0.52.6",
+ "windows_x86_64_msvc 0.52.6",
 ]
 
 [[package]]
@@ -2312,9 +2329,9 @@ checksum = "2b38e32f0abccf9987a4e3079dfb67dcd799fb61361e53e2882c3cbaf0d905d8"
 
 [[package]]
 name = "windows_aarch64_gnullvm"
-version = "0.52.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "7088eed71e8b8dda258ecc8bac5fb1153c5cffaf2578fc8ff5d61e23578d3263"
+checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"
 
 [[package]]
 name = "windows_aarch64_msvc"
@@ -2330,9 +2347,9 @@ checksum = "dc35310971f3b2dbbf3f0690a219f40e2d9afcf64f9ab7cc1be722937c26b4bc"
 
 [[package]]
 name = "windows_aarch64_msvc"
-version = "0.52.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "9985fd1504e250c615ca5f281c3f7a6da76213ebd5ccc9561496568a2752afb6"
+checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"
 
 [[package]]
 name = "windows_i686_gnu"
@@ -2348,15 +2365,15 @@ checksum = "a75915e7def60c94dcef72200b9a8e58e5091744960da64ec734a6c6e9b3743e"
 
 [[package]]
 name = "windows_i686_gnu"
-version = "0.52.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "88ba073cf16d5372720ec942a8ccbf61626074c6d4dd2e745299726ce8b89670"
+checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"
 
 [[package]]
 name = "windows_i686_gnullvm"
-version = "0.52.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "87f4261229030a858f36b459e748ae97545d6f1ec60e5e0d6a3d32e0dc232ee9"
+checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"
 
 [[package]]
 name = "windows_i686_msvc"
@@ -2372,9 +2389,9 @@ checksum = "8f55c233f70c4b27f66c523580f78f1004e8b5a8b659e05a4eb49d4166cca406"
 
 [[package]]
 name = "windows_i686_msvc"
-version = "0.52.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "db3c2bf3d13d5b658be73463284eaf12830ac9a26a90c717b7f771dfe97487bf"
+checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"
 
 [[package]]
 name = "windows_x86_64_gnu"
@@ -2390,9 +2407,9 @@ checksum = "53d40abd2583d23e4718fddf1ebec84dbff8381c07cae67ff7768bbf19c6718e"
 
 [[package]]
 name = "windows_x86_64_gnu"
-version = "0.52.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "4e4246f76bdeff09eb48875a0fd3e2af6aada79d409d33011886d3e1581517d9"
+checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
@@ -2408,9 +2425,9 @@ checksum = "0b7b52767868a23d5bab768e390dc5f5c55825b6d30b86c844ff2dc7414044cc"
 
 [[package]]
 name = "windows_x86_64_gnullvm"
-version = "0.52.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "852298e482cd67c356ddd9570386e2862b5673c85bd5f88df9ab6802b334c596"
+checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"
 
 [[package]]
 name = "windows_x86_64_msvc"
@@ -2426,9 +2443,9 @@ checksum = "ed94fce61571a4006852b7389a063ab983c02eb1bb37b47f8272ce92d06d9538"
 
 [[package]]
 name = "windows_x86_64_msvc"
-version = "0.52.5"
+version = "0.52.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "bec47e5bfd1bff0eeaf6d8b485cc1074891a197ab4225d504cb7a1ab88b02bf0"
+checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"
 
 [[package]]
 name = "winnow"
@@ -2439,6 +2456,22 @@ dependencies = [
  "memchr",
 ]
 
+[[package]]
+name = "wireguard-nt"
+version = "0.5.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "22b4dbcc6c93786cf22e420ef96e8976bfb92a455070282302b74de5848191f4"
+dependencies = [
+ "bitflags 2.5.0",
+ "getrandom",
+ "ipnet",
+ "libloading",
+ "log",
+ "thiserror",
+ "widestring",
+ "windows-sys 0.59.0",
+]
+
 [[package]]
 name = "x25519-dalek"
 version = "2.0.1"
diff --git a/Cargo.toml b/Cargo.toml
index 946a604..f9cae82 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -56,10 +56,11 @@ serde = { version = "1.0.200", features = ["derive"] }
 arbitrary = { version = "1.3.2", features = ["derive"] }
 anyhow = { version = "1.0.82", features = ["backtrace", "std"] }
 mio = { version = "0.8.11", features = ["net", "os-poll"] }
-oqs-sys = { version = "0.9.1", default-features = false, features = ['classic_mceliece', 'kyber']  }
+oqs-sys = { version = "0.10.0", default-features = false, features = ['classic_mceliece', 'kyber']  }
 blake2 = "0.10.6"
 chacha20poly1305 = { version = "0.10.1", default-features = false, features = [ "std", "heapless" ] }
 zerocopy = { version = "0.7.32", features = ["derive"] }
 home = "0.5.9"
 serial_test = "3.1.1"
 derive_builder = "0.20.0"
+ipnet = "2.9.0"
diff --git a/rosenpass/src/app_server.rs b/rosenpass/src/app_server.rs
index 33125a3..8d26c98 100644
--- a/rosenpass/src/app_server.rs
+++ b/rosenpass/src/app_server.rs
@@ -49,15 +49,19 @@ fn ipv6_any_binding() -> SocketAddr {
     SocketAddr::V6(SocketAddrV6::new(IPV6_ANY_ADDR, 0, 0, 0))
 }
 
+pub trait WgPeerAdapter: Sized {
+    fn update_wg_psk(&mut self, key: &rosenpass_secret_memory::Secret<32>) -> anyhow::Result<()>;
+}
+
 #[derive(Default, Debug)]
-pub struct AppPeer {
+pub struct AppPeer<W: WgPeerAdapter> {
     pub outfile: Option<PathBuf>,
-    pub outwg: Option<WireguardOut>, // TODO make this a generic command
+    pub adapter: Option<W>, 
     pub initial_endpoint: Option<Endpoint>,
     pub current_endpoint: Option<Endpoint>,
 }
 
-impl AppPeer {
+impl<W:WgPeerAdapter> AppPeer<W> {
     pub fn endpoint(&self) -> Option<&Endpoint> {
         self.current_endpoint
             .as_ref()
@@ -66,13 +70,54 @@ impl AppPeer {
 }
 
 #[derive(Default, Debug)]
-pub struct WireguardOut {
+pub struct UnixWireguardOut {
     // impl KeyOutput
     pub dev: String,
     pub pk: String,
     pub extra_params: Vec<String>,
 }
 
+impl WgPeerAdapter for UnixWireguardOut {
+    fn update_wg_psk(&mut self, key: &rosenpass_secret_memory::Secret<32>) -> anyhow::Result<()>{
+            let mut child = match Command::new("wg")
+                .arg("set")
+                .arg(&self.dev)
+                .arg("peer")
+                .arg(&self.pk)
+                .arg("preshared-key")
+                .arg("/dev/stdin")
+                .stdin(Stdio::piped())
+                .args(&self.extra_params)
+                .spawn()
+            {
+                Ok(x) => x,
+                Err(e) => {
+                    if e.kind() == std::io::ErrorKind::NotFound {
+                        anyhow::bail!("Could not find wg command");
+                    } else {
+                        return Err(anyhow::Error::new(e));
+                    }
+                }
+            };
+            b64_writer(child.stdin.take().unwrap()).write_all(key.secret())?;
+
+            thread::spawn(move || {
+                let status = child.wait();
+
+                if let Ok(status) = status {
+                    if status.success() {
+                        debug!("successfully passed psk to wg")
+                    } else {
+                        error!("could not pass psk to wg {:?}", status)
+                    }
+                } else {
+                    error!("wait failed: {:?}", status)
+                }
+            });
+        Ok(())
+    }
+}
+
 #[derive(Debug, Clone, Copy, PartialEq)]
 pub enum DoSOperation {
     UnderLoad,
@@ -95,12 +140,12 @@ pub struct AppServerTest {
 /// Responsible for file IO, network IO
 // TODO add user control via unix domain socket and stdin/stdout
 #[derive(Debug)]
-pub struct AppServer {
+pub struct AppServer<W: WgPeerAdapter> {
     pub crypt: CryptoServer,
     pub sockets: Vec<mio::net::UdpSocket>,
     pub events: mio::Events,
     pub mio_poll: mio::Poll,
-    pub peers: Vec<AppPeer>,
+    pub peers: Vec<AppPeer<W>>,
     pub verbosity: Verbosity,
     pub all_sockets_drained: bool,
     pub under_load: DoSOperation,
@@ -121,15 +166,15 @@ pub struct AppServer {
 pub struct SocketPtr(pub usize);
 
 impl SocketPtr {
-    pub fn get<'a>(&self, srv: &'a AppServer) -> &'a mio::net::UdpSocket {
+    pub fn get<'a,W: WgPeerAdapter>(&self, srv: &'a AppServer<W>) -> &'a mio::net::UdpSocket {
         &srv.sockets[self.0]
     }
 
-    pub fn get_mut<'a>(&self, srv: &'a mut AppServer) -> &'a mut mio::net::UdpSocket {
+    pub fn get_mut<'a,W: WgPeerAdapter>(&self, srv: &'a mut AppServer<W>) -> &'a mut mio::net::UdpSocket {
         &mut srv.sockets[self.0]
     }
 
-    pub fn send_to(&self, srv: &AppServer, buf: &[u8], addr: SocketAddr) -> anyhow::Result<()> {
+    pub fn send_to<W: WgPeerAdapter>(&self, srv: &AppServer<W>, buf: &[u8], addr: SocketAddr) -> anyhow::Result<()> {
         self.get(srv).send_to(buf, addr)?;
         Ok(())
     }
@@ -150,11 +195,11 @@ impl AppPeerPtr {
         PeerPtr(self.0)
     }
 
-    pub fn get_app<'a>(&self, srv: &'a AppServer) -> &'a AppPeer {
+    pub fn get_app<'a, W: WgPeerAdapter>(&self, srv: &'a AppServer<W>) -> &'a AppPeer<W> {
         &srv.peers[self.0]
     }
 
-    pub fn get_app_mut<'a>(&self, srv: &'a mut AppServer) -> &'a mut AppPeer {
+    pub fn get_app_mut<'a, W: WgPeerAdapter>(&self, srv: &'a mut AppServer<W>) -> &'a mut AppPeer<W> {
         &mut srv.peers[self.0]
     }
 }
@@ -315,7 +360,7 @@ impl Endpoint {
         Some(Self::discovery_from_addresses(addrs))
     }
 
-    pub fn send(&self, srv: &AppServer, buf: &[u8]) -> anyhow::Result<()> {
+    pub fn send<W: WgPeerAdapter>(&self, srv: &AppServer<W>, buf: &[u8]) -> anyhow::Result<()> {
         use Endpoint::*;
         match self {
             SocketBoundAddress(host) => host.socket.send_to(srv, buf, host.addr),
@@ -391,7 +436,7 @@ impl HostPathDiscoveryEndpoint {
         &self.addresses
     }
 
-    fn insert_next_scout_offset(&self, srv: &AppServer, addr_no: usize, sock_no: usize) {
+    fn insert_next_scout_offset<W: WgPeerAdapter>(&self, srv: &AppServer<W>, addr_no: usize, sock_no: usize) {
         self.scouting_state.set((
             (addr_no + 1) % self.addresses.len(),
             (sock_no + 1) % srv.sockets.len(),
@@ -401,7 +446,7 @@ impl HostPathDiscoveryEndpoint {
     /// Attempt to reach the host
     ///
     /// Will round-robin-try different socket-ip-combinations on each call.
-    pub fn send_scouting(&self, srv: &AppServer, buf: &[u8]) -> anyhow::Result<()> {
+    pub fn send_scouting<W: WgPeerAdapter>(&self, srv: &AppServer<W>, buf: &[u8]) -> anyhow::Result<()> {
         let (addr_off, sock_off) = self.scouting_state.get();
 
         let mut addrs = (self.addresses)
@@ -444,7 +489,7 @@ impl HostPathDiscoveryEndpoint {
     }
 }
 
-impl AppServer {
+impl<W: WgPeerAdapter> AppServer<W> {
     pub fn new(
         sk: SSk,
         pk: SPk,
@@ -509,6 +554,7 @@ impl AppServer {
 
             let v6 = try_register_socket!("IPv6", ipv6_any_binding());
 
+            /* 
             let need_v4 = match v6.map(|no| sockets[no].only_v6()) {
                 Some(Ok(v)) => v,
                 None => true,
@@ -517,6 +563,9 @@ impl AppServer {
                     true
                 }
             };
+            */
+            //TEMP
+            let need_v4 = true;
 
             if need_v4 {
                 try_register_socket!("IPv4", ipv4_any_binding());
@@ -562,7 +611,7 @@ impl AppServer {
         psk: Option<SymKey>,
         pk: SPk,
         outfile: Option<PathBuf>,
-        outwg: Option<WireguardOut>,
+        adapter: Option<W>,
         hostname: Option<String>,
     ) -> anyhow::Result<AppPeerPtr> {
         let PeerPtr(pn) = self.crypt.add_peer(psk, pk)?;
@@ -573,7 +622,7 @@ impl AppServer {
         let current_endpoint = None;
         self.peers.push(AppPeer {
             outfile,
-            outwg,
+            adapter,
             initial_endpoint,
             current_endpoint,
         });
@@ -733,14 +782,12 @@ impl AppServer {
     }
 
     pub fn output_key(
-        &self,
+        &mut self,
         peer: AppPeerPtr,
         why: KeyOutputReason,
         key: &SymKey,
     ) -> anyhow::Result<()> {
         let peerid = peer.lower().get(&self.crypt).pidt()?;
-        let ap = peer.get_app(self);
-
         if self.verbose() {
             let msg = match why {
                 KeyOutputReason::Exchanged => "Exchanged key with peer",
@@ -749,6 +796,7 @@ impl AppServer {
             info!("{} {}", msg, fmt_b64(&*peerid));
         }
 
+        let ap = peer.get_app_mut(self);
         if let Some(of) = ap.outfile.as_ref() {
             // This might leave some fragments of the secret on the stack;
             // in practice this is likely not a problem because the stack likely
@@ -771,42 +819,8 @@ impl AppServer {
             );
         }
 
-        if let Some(owg) = ap.outwg.as_ref() {
-            let mut child = match Command::new("wg")
-                .arg("set")
-                .arg(&owg.dev)
-                .arg("peer")
-                .arg(&owg.pk)
-                .arg("preshared-key")
-                .arg("/dev/stdin")
-                .stdin(Stdio::piped())
-                .args(&owg.extra_params)
-                .spawn()
-            {
-                Ok(x) => x,
-                Err(e) => {
-                    if e.kind() == std::io::ErrorKind::NotFound {
-                        anyhow::bail!("Could not find wg command");
-                    } else {
-                        return Err(anyhow::Error::new(e));
-                    }
-                }
-            };
-            b64_writer(child.stdin.take().unwrap()).write_all(key.secret())?;
-
-            thread::spawn(move || {
-                let status = child.wait();
-
-                if let Ok(status) = status {
-                    if status.success() {
-                        debug!("successfully passed psk to wg")
-                    } else {
-                        error!("could not pass psk to wg {:?}", status)
-                    }
-                } else {
-                    error!("wait failed: {:?}", status)
-                }
-            });
+        if let Some(adapter ) = ap.adapter.as_mut() {
+            adapter.update_wg_psk(key)?;
         }
 
         Ok(())
@@ -942,3 +956,4 @@ impl AppServer {
         Ok(None)
     }
 }
+
diff --git a/rosenpass/src/cli.rs b/rosenpass/src/cli.rs
index 698247c..d62a659 100644
--- a/rosenpass/src/cli.rs
+++ b/rosenpass/src/cli.rs
@@ -6,7 +6,7 @@ use rosenpass_secret_memory::file::StoreSecret;
 use rosenpass_util::file::{LoadValue, LoadValueB64};
 use std::path::PathBuf;
 
-use crate::app_server::AppServer;
+use crate::app_server::{AppServer, UnixWireguardOut};
 use crate::app_server::{self, AppServerTest};
 use crate::protocol::{SPk, SSk, SymKey};
 
@@ -305,7 +305,7 @@ impl CliCommand {
         let pk = SPk::load(&config.public_key)?;
 
         // start an application server
-        let mut srv = std::boxed::Box::<AppServer>::new(AppServer::new(
+        let mut srv = std::boxed::Box::<AppServer::<UnixWireguardOut>>::new(AppServer::new(
             sk,
             pk,
             config.listen,
@@ -319,7 +319,7 @@ impl CliCommand {
                 cfg_peer.pre_shared_key.map(SymKey::load_b64).transpose()?,
                 SPk::load(&cfg_peer.public_key)?,
                 cfg_peer.key_out,
-                cfg_peer.wg.map(|cfg| app_server::WireguardOut {
+                cfg_peer.wg.map(|cfg| app_server::UnixWireguardOut {
                     dev: cfg.device,
                     pk: cfg.peer,
                     extra_params: cfg.extra_params,
diff --git a/rp/Cargo.toml b/rp/Cargo.toml
index a86eb90..1d70e6b 100644
--- a/rp/Cargo.toml
+++ b/rp/Cargo.toml
@@ -33,6 +33,10 @@ netlink-packet-core = "0.7"
 netlink-packet-generic = "0.3"
 netlink-packet-wireguard = "0.2"
 
+[target.'cfg(windows)'.dependencies]
+wireguard-nt = "0.5.0"
+ipnet = {workspace = true}
+
 [dev-dependencies]
 tempfile = "3"
 stacker = "0.1.15"
diff --git a/rp/build.rs b/rp/build.rs
new file mode 100644
index 0000000..ee7ec2f
--- /dev/null
+++ b/rp/build.rs
@@ -0,0 +1,9 @@
+// build.rs
+use std::env;
+
+fn main() {
+    //Increase stack size for Windows
+    if env::var("CARGO_CFG_TARGET_ENV").as_deref() == Ok("msvc") {
+        println!("cargo:rustc-link-arg=/stack:{}", 16 * 1024 * 1024);
+    }
+}
\ No newline at end of file
diff --git a/rp/src/exchange.rs b/rp/src/exchange.rs
index 5648214..c0b4773 100644
--- a/rp/src/exchange.rs
+++ b/rp/src/exchange.rs
@@ -1,6 +1,9 @@
-use std::{net::SocketAddr, path::PathBuf};
+use std::{cell::RefCell, net::SocketAddr, path::PathBuf, rc::Rc};
 
-use anyhow::Result;
+use anyhow::{anyhow, Result};
+use ipnet::IpNet;
+use rosenpass::app_server::WgPeerAdapter;
+use wireguard_nt::SetPeer;
 
 #[derive(Default)]
 pub struct ExchangePeer {
@@ -19,7 +22,7 @@ pub struct ExchangeOptions {
     pub peers: Vec<ExchangePeer>,
 }
 
-#[cfg(not(any(target_os = "linux", target_os = "freebsd")))]
+#[cfg(not(any(target_os = "linux", target_os = "freebsd", target_os = "windows")))]
 pub async fn exchange(_: ExchangeOptions) -> Result<()> {
     use anyhow::anyhow;
 
@@ -135,7 +138,7 @@ pub async fn exchange(options: ExchangeOptions) -> Result<()> {
     use anyhow::anyhow;
     use netlink_packet_wireguard::{constants::WG_KEY_LEN, nlas::WgDeviceAttrs};
     use rosenpass::{
-        app_server::{AppServer, WireguardOut},
+        app_server::{AppServer, UnixWireguardOut},
         config::Verbosity,
         protocol::{SPk, SSk, SymKey},
     };
@@ -228,7 +231,7 @@ pub async fn exchange(options: ExchangeOptions) -> Result<()> {
             .transpose()?,
             SPk::load(&pqpk)?,
             None,
-            Some(WireguardOut {
+            Some(UnixWireguardOut {
                 dev: link_name.clone(),
                 pk: fs::read_to_string(wgpk)?,
                 extra_params,
@@ -259,3 +262,307 @@ pub async fn exchange(options: ExchangeOptions) -> Result<()> {
         }
     }
 }
+
+#[cfg(target_os = "windows")]
+struct WindowsWireguardOut {
+    adapter: Rc<RefCell<wireguard_nt::Adapter>>,
+    peer: wireguard_nt::SetPeer,
+    adapter_ip: IpNet,
+}
+
+#[cfg(target_os = "windows")]
+impl WindowsWireguardOut {
+    fn new(
+        adapter: Rc<RefCell<wireguard_nt::Adapter>>,
+        adapter_ip: IpNet,
+        peer: wireguard_nt::SetPeer,
+    ) -> anyhow::Result<Self> {
+        let wgout = WindowsWireguardOut {
+            adapter,
+            adapter_ip,
+            peer,
+        };
+
+        let config = wgout.adapter.borrow_mut().get_config();
+
+        let mut peers: Vec<wireguard_nt::SetPeer> = config
+            .peers
+            .iter()
+            .filter_map(|p| {
+                //Duplicate entry
+                if p.endpoint == wgout.peer.endpoint
+                    && Some(p.public_key) == wgout.peer.public_key
+                    && p.allowed_ips == wgout.peer.allowed_ips
+                {
+                    None
+                } else {
+                    Some(SetPeer {
+                        preshared_key: Some(p.preshared_key),
+                        public_key: Some(p.public_key),
+                        keep_alive: Some(p.persistent_keepalive),
+                        allowed_ips: p.allowed_ips.clone(),
+                        endpoint: p.endpoint,
+                    })
+                }
+            })
+            .collect();
+
+        peers.push(wgout.peer.clone());
+
+        let config = wireguard_nt::SetInterface {
+            //Wireguard listen port is one added
+            listen_port: Some(config.listen_port + 1),
+            public_key: Some(config.public_key),
+            private_key: Some(config.private_key),
+            peers,
+        };
+
+        wgout.adapter.borrow_mut().down();
+
+        wgout
+            .adapter
+            .borrow_mut()
+            .set_config(&config)
+            .map_err(|err| anyhow!("Error setting adapter config {}", err))?;
+
+        wgout
+            .adapter
+            .borrow_mut()
+            .set_default_route(&[wgout.adapter_ip.clone()], &config)
+            .map_err(|err| anyhow!("Error setting adapter default route {}", err))?;
+        wgout.adapter.borrow_mut().up();
+
+        Ok(wgout)
+    }
+}
+
+#[cfg(target_os = "windows")]
+impl WgPeerAdapter for WindowsWireguardOut {
+    fn update_wg_psk(&mut self, key: &rosenpass_secret_memory::Secret<32>) -> anyhow::Result<()> {
+        let config = self.adapter.borrow_mut().get_config();
+
+        let mut peer_found = false;
+        let peers: Vec<wireguard_nt::SetPeer> = config
+            .peers
+            .iter()
+            .map(|p| {
+                let mut peer = SetPeer {
+                    preshared_key: Some(p.preshared_key),
+                    public_key: Some(p.public_key),
+                    keep_alive: Some(p.persistent_keepalive),
+                    allowed_ips: p.allowed_ips.clone(),
+                    endpoint: p.endpoint,
+                };
+
+                if p.endpoint == self.peer.endpoint
+                    && Some(p.public_key) == self.peer.public_key
+                    && p.allowed_ips == self.peer.allowed_ips
+                {
+                    peer_found = true;
+                    peer.preshared_key = Some(key.secret().clone());
+                }
+                peer
+            })
+            .collect();
+
+        if !peer_found {
+            return Err(anyhow!("Peer not found"));
+        }
+
+        let config = wireguard_nt::SetInterface {
+            listen_port: Some(config.listen_port),
+            public_key: Some(config.public_key),
+            private_key: Some(config.private_key),
+            peers,
+        };
+
+        self.adapter.borrow_mut().down();
+
+        self.adapter
+            .borrow_mut()
+            .set_config(&config)
+            .map_err(|err| anyhow!("Error setting adapter config {}", err))?;
+
+        self.adapter
+            .borrow_mut()
+            .set_default_route(&[self.adapter_ip.clone()], &config)
+            .map_err(|err| anyhow!("Error setting adapter default route {}", err))?;
+
+        self.adapter.borrow_mut().up();
+
+        Ok(())
+    }
+}
+
+#[cfg(target_os = "windows")]
+pub async fn exchange(options: ExchangeOptions) -> Result<()> {
+    use std::str::FromStr;
+
+    use anyhow::bail;
+    use base64::Engine;
+    use rosenpass::{
+        app_server::AppServer,
+        config::Verbosity,
+        protocol::{SPk, SSk, SymKey},
+    };
+    use rosenpass_secret_memory::Secret;
+    use rosenpass_util::file::{LoadValue as _, LoadValueB64};
+    use zeroize::Zeroize;
+
+    let wireguard = unsafe { wireguard_nt::load_from_path("wireguard-nt/bin/amd64/wireguard.dll") }
+        .expect("Failed to load wireguard dll");
+
+    let adapter = match wireguard_nt::Adapter::open(&wireguard, "rosenpass") {
+        Ok(_) => {
+            bail!("Existing adapter already configured");
+        }
+        Err(_) => match wireguard_nt::Adapter::create(&wireguard, "WireGuard", "Rosenpass", None) {
+            Ok(a) => a,
+            Err(_) => {
+                bail!("Error creating adapter");
+            }
+        },
+    };
+
+    let wgsk_path = options.private_keys_dir.join("wgsk");
+
+    let wgsk = Secret::<32>::load_b64(wgsk_path)?;
+
+    if let Some(listen) = options.listen {
+        if listen.port() == u16::MAX {
+            return Err(anyhow!("You may not use {} as the listen port.", u16::MAX));
+        }
+    }
+
+    let pqsk = options.private_keys_dir.join("pqsk");
+    let pqpk = options.private_keys_dir.join("pqpk");
+
+    let sk = SSk::load(&pqsk)?;
+    let pk = SPk::load(&pqpk)?;
+
+    let mut wg_private_key = [0u8; 32];
+    wg_private_key.copy_from_slice(wgsk.secret());
+
+    let wgpk: x25519_dalek::PublicKey = {
+        let mut secret = x25519_dalek::StaticSecret::from(wgsk.secret().clone());
+        let public = x25519_dalek::PublicKey::from(&secret);
+        secret.zeroize();
+        public
+    };
+
+    let mut wg_public_key = [0u8; 32];
+    wg_public_key.copy_from_slice(wgpk.as_bytes());
+
+    let adapter_config = wireguard_nt::SetInterface {
+        listen_port: options.listen.map(|s| s.port() + 1),
+        public_key: Some(wg_public_key),
+        private_key: Some(wg_private_key),
+        peers: vec![],
+    };
+
+    let adapter_ip = IpNet::from_str("192.168.30.2/24")?;
+    if adapter
+        .set_default_route(&[adapter_ip.clone()], &adapter_config)
+        .is_err()
+    {
+        bail!("Could not set basic adapter config");
+    }
+
+    if adapter.set_config(&adapter_config).is_err() {
+        bail!("Could not set basic adapter config");
+    }
+
+    if adapter.up().is_err() {
+        bail!("Could not bring up adapter");
+    }
+    let adapter = Rc::new(RefCell::new(adapter));
+
+    let mut srv = Box::new(AppServer::new(
+        sk,
+        pk,
+        if let Some(listen) = options.listen {
+            vec![listen]
+        } else {
+            Vec::with_capacity(0)
+        },
+        if options.verbose {
+            Verbosity::Verbose
+        } else {
+            Verbosity::Quiet
+        },
+        None,
+    )?);
+
+    for peer in options.peers {
+        let wgpk = peer.public_keys_dir.join("wgpk");
+        let pqpk = peer.public_keys_dir.join("pqpk");
+        let psk = peer.public_keys_dir.join("psk");
+
+        let wgpk = Secret::from_slice(
+            &base64::engine::general_purpose::STANDARD.decode(std::fs::read_to_string(wgpk)?)?,
+        );
+
+        let psk = if psk.exists() {
+            Some(SymKey::load_b64(psk))
+        } else {
+            None
+        }
+        .transpose()?;
+
+        let pk = SPk::load(&pqpk)?;
+
+        let endpoint = if let Some(mut endpoint) = peer.endpoint {
+            endpoint.set_port(endpoint.port() + 1);
+            endpoint
+        } else {
+            bail!("No peer endpoint specified");
+        };
+
+        let allowed_ips = peer
+            .allowed_ips
+            .into_iter()
+            .map(|cidr_ip| IpNet::from_str(&cidr_ip).unwrap())
+            .collect();
+
+        let mut public_key = [0u8; 32];
+        public_key.copy_from_slice(wgpk.secret());
+
+        let wg_peer = wireguard_nt::SetPeer {
+            public_key: Some(public_key),
+            preshared_key: Some(wgpk.clone().secret().clone()),
+            keep_alive: peer.persistent_keepalive.map(|ka| ka as u16),
+            endpoint,
+            allowed_ips,
+        };
+
+        let adapter = WindowsWireguardOut::new(adapter.clone(), adapter_ip.clone(), wg_peer)?;
+
+        srv.add_peer(
+            psk.clone(),
+            pk,
+            None,
+            Some(adapter),
+            peer.endpoint.map(|x| x.to_string()),
+        )?;
+    }
+
+    let out = srv.event_loop();
+
+    match out {
+        Ok(_) => Ok(()),
+        Err(e) => {
+            // Check if the returned error is actually EINTR, in which case, the run actually succeeded.
+            let is_ok = if let Some(e) = e.root_cause().downcast_ref::<std::io::Error>() {
+                matches!(e.kind(), std::io::ErrorKind::Interrupted)
+            } else {
+                false
+            };
+
+            if is_ok {
+                Ok(())
+            } else {
+                Err(e)
+            }
+        }
+    }
+}
diff --git a/rp/src/key.rs b/rp/src/key.rs
index a876905..99860a8 100644
--- a/rp/src/key.rs
+++ b/rp/src/key.rs
@@ -1,10 +1,12 @@
 use std::{
     fs::{self, DirBuilder, OpenOptions},
     io::Write,
-    os::unix::fs::{DirBuilderExt, OpenOptionsExt, PermissionsExt},
     path::Path,
 };
 
+#[cfg(target_family = "unix")]
+use std::os::unix::fs::{DirBuilderExt, OpenOptionsExt, PermissionsExt};
+
 use anyhow::{anyhow, Result};
 use base64::Engine;
 use rosenpass_util::file::LoadValueB64;
@@ -15,7 +17,7 @@ use rosenpass_cipher_traits::Kem;
 use rosenpass_ciphers::kem::StaticKem;
 use rosenpass_secret_memory::{file::StoreSecret as _, Secret};
 
-#[cfg(not(target_family = "unix"))]
+#[cfg(not(any(target_family = "unix",target_family="windows")))]
 pub fn genkey(_: &Path) -> Result<()> {
     Err(anyhow!(
         "Your system {} is not yet supported. We are happy to receive patches to address this :)",
@@ -23,6 +25,63 @@ pub fn genkey(_: &Path) -> Result<()> {
     ))
 }
 
+#[cfg(target_family = "windows")]
+pub fn genkey(private_keys_dir: &Path) -> Result<()> {
+    if private_keys_dir.exists() {
+        /* 
+        if fs::metadata(private_keys_dir)?.permissions().mode() != 0o700 {
+            return Err(anyhow!(
+                "Directory {:?} has incorrect permissions: please use 0700 for proper security.",
+                private_keys_dir
+            ));
+        }
+        */
+    } else {
+        DirBuilder::new()
+            .recursive(true)
+            .create(private_keys_dir)?;
+    }
+
+    let wgsk_path = private_keys_dir.join("wgsk");
+    let pqsk_path = private_keys_dir.join("pqsk");
+    let pqpk_path = private_keys_dir.join("pqpk");
+
+    if !wgsk_path.exists() {
+        let wgsk: Secret<32> = Secret::random();
+
+        let mut wgsk_file = OpenOptions::new()
+            .write(true)
+            .create(true)
+            .open(wgsk_path)?;
+
+        wgsk_file.write_all(
+            base64::engine::general_purpose::STANDARD
+                .encode(wgsk.secret())
+                .as_bytes(),
+        )?;
+    } else {
+        eprintln!(
+            "WireGuard secret key already exists at {:#?}: not regenerating",
+            wgsk_path
+        );
+    }
+
+    if !pqsk_path.exists() && !pqpk_path.exists() {
+        let mut pqsk = SSk::random();
+        let mut pqpk = SPk::random();
+        StaticKem::keygen(pqsk.secret_mut(), pqpk.secret_mut())?;
+        pqpk.store_secret(pqpk_path)?;
+        pqsk.store_secret(pqsk_path)?;
+    } else {
+        eprintln!(
+            "Rosenpass keys already exist in {:#?}: not regenerating",
+            private_keys_dir
+        );
+    }
+
+    Ok(())
+}
+
 #[cfg(target_family = "unix")]
 pub fn genkey(private_keys_dir: &Path) -> Result<()> {
     if private_keys_dir.exists() {
diff --git a/util/src/file.rs b/util/src/file.rs
index b523220..89e877f 100644
--- a/util/src/file.rs
+++ b/util/src/file.rs
@@ -1,7 +1,7 @@
 use anyhow::ensure;
 use std::fs::File;
 use std::io::Read;
-use std::os::unix::fs::OpenOptionsExt;
+
 use std::result::Result;
 use std::{fs::OpenOptions, path::Path};
 
@@ -14,10 +14,17 @@ pub enum Visibility {
 pub fn fopen_w<P: AsRef<Path>>(path: P, visibility: Visibility) -> std::io::Result<File> {
     let mut options = OpenOptions::new();
     options.create(true).write(true).read(false).truncate(true);
-    match visibility {
-        Visibility::Public => options.mode(0o644),
-        Visibility::Secret => options.mode(0o600),
-    };
+
+    //TODO: Visibilty for windows target family
+
+    #[cfg(target_family = "unix")]
+    {
+        use std::os::unix::fs::OpenOptionsExt;
+        match visibility {
+            Visibility::Public => options.mode(0o644),
+            Visibility::Secret => options.mode(0o600),
+        };
+    }
     options.open(path)
 }
 /// Open a file readable
