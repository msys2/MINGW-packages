diff --git a/demos/ppl_pips/ppl_pips.cc b/demos/ppl_pips/ppl_pips.cc.modified
index efc1a90..66b85e9 100644
--- a/demos/ppl_pips/ppl_pips.cc
+++ b/demos/ppl_pips/ppl_pips.cc.modified
@@ -817,7 +817,7 @@ main(int argc, char* argv[]) try {
 
 //  POLYHEDRON_TYPE ph;
 //  Representation rep = read_polyhedron(input(), ph);
-  std::auto_ptr<PIP_Parser> parser;
+  std::unique_ptr<PIP_Parser> parser;
   if (piplib_format) {
     parser.reset(new PIP_PipLib_Parser);
   }
@@ -838,7 +838,7 @@ main(int argc, char* argv[]) try {
     parser->output_solution_tree(*output_stream_p);
   }
   else {
-    std::auto_ptr<PPL::PIP_Problem> pip_p;
+    std::unique_ptr<PPL::PIP_Problem> pip_p;
     // Perform a time benchmark loop executing the resolution several times.
     for (long i = 0; i < loop_iterations; ++i) {
       pip_p.reset(new PPL::PIP_Problem(pip));
diff --git a/src/PIP_Tree.cc b/src/PIP_Tree.cc.modified
index c7ae0bc..ba92843 100644
--- a/src/PIP_Tree.cc
+++ b/src/PIP_Tree.cc.modified
@@ -1101,8 +1101,8 @@ PIP_Decision_Node::PIP_Decision_Node(const PIP_Decision_Node& y)
     false_child = y.false_child->clone();
     false_child->set_parent(this);
   }
-  // Protect false_child from exception safety issues via std::auto_ptr.
-  std::auto_ptr<PIP_Tree_Node> wrapped_node(false_child);
+  // Protect false_child from exception safety issues via std::unique_ptr.
+  std::unique_ptr<PIP_Tree_Node> wrapped_node(false_child);
   if (y.true_child != 0) {
     true_child = y.true_child->clone();
     true_child->set_parent(this);
@@ -3140,8 +3140,8 @@ PIP_Solution_Node::solve(const PIP_Problem& pip,
 
       // Create a solution node for the "true" version of current node.
       PIP_Tree_Node* t_node = new PIP_Solution_Node(*this, No_Constraints());
-      // Protect it from exception safety issues via std::auto_ptr.
-      std::auto_ptr<PIP_Tree_Node> wrapped_node(t_node);
+      // Protect it from exception safety issues via std::unique_ptr.
+      std::unique_ptr<PIP_Tree_Node> wrapped_node(t_node);
 
       // Add parametric constraint to context.
       ctx.add_row(t_test);
