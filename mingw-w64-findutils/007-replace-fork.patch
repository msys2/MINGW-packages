--- a/find/defs.h
+++ b/find/defs.h
@@ -343,6 +343,9 @@
 
 /* find library function declarations.  */
 
+/* xgetcwd.c */
+char *xgetcwd (void);
+
 /* find global function declarations.  */
 
 /* SymlinkOption represents the choice of
--- a/find/exec.c
+++ b/find/exec.c
@@ -277,6 +277,91 @@
   return ok;
 }
 
+#ifdef __MINGW32__
+
+/* More sensible spawnvp function: the library one requires arguments
+   with embedded special characters to be quoted.  */
+static char **
+quote_spawn_args (const char * const *argv)
+{
+  /* These characters should include anything that is special to _any_
+     program, including both Windows and Unixy shells.  */
+  const char need_quotes[] = " \t#;\"\'*?[]&|<>|(){}$`^";
+  int i = 0;
+  char **qargv;
+
+  while (argv[i])
+    i++;
+  qargv = malloc ((i + 1)*sizeof(argv[0]));
+
+  if (!qargv)
+    return NULL;
+  for (i = 0; argv[i]; i++)
+    {
+      if (strpbrk (argv[i], need_quotes))
+	{
+	  size_t len = strlen (argv[i]) + 3;
+	  const char *p = argv[i];
+	  char *q;
+
+	  for ( ; *p; p++)
+	    {
+	      if (*p == '\"')
+		len++;
+	    }
+	  qargv[i] = xmalloc (len);
+	  (qargv[i])[0] = '\"';
+	  for (p = argv[i], q = qargv[i] + 1; *p; p++)
+	    {
+	      if (*p == '\"')
+		*q++ = '\\';
+	      *q++ = *p;
+	    }
+	  memcpy (q, "\"", 2);
+	}
+      else
+	qargv[i] = strdup (argv[i]);
+#if 0
+      printf ("%d: `%s'\n", i, qargv[i]);
+#endif
+    }
+  qargv[i] = NULL;
+
+  return qargv;
+}
+
+static void
+free_args (char **args)
+{
+  if (args)
+    {
+      int i;
+
+      for (i = 0; args[i]; i++)
+	free (args[i]);
+      free (args);
+    }
+}
+
+int
+w32_spawnvp (int mode, const char *cmd, const char * const *argv)
+{
+  int ret;
+  char **qargv = quote_spawn_args (argv);
+
+  if (!qargv)
+    qargv = (char **)argv;
+#ifdef __MINGW64__
+  ret = spawnvp (mode, cmd, (char * const *)qargv);
+#else
+  ret = spawnvp (mode, cmd, (const char * const *)qargv);
+#endif
+
+  free_args (qargv);
+  return ret;
+}
+
+#endif	/* __MINGW32__ */
 
 int
 launch (struct buildcmd_control *ctl, void *usercontext, int argc, char **argv)
@@ -309,9 +394,63 @@
   if (first_time)
     {
       first_time = 0;
+#ifdef SIGCHLD
       signal (SIGCHLD, SIG_DFL);
+#endif
     }
+  
+#if defined(__MINGW32__) || defined(_MSC_VER) || defined(__MSDOS__)
+{
+  char *cwd;
+  int wait_ret = 0;
+  cwd = xgetcwd ();
 
+  assert (NULL != execp->wd_for_exec);
+  if (!prep_child_for_exec (execp->close_stdin, execp->wd_for_exec))
+    {
+      _exit (1);
+    }
+  else
+    {
+      if (fd_leak_check_is_enabled ())
+        {
+          complain_about_leaky_fds ();
+        }
+    }
+#ifdef __MSDOS__
+  child_pid = spawnvp (P_WAIT, argv[0], argv);
+  if (child_pid == -1)
+    error (0, errno, "%s", argv[0]);
+  execp->last_child_status |= (child_pid & 0xff);
+#else
+#ifdef __MINGW32__
+  child_pid = w32_spawnvp (_P_NOWAIT, argv[0],
+			   (const char * const *)argv);
+#else
+  child_pid = spawnvp (_P_NOWAIT, argv[0],
+		       (const char * const *)argv);
+#endif
+  if (child_pid == -1)
+    error (0, errno, "%s", argv[0]);
+  else
+    wait_ret = _cwait (&execp->last_child_status, child_pid, 0);
+  if (wait_ret == -1)
+    {
+      error (0, errno, _("error waiting for %s"), argv[0]);
+      state.exit_status = 1;
+      return 0;		/* FAIL */
+    }
+#endif
+  
+  if (chdir (cwd) < 0)
+    {
+      error (0, errno, "%s", cwd);
+      _exit (1);
+    }
+  if (cwd)
+	  free (cwd);
+}
+#else /* _WIN32 */
   child_pid = fork ();
   if (child_pid == -1)
     die (EXIT_FAILURE, errno, _("cannot fork"));
@@ -351,6 +490,7 @@
 	  return 0;		/* FAIL */
 	}
     }
+#endif /* _WIN32 */ 
 
   if (WIFSIGNALED (execp->last_child_status))
     {
--- a/xargs/xargs.c
+++ b/xargs/xargs.c
@@ -1244,13 +1268,15 @@
 
      We use 0 here in order to avoid generating a data structure that appears
      to indicate that we (the child) have a child. */
+#if !defined(__MINGW32__) && !defined(_MSC_VER)
   unsigned int slot = add_proc (0);
   set_slot_var (slot);
+#endif
 
   if (!keep_stdin || open_tty)
     {
       int fd;
       const char *inputfile = open_tty ? "/dev/tty" : "/dev/null";
 
       close (0);
       if ((fd = open (inputfile, O_RDONLY)) < 0)
@@ -1315,7 +1345,33 @@
     {
       if (!query_before_executing && print_command)
 	print_args (false);
-
+#if defined(__MINGW32__) || defined(_MSC_VER) || defined(__MSDOS__)
+      {
+	char *cwd = xgetcwd ();
+	int e;
+	prep_child_for_exec();
+#ifdef __MSDOS__
+	child = spawnvp (P_WAIT, argv[0], argv);
+#else
+	while ((child = spawnvp (_P_NOWAIT, argv[0],
+# ifdef __MINGW64__
+				 (char * const *)argv)) < 0
+# else
+				 (const char * const *)argv)) < 0
+# endif
+	       && errno == ENOMEM && procs_executing)
+	  wait_for_proc (false, 1u);
+#endif
+	e = errno;	/* errno will be clobbered by wait_for_proc and chdir */
+	chdir (cwd);
+	if (cwd)
+	  free (cwd);
+	if (child == -1 && !(e == ENOENT || e == ENOEXEC))
+	  error (0, e, "%s", argv[0]);
+      }
+      add_proc (child);
+    }
+#else
       /* Before forking, reap any already-exited child. We do this so
 	 that we don't leave unreaped children around while we build a
 	 new command line.  For example this command will spend most
@@ -1458,6 +1515,7 @@
 	} /* switch on bytes read */
       close (fd[0]);
     }
+#endif
   return 1;			/* Success */
 }
 
@@ -1512,12 +1570,45 @@
 static void
 wait_for_proc (bool all, unsigned int minreap)
 {
+#if defined(__MSDOS__)
+  if (procs_executing)
+	procs_executing--;
+#else
   unsigned int reaped = 0;
 
   while (procs_executing)
     {
       unsigned int i;
       int status;
+
+#if defined(__MINGW32__) || defined(_MSC_VER)
+      do
+	{
+	  for (i = 0; i < pids_alloc; i++)
+	    {
+	      DWORD waited, dstatus;
+
+	      if (!pids[i])
+		continue;
+	      if (pids[i] == -1) /* spawnvp failed */
+		{
+		  status = 127;	/* mimic Unixy shell */
+		  break;
+		}
+	      waited = WaitForSingleObject ((HANDLE)pids[i], 10UL);
+	      if (waited == WAIT_OBJECT_0) /* this process finished */
+		{
+		  GetExitCodeProcess ((HANDLE)pids[i], &dstatus);
+		  CloseHandle ((HANDLE)pids[i]);
+		  status = dstatus;
+		  break;
+		}
+	      else if (waited == WAIT_FAILED)
+		error (1, errno, _("error waiting for child process"));
+	    }
+	}
+      while (i == pids_alloc);	/* A child died that we didn't start? */    
+#else      
       pid_t pid;
       int wflags = 0;
 
@@ -1589,7 +1680,8 @@
 	    }
 	  break;
 	}
-
+#endif
+      
       /* Remove the child from the list.  */
       pids[i] = 0;
       procs_executing--;
@@ -1606,7 +1698,14 @@
 	       _("%s: terminated by signal %d"), bc_state.cmd_argv[0], WTERMSIG (status));
       if (WEXITSTATUS (status) != 0)
 	child_error = XARGS_EXIT_CLIENT_EXIT_NONZERO;
+
+      
+#if defined(__MINGW32__) || defined(_MSC_VER)
+      if (!all)
+	break;
+#endif
     }
+#endif
 }
 
 /* Wait for all child processes to finish.  */
