For some reason, `clang++` considers the following two operators
ambiguous (conflicting types):
* inline bool operator == (const frame_info& a, const frame_info& b)
  from liboctave/util/quit.h:84:13
* __inline bool operator== (REFGUID guidOne, REFGUID guidOther)
  from /clang64/include/guiddef.h:180:15

Is that a compiler bug? Or an issue with the MinGW headers?
Fwiw, this compiles fine with clang++ on Linux or Mac OS, or with g++ on
Windows.

To avoid that conflict, make Octave's operator a member function of
octave::frame_info.

Since clang++ seems to consider both operators as being able to convert
input of an overlapping group of classes, it's not entirely clear whether
this might cause the wrong operator overload to be used in some places in
Octave.

diff -r 96ed8d1d0c59 liboctave/util/quit.h
--- a/liboctave/util/quit.h	Sat Mar 04 00:59:48 2023 -0500
+++ b/liboctave/util/quit.h	Fri Mar 10 18:19:00 2023 +0100
@@ -70,6 +70,14 @@
 
   int column (void) const { return m_column; }
 
+  inline bool operator == (const frame_info& other) const
+  {
+    return (file_name () == other.file_name ()
+            && fcn_name () == other.fcn_name ()
+            && line () == other.line ()
+            && column () == other.column ());
+  }
+
 private:
 
   std::string m_file_name;
@@ -81,14 +89,6 @@
   int m_column;
 };
 
-inline bool operator == (const frame_info& a, const frame_info& b)
-{
-  return (a.file_name () == b.file_name ()
-          && a.fcn_name () == b.fcn_name ()
-          && a.line () == b.line ()
-          && a.column () == b.column ());
-}
-
 class OCTAVE_EXCEPTION_API execution_exception : public std::runtime_error
 {
 public: