diff --git a/elf/lto-unix.cc b/elf/lto-unix.cc
index 8f3a50fc..50e6e0dc 100644
--- a/elf/lto-unix.cc
+++ b/elf/lto-unix.cc
@@ -200,9 +200,9 @@ static PluginStatus release_input_file(const void *handle) {
   LOG << "release_input_file\n";
 
   ObjectFile<E> &file = *(ObjectFile<E> *)handle;
-  if (file.mf->fd != -1) {
-    close(file.mf->fd);
-    file.mf->fd = -1;
+  if (file.mf->fd) {
+    CloseHandle(file.mf->fd);
+    file.mf->fd = nullptr;
   }
   return LDPS_OK;
 }
@@ -570,7 +570,7 @@ static ElfSym<E> to_elf_sym(PluginSymbol &psym) {
 // Returns false if it's GCC.
 template <typename E>
 static bool is_llvm(Context<E> &ctx) {
-  return ctx.arg.plugin.ends_with("LLVMgold.so");
+  return ctx.arg.plugin.ends_with("LLVMgold.dll");
 }
 
 // Returns true if a given linker plugin supports the get_symbols_v3 API.
@@ -590,11 +590,13 @@ create_plugin_input_file(Context<E> &ctx, MappedFile *mf) {
   file.offset = mf->get_offset();
   file.filesize = mf->size;
 
-  if (mf2->fd == -1)
-    mf2->fd = open(file.name, O_RDONLY);
+  if (!mf2->fd)
+    mf2->fd = CreateFileA(file.name, GENERIC_READ,
+                          FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
+                          nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
   file.fd = mf2->fd;
 
-  if (file.fd == -1)
+  if (!file.fd)
     Fatal(ctx) << "cannot open " << file.name << ": " << errno_string();
   return file;
 }
@@ -645,8 +647,8 @@ ObjectFile<E> *read_lto_object(Context<E> &ctx, MappedFile *mf) {
   // open files" issue, we close fd only for GCC. This is ugly, though.
   if (!is_llvm(ctx)) {
     MappedFile *mf2 = mf->parent ? mf->parent : mf;
-    close(mf2->fd);
-    mf2->fd = -1;
+    CloseHandle(mf2->fd);
+    mf2->fd = nullptr;
   }
 
   // Create a symbol strtab
diff --git a/elf/lto.h b/elf/lto.h
index 489a06fa..6b1d938b 100644
--- a/elf/lto.h
+++ b/elf/lto.h
@@ -73,7 +73,7 @@ enum PluginOutputFileType {
 
 struct PluginInputFile {
   const char *name;
-  i32 fd;
+  HANDLE fd;
   u64 offset;
   u64 filesize;
   void *handle;
