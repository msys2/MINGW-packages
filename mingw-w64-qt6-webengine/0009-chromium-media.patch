diff -ur a/src/3rdparty/chromium/media/audio/BUILD.gn b/src/3rdparty/chromium/media/audio/BUILD.gn
--- a/src/3rdparty/chromium/media/audio/BUILD.gn	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/audio/BUILD.gn	2024-01-07 20:58:15.274810000 +0800
@@ -223,13 +223,23 @@
       "win/waveout_output_win.cc",
       "win/waveout_output_win.h",
     ]
+    if (is_mingw) {
+      sources -= [
+        "win/audio_low_latency_input_win.cc",
+        "win/audio_low_latency_input_win.h",
+        "win/audio_low_latency_output_win.cc",
+        "win/audio_low_latency_output_win.h",
+        #"win/audio_manager_win.cc",
+        #"win/audio_manager_win.h",
+      ]
+    }
 
     deps += [ "//media/base/win:media_foundation_util" ]
 
     libs += [
-      "dxguid.lib",
-      "setupapi.lib",
-      "winmm.lib",
+      "dxguid",
+      "setupapi",
+      "winmm",
     ]
   }
 
diff -ur a/src/3rdparty/chromium/media/audio/audio_manager.cc b/src/3rdparty/chromium/media/audio/audio_manager.cc
--- a/src/3rdparty/chromium/media/audio/audio_manager.cc	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/audio/audio_manager.cc	2024-01-07 20:58:02.477927700 +0800
@@ -43,7 +43,7 @@
 
   AudioLogFactory* fake_log_factory() { return &fake_log_factory_; }
 
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
   // This should be called before creating an AudioManager in tests to ensure
   // that the creating thread is COM initialized.
   void InitializeCOMForTesting() {
@@ -57,7 +57,7 @@
 
   FakeAudioLogFactory fake_log_factory_;
 
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
   std::unique_ptr<base::win::ScopedCOMInitializer> com_initializer_for_testing_;
 #endif
 
@@ -111,18 +111,20 @@
 std::unique_ptr<AudioManager> AudioManager::Create(
     std::unique_ptr<AudioThread> audio_thread,
     AudioLogFactory* audio_log_factory) {
+//#if !defined(COMPILER_GCC)
   std::unique_ptr<AudioManager> manager =
       CreateAudioManager(std::move(audio_thread), audio_log_factory);
 #if BUILDFLAG(ENABLE_WEBRTC)
   manager->InitializeDebugRecording();
 #endif
   return manager;
+//#endif
 }
 
 // static
 std::unique_ptr<AudioManager> AudioManager::CreateForTesting(
     std::unique_ptr<AudioThread> audio_thread) {
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
   GetHelper()->InitializeCOMForTesting();
 #endif
   return Create(std::move(audio_thread), GetHelper()->fake_log_factory());
diff -ur a/src/3rdparty/chromium/media/audio/simple_sources.cc b/src/3rdparty/chromium/media/audio/simple_sources.cc
--- a/src/3rdparty/chromium/media/audio/simple_sources.cc	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/audio/simple_sources.cc	2024-01-02 19:50:33.689366900 +0800
@@ -8,6 +8,7 @@
 
 #include <algorithm>
 #include <memory>
+#include <cstring>
 
 #include "base/files/file.h"
 #include "base/logging.h"
diff -ur a/src/3rdparty/chromium/media/audio/win/audio_low_latency_input_win.h b/src/3rdparty/chromium/media/audio/win/audio_low_latency_input_win.h
--- a/src/3rdparty/chromium/media/audio/win/audio_low_latency_input_win.h	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/audio/win/audio_low_latency_input_win.h	2024-01-02 19:50:33.736235600 +0800
@@ -61,7 +61,9 @@
 #include <endpointvolume.h>
 #include <stddef.h>
 #include <stdint.h>
+#if defined(COMPILER_MSVC)
 #include <windows.media.effects.h>
+#endif
 #include <wrl/client.h>
 
 #include <memory>
@@ -346,6 +348,7 @@
   // Also added to a UMS histogram.
   bool raw_processing_supported_ = false;
 
+#if defined(COMPILER_MSVC)
   // List of supported and active capture effects for the selected device in
   // default (normal) audio processing mode.
   std::vector<ABI::Windows::Media::Effects::AudioEffectType>
@@ -353,6 +356,7 @@
   // List of supported and active capture effects for the selected device in
   // raw (minimal) audio processing mode. Will be empty in most cases.
   std::vector<ABI::Windows::Media::Effects::AudioEffectType> raw_effect_types_;
+#endif
 
   // Will be enabled if "--use-fake-audio-capture-timestamps" has been added to
   // the command line. This mode can be used in situations where the default
diff -ur a/src/3rdparty/chromium/media/audio/win/core_audio_util_win.cc b/src/3rdparty/chromium/media/audio/win/core_audio_util_win.cc
--- a/src/3rdparty/chromium/media/audio/win/core_audio_util_win.cc	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/audio/win/core_audio_util_win.cc	2024-01-07 17:09:43.235028300 +0800
@@ -183,6 +183,7 @@
     case 2:
       DVLOG(2) << "KSAUDIO_SPEAKER_STEREO";
       return KSAUDIO_SPEAKER_STEREO;
+#if defined(COMPILER_MSVC)
     case 3:
       DVLOG(2) << "KSAUDIO_SPEAKER_2POINT1";
       return KSAUDIO_SPEAKER_2POINT1;
@@ -201,6 +202,7 @@
     case 8:
       DVLOG(2) << "KSAUDIO_SPEAKER_7POINT1";
       return KSAUDIO_SPEAKER_7POINT1;
+#endif
     default:
       DVLOG(1) << "Unsupported channel count: " << channels;
   }
@@ -224,6 +226,7 @@
   return SUCCEEDED(device->GetState(&state)) && (state & DEVICE_STATE_ACTIVE);
 }
 
+#if defined(COMPILER_MSVC)
 HRESULT GetDeviceFriendlyNameInternal(IMMDevice* device,
                                       std::string* friendly_name) {
   // Retrieve user-friendly name of endpoint device.
@@ -247,6 +250,7 @@
 
   return hr;
 }
+#endif
 
 ComPtr<IMMDeviceEnumerator> CreateDeviceEnumeratorInternal(
     bool allow_reinitialize) {
@@ -537,6 +541,7 @@
   return ptr_->wFormatTag == WAVE_FORMAT_EXTENSIBLE && ptr_->cbSize >= 22;
 }
 
+#if defined(COMPILER_MSVC)
 bool CoreAudioUtil::WaveFormatWrapper::IsPcm() const {
   return IsExtensible() ? GetExtensible()->SubFormat == KSDATAFORMAT_SUBTYPE_PCM
                         : ptr_->wFormatTag == WAVE_FORMAT_PCM;
@@ -547,6 +552,7 @@
              ? GetExtensible()->SubFormat == KSDATAFORMAT_SUBTYPE_IEEE_FLOAT
              : ptr_->wFormatTag == WAVE_FORMAT_IEEE_FLOAT;
 }
+#endif
 
 size_t CoreAudioUtil::WaveFormatWrapper::size() const {
   return sizeof(*ptr_) + ptr_->cbSize;
@@ -582,6 +588,7 @@
       &wave_format, " [+] wValidBitsPerSample: %d, dwChannelMask: %s",
       format.GetExtensible()->Samples.wValidBitsPerSample,
       ChannelMaskToString(format.GetExtensible()->dwChannelMask).c_str());
+#if defined(COMPILER_MSVC)
   if (format.IsPcm()) {
     base::StringAppendF(&wave_format, "%s",
                         ", SubFormat: KSDATAFORMAT_SUBTYPE_PCM");
@@ -591,6 +598,9 @@
   } else {
     base::StringAppendF(&wave_format, "%s", ", SubFormat: NOT_SUPPORTED");
   }
+#else
+  base::StringAppendF(&wave_format, "%s", ", SubFormat: NOT_SUPPORTED");
+#endif
   return wave_format;
 }
 
@@ -667,6 +677,7 @@
   if (device_name.unique_id.empty())
     return E_FAIL;
 
+#if defined(COMPILER_MSVC)
   HRESULT hr = GetDeviceFriendlyNameInternal(device, &device_name.device_name);
   if (FAILED(hr))
     return hr;
@@ -675,6 +686,7 @@
   DVLOG(2) << "friendly name: " << device_name.device_name;
   DVLOG(2) << "unique id    : " << device_name.unique_id;
   return hr;
+#endif
 }
 
 std::string CoreAudioUtil::GetAudioControllerID(IMMDevice* device,
@@ -707,8 +719,10 @@
   base::win::ScopedPropVariant instance_id;
   if (FAILED(enumerator->GetDevice(filter_id, &device_node)) ||
       FAILED(device_node->OpenPropertyStore(STGM_READ, &properties)) ||
+#if defined(COMPILER_MSVC)
       FAILED(properties->GetValue(PKEY_Device_InstanceId,
                                   instance_id.Receive())) ||
+#endif
       instance_id.get().vt != VT_LPWSTR) {
     DLOG(ERROR) << "Failed to get instance id of the audio device node";
     return std::string();
@@ -847,11 +861,13 @@
 
   // Verify that the reported format can be mixed by the audio engine in
   // shared mode.
+#if defined(COMPILER_MSVC)
   if (!wrapped_format.IsPcm() && !wrapped_format.IsFloat()) {
     DLOG(ERROR)
         << "Only pure PCM or float audio streams can be mixed in shared mode";
     return AUDCLNT_E_UNSUPPORTED_FORMAT;
   }
+#endif
   // Log a warning for the rare case where |mix_format| only contains a
   // stand-alone WAVEFORMATEX structure but don't return.
   if (!wrapped_format.IsExtensible()) {
diff -ur a/src/3rdparty/chromium/media/audio/win/device_enumeration_win.cc b/src/3rdparty/chromium/media/audio/win/device_enumeration_win.cc
--- a/src/3rdparty/chromium/media/audio/win/device_enumeration_win.cc	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/audio/win/device_enumeration_win.cc	2024-01-02 19:50:33.783098200 +0800
@@ -74,6 +74,7 @@
     device.unique_id =
         base::WideToUTF8(static_cast<WCHAR*>(endpoint_device_id));
 
+#if defined(COMPILER_MSVC)
     // Retrieve user-friendly name of endpoint device.
     // Example: "Microphone (Realtek High Definition Audio)".
     Microsoft::WRL::ComPtr<IPropertyStore> properties;
@@ -96,6 +97,7 @@
       if (!suffix.empty())
         device.device_name += suffix;
     }
+#endif
 
     // Add combination of user-friendly and unique name to the output list.
     device_names->push_back(device);
diff -ur a/src/3rdparty/chromium/media/audio/win/waveout_output_win.cc b/src/3rdparty/chromium/media/audio/win/waveout_output_win.cc
--- a/src/3rdparty/chromium/media/audio/win/waveout_output_win.cc	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/audio/win/waveout_output_win.cc	2024-01-02 19:50:33.798732600 +0800
@@ -107,7 +107,9 @@
   } else {
     format_.dwChannelMask = kChannelsToMask[params.channels()];
   }
+#if defined(COMPILER_MSVC)
   format_.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
+#endif
   format_.Samples.wValidBitsPerSample = format_.Format.wBitsPerSample;
 }
 
diff -ur a/src/3rdparty/chromium/media/base/audio_bus.cc b/src/3rdparty/chromium/media/base/audio_bus.cc
--- a/src/3rdparty/chromium/media/base/audio_bus.cc	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/base/audio_bus.cc	2024-01-02 19:50:33.861312100 +0800
@@ -7,6 +7,7 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include <cstring>
 #include <limits>
 #include <utility>
 
diff -ur a/src/3rdparty/chromium/media/base/audio_parameters.h b/src/3rdparty/chromium/media/base/audio_parameters.h
--- a/src/3rdparty/chromium/media/base/audio_parameters.h	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/base/audio_parameters.h	2024-01-02 19:50:33.892481100 +0800
@@ -28,7 +28,7 @@
 // instead of in Audio{Input,Output}Buffer to be able to calculate size like so.
 // Use a constexpr for the alignment value that's the same as
 // AudioBus::kChannelAlignment, since MSVC doesn't accept the latter to be used.
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
 #pragma warning(push)
 #pragma warning(disable : 4324)  // Disable warning for added padding.
 #endif
@@ -54,7 +54,7 @@
   uint32_t bitstream_data_size;
   uint32_t bitstream_frames;
 };
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
 #pragma warning(pop)
 #endif
 
diff -ur a/src/3rdparty/chromium/media/base/win/BUILD.gn b/src/3rdparty/chromium/media/base/win/BUILD.gn
--- a/src/3rdparty/chromium/media/base/win/BUILD.gn	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/base/win/BUILD.gn	2024-01-02 19:50:33.970646700 +0800
@@ -34,16 +34,18 @@
     "//ui/gfx:color_space",
   ]
   libs = [
-    "d3d11.lib",
-    "mf.lib",
-    "mfplat.lib",
-    "mfreadwrite.lib",
-    "dxguid.lib",
-    "dxgi.lib",
+    "d3d11",
+    "mf",
+    "mfplat",
+    "mfreadwrite",
+    "dxguid",
+    "dxgi",
   ]
 
-  # MediaFoundation is not available on Windows N, so must be delay loaded.
-  all_dependent_configs = [ ":delay_load_mf" ]
+  if (!is_mingw) {
+    # MediaFoundation is not available on Windows N, so must be delay loaded.
+    all_dependent_configs = [ ":delay_load_mf" ]
+  }
 }
 
 component("color_space_util_win") {
@@ -59,13 +61,15 @@
     "//ui/gfx:color_space",
   ]
   libs = [
-    "mf.lib",
-    "mfplat.lib",
-    "mfreadwrite.lib",
+    "mf",
+    "mfplat",
+    "mfreadwrite",
   ]
 
-  # MediaFoundation is not available on Windows N, so must be delay loaded.
-  all_dependent_configs = [ ":delay_load_mf" ]
+  if (!is_mingw) {
+    # MediaFoundation is not available on Windows N, so must be delay loaded.
+    all_dependent_configs = [ ":delay_load_mf" ]
+  }
 }
 
 source_set("mf_cdm_proxy") {
diff -ur a/src/3rdparty/chromium/media/capture/BUILD.gn b/src/3rdparty/chromium/media/capture/BUILD.gn
--- a/src/3rdparty/chromium/media/capture/BUILD.gn	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/capture/BUILD.gn	2024-01-02 19:50:34.001937700 +0800
@@ -244,21 +244,31 @@
       "video/win/video_capture_device_win.cc",
       "video/win/video_capture_device_win.h",
     ]
+    if (is_mingw) {
+      sources -= [
+        "video/win/video_capture_device_factory_win.cc",
+        "video/win/video_capture_device_factory_win.h",
+        "video/win/video_capture_device_mf_win.cc",
+        "video/win/video_capture_device_mf_win.h",
+      ]
+    }
     deps += [
       "//media/base/win:color_space_util_win",
       "//media/base/win:media_foundation_util",
     ]
     libs = [
-      "mf.lib",
-      "mfplat.lib",
-      "mfreadwrite.lib",
-      "mfuuid.lib",
-    ]
-    ldflags = [
-      "/DELAYLOAD:mf.dll",
-      "/DELAYLOAD:mfplat.dll",
-      "/DELAYLOAD:mfreadwrite.dll",
-    ]
+      "mf",
+      "mfplat",
+      "mfreadwrite",
+      "mfuuid",
+    ]
+    if (!is_mingw) {
+      ldflags = [
+        "/DELAYLOAD:mf.dll",
+        "/DELAYLOAD:mfplat.dll",
+        "/DELAYLOAD:mfreadwrite.dll",
+      ]
+    }
   }
 
   if (is_linux || is_chromeos) {
@@ -524,17 +534,19 @@
       "video/win/video_capture_device_mf_win_unittest.cc",
     ]
     libs = [
-      "mf.lib",
-      "mfplat.lib",
-      "mfreadwrite.lib",
-      "mfuuid.lib",
-      "dxguid.lib",
-    ]
-    ldflags = [
-      "/DELAYLOAD:mf.dll",
-      "/DELAYLOAD:mfplat.dll",
-      "/DELAYLOAD:mfreadwrite.dll",
-    ]
+      "mf",
+      "mfplat",
+      "mfreadwrite",
+      "mfuuid",
+      "dxguid",
+    ]
+    if (!is_mingw) {
+      ldflags = [
+        "/DELAYLOAD:mf.dll",
+        "/DELAYLOAD:mfplat.dll",
+        "/DELAYLOAD:mfreadwrite.dll",
+      ]
+    }
 
     deps += [ "//media/base/win:media_foundation_util" ]
   }
diff -ur a/src/3rdparty/chromium/media/cdm/BUILD.gn b/src/3rdparty/chromium/media/cdm/BUILD.gn
--- a/src/3rdparty/chromium/media/cdm/BUILD.gn	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/cdm/BUILD.gn	2024-01-02 19:50:34.048812200 +0800
@@ -129,7 +129,7 @@
     public_deps += [ "//components/crash/core/common:crash_key" ]
   }
 
-  if (is_win) {
+  if (is_win && !is_mingw) {
     sources += [
       "media_foundation_cdm_data.cc",
       "media_foundation_cdm_data.h",
diff -ur a/src/3rdparty/chromium/media/cdm/api/content_decryption_module_export.h b/src/3rdparty/chromium/media/cdm/api/content_decryption_module_export.h
--- a/src/3rdparty/chromium/media/cdm/api/content_decryption_module_export.h	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/cdm/api/content_decryption_module_export.h	2024-01-02 19:50:34.064352300 +0800
@@ -7,6 +7,7 @@
 
 // Define CDM_API so that functionality implemented by the CDM module
 // can be exported to consumers.
+#if defined(COMPONENT_BUILD)
 #if defined(_WIN32)
 
 #if defined(CDM_IMPLEMENTATION)
@@ -19,20 +20,24 @@
 #define CDM_API __attribute__((visibility("default")))
 #endif  // defined(_WIN32)
 
+#else // !defined(COMPONENT_BUILD)
+#define CDM_API
+#endif
+
 // Define CDM_CLASS_API to export class types. We have to add visibility
 // attributes to make sure virtual tables in CDM consumer and CDM implementation
 // are the same. Generally, it was always a good idea, as there're no guarantees
 // about that for the internal symbols, but it has only become a practical issue
 // after introduction of LTO devirtualization. See more details on
 // https://crbug.com/609564#c35
-#if defined(_WIN32)
+#if defined(COMPILER_MSVC)
 #if defined(__clang__)
 #define CDM_CLASS_API [[clang::lto_visibility_public]]
 #else
 #define CDM_CLASS_API
 #endif
-#else  // defined(_WIN32)
+#else  // defined(COMPILER_MSVC)
 #define CDM_CLASS_API __attribute__((visibility("default")))
-#endif  // defined(_WIN32)
+#endif  // defined(COMPILER_MSVC)
 
 #endif  // CDM_CONTENT_DECRYPTION_MODULE_EXPORT_H_
diff -ur a/src/3rdparty/chromium/media/cdm/cdm_auxiliary_helper.cc b/src/3rdparty/chromium/media/cdm/cdm_auxiliary_helper.cc
--- a/src/3rdparty/chromium/media/cdm/cdm_auxiliary_helper.cc	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/cdm/cdm_auxiliary_helper.cc	2024-01-02 19:50:34.111312000 +0800
@@ -8,10 +8,10 @@
 #include "media/base/cdm_context.h"
 #include "media/cdm/cdm_helpers.h"
 
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
 #include "media/cdm/media_foundation_cdm_data.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
-#endif  // BUILDFLAG(IS_WIN)
+#endif  // defined(COMPILER_MSVC)
 
 namespace media {
 
@@ -55,7 +55,7 @@
   std::move(callback).Run(version, std::vector<uint8_t>());
 }
 
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
 void CdmAuxiliaryHelper::GetMediaFoundationCdmData(
     GetMediaFoundationCdmDataCB callback) {
   std::move(callback).Run(std::make_unique<MediaFoundationCdmData>(
@@ -66,6 +66,6 @@
     const std::vector<uint8_t>& client_token) {}
 
 void CdmAuxiliaryHelper::OnCdmEvent(CdmEvent event, HRESULT hresult) {}
-#endif  // BUILDFLAG(IS_WIN)
+#endif  // defined(COMPILER_MSVC)
 
 }  // namespace media
diff -ur a/src/3rdparty/chromium/media/cdm/cdm_auxiliary_helper.h b/src/3rdparty/chromium/media/cdm/cdm_auxiliary_helper.h
--- a/src/3rdparty/chromium/media/cdm/cdm_auxiliary_helper.h	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/cdm/cdm_auxiliary_helper.h	2024-01-07 20:51:09.165430500 +0800
@@ -69,11 +69,11 @@
                          ChallengePlatformCB callback) override;
   void GetStorageId(uint32_t version, StorageIdCB callback) override;
 
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
   void GetMediaFoundationCdmData(GetMediaFoundationCdmDataCB callback) override;
   void SetCdmClientToken(const std::vector<uint8_t>& client_token) override;
   void OnCdmEvent(CdmEvent event, HRESULT hresult) override;
-#endif  // BUILDFLAG(IS_WIN)
+#endif  // defined(COMPILER_MSVC)
 };
 
 }  // namespace media
diff -ur a/src/3rdparty/chromium/media/cdm/cdm_document_service.h b/src/3rdparty/chromium/media/cdm/cdm_document_service.h
--- a/src/3rdparty/chromium/media/cdm/cdm_document_service.h	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/cdm/cdm_document_service.h	2024-01-08 07:48:37.067650700 +0800
@@ -50,10 +50,10 @@
       base::OnceCallback<void(uint32_t version,
                               const std::vector<uint8_t>& storage_id)>;
 
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
   using GetMediaFoundationCdmDataCB =
       base::OnceCallback<void(std::unique_ptr<MediaFoundationCdmData>)>;
-#endif  // BUILDFLAG(IS_WIN)
+#endif  // defined(COMPILER_MSVC)
 
   // Allows authorized services to verify that the underlying platform is
   // trusted. An example of a trusted platform is a Chrome OS device in
@@ -80,7 +80,7 @@
   //                 version does not exist.
   virtual void GetStorageId(uint32_t version, StorageIdCB callback) = 0;
 
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
   // Gets the Media Foundation cdm data for the origin associated with the CDM.
   virtual void GetMediaFoundationCdmData(
       GetMediaFoundationCdmDataCB callback) = 0;
@@ -95,7 +95,7 @@
   // logic, e.g. disable the CDM in the current robustness level. For error
   // events, the `hresult` provides more details about the error.
   virtual void OnCdmEvent(CdmEvent event, HRESULT hresult) = 0;
-#endif  // BUILDFLAG(IS_WIN)
+#endif  // defined(COMPILER_MSVC)
 };
 
 }  // namespace media
diff -ur a/src/3rdparty/chromium/media/cdm/mock_helpers.h b/src/3rdparty/chromium/media/cdm/mock_helpers.h
--- a/src/3rdparty/chromium/media/cdm/mock_helpers.h	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/cdm/mock_helpers.h	2024-01-08 20:15:08.256837400 +0800
@@ -55,12 +55,12 @@
   MOCK_METHOD1(GetStorageIdCalled, std::vector<uint8_t>(uint32_t version));
   void GetStorageId(uint32_t version, StorageIdCB callback) override;
 
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
   MOCK_METHOD(void,
               GetMediaFoundationCdmData,
               (GetMediaFoundationCdmDataCB callback),
               (override));
-#endif  // BUILDFLAG(IS_WIN)
+#endif  // defined(COMPILER_MSVC)
 
  private:
   std::unique_ptr<CdmAllocator> allocator_;
diff -ur a/src/3rdparty/chromium/media/cdm/win/media_foundation_cdm.h b/src/3rdparty/chromium/media/cdm/win/media_foundation_cdm.h
--- a/src/3rdparty/chromium/media/cdm/win/media_foundation_cdm.h	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/cdm/win/media_foundation_cdm.h	2024-01-02 19:50:34.142484800 +0800
@@ -5,6 +5,8 @@
 #ifndef MEDIA_CDM_WIN_MEDIA_FOUNDATION_CDM_H_
 #define MEDIA_CDM_WIN_MEDIA_FOUNDATION_CDM_H_
 
+#if defined(COMPILER_MSVC)
+
 #include <mfcontentdecryptionmodule.h>
 #include <wrl.h>
 
@@ -187,4 +189,6 @@
 
 }  // namespace media
 
+#endif
+
 #endif  // MEDIA_CDM_WIN_MEDIA_FOUNDATION_CDM_H_
diff -ur a/src/3rdparty/chromium/media/device_monitors/BUILD.gn b/src/3rdparty/chromium/media/device_monitors/BUILD.gn
--- a/src/3rdparty/chromium/media/device_monitors/BUILD.gn	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/device_monitors/BUILD.gn	2024-01-02 19:50:34.158118600 +0800
@@ -36,7 +36,7 @@
     frameworks = [ "Foundation.framework" ]
   }
 
-  if (is_win) {
+  if (is_win && !is_mingw) {
     sources += [
       "system_message_window_win.cc",
       "system_message_window_win.h",
diff -ur a/src/3rdparty/chromium/media/filters/BUILD.gn b/src/3rdparty/chromium/media/filters/BUILD.gn
--- a/src/3rdparty/chromium/media/filters/BUILD.gn	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/filters/BUILD.gn	2024-01-02 19:50:34.220611700 +0800
@@ -215,7 +215,7 @@
       "passthrough_dts_audio_decoder.h",
     ]
   }
-  if (is_win) {
+  if (is_win && !is_mingw) {
     sources += [
       "win/media_foundation_utils.cc",
       "win/media_foundation_utils.h",
diff -ur a/src/3rdparty/chromium/media/filters/ffmpeg_demuxer.cc b/src/3rdparty/chromium/media/filters/ffmpeg_demuxer.cc
--- a/src/3rdparty/chromium/media/filters/ffmpeg_demuxer.cc	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/filters/ffmpeg_demuxer.cc	2024-01-02 19:50:34.236240800 +0800
@@ -105,6 +105,7 @@
   if (stream->start_time != kNoFFmpegTimestamp)
     start_time = ConvertFromTimeBase(stream->time_base, stream->start_time);
 
+#if LIBAVCODEC_VERSION_MAJOR < 59
   // Next try to use the first DTS value, for codecs where we know PTS == DTS
   // (excludes all H26x codecs). The start time must be returned in PTS.
   if (av_stream_get_first_dts(stream) != kInvalidPTSMarker &&
@@ -116,6 +117,7 @@
     if (first_pts < start_time)
       start_time = first_pts;
   }
+#endif
 
   return start_time;
 }
@@ -1609,8 +1611,10 @@
   for (const auto& stream : streams_) {
     if (!stream || stream->IsEnabled() != enabled)
       continue;
+#if LIBAVCODEC_VERSION_MAJOR < 59
     if (av_stream_get_first_dts(stream->av_stream()) == kInvalidPTSMarker)
       continue;
+#endif
     if (!lowest_start_time_stream ||
         stream->start_time() < lowest_start_time_stream->start_time()) {
       lowest_start_time_stream = stream.get();
@@ -1630,8 +1634,10 @@
     if (stream->type() != DemuxerStream::VIDEO)
       continue;
 
+#if LIBAVCODEC_VERSION_MAJOR < 59
     if (av_stream_get_first_dts(stream->av_stream()) == kInvalidPTSMarker)
       continue;
+#endif
 
     if (!stream->IsEnabled())
       continue;
diff -ur a/src/3rdparty/chromium/media/gpu/BUILD.gn b/src/3rdparty/chromium/media/gpu/BUILD.gn
--- a/src/3rdparty/chromium/media/gpu/BUILD.gn	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/gpu/BUILD.gn	2024-01-08 07:57:47.009258400 +0800
@@ -286,21 +286,23 @@
       "//ui/display",
     ]
     libs += [
-      "d3d9.lib",
-      "d3d11.lib",
-      "dxva2.lib",
-      "strmiids.lib",
-      "mf.lib",
-      "mfplat.lib",
-      "mfuuid.lib",
-    ]
-    ldflags += [
-      "/DELAYLOAD:d3d9.dll",
-      "/DELAYLOAD:d3d11.dll",
-      "/DELAYLOAD:dxva2.dll",
-      "/DELAYLOAD:mf.dll",
-      "/DELAYLOAD:mfplat.dll",
+      "d3d9",
+      "d3d11",
+      "dxva2",
+      "strmiids",
+      "mf",
+      "mfplat",
+      "mfuuid",
     ]
+    if (!is_mingw) {
+      ldflags += [
+        "/DELAYLOAD:d3d9.dll",
+        "/DELAYLOAD:d3d11.dll",
+        "/DELAYLOAD:dxva2.dll",
+        "/DELAYLOAD:mf.dll",
+        "/DELAYLOAD:mfplat.dll",
+      ]
+    }
   }
 
   if (use_ozone) {
@@ -370,7 +372,7 @@
     "//ui/gfx/geometry",
   ]
 
-  if (is_win || use_vaapi) {
+  if (is_msvc || use_vaapi) {
     sources += [
       "video_rate_control.cc",
       "video_rate_control.h",
diff -ur a/src/3rdparty/chromium/media/gpu/windows/dxva_video_decode_accelerator_win.cc b/src/3rdparty/chromium/media/gpu/windows/dxva_video_decode_accelerator_win.cc
--- a/src/3rdparty/chromium/media/gpu/windows/dxva_video_decode_accelerator_win.cc	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/gpu/windows/dxva_video_decode_accelerator_win.cc	2024-01-02 19:50:34.408186200 +0800
@@ -97,7 +97,7 @@
 // texture color conversion in DX11.
 // Defined in mfidl.h in the Windows 10 SDK. ntverp.h provides VER_PRODUCTBUILD
 // to detect which SDK we are compiling with.
-#if VER_PRODUCTBUILD < 10011  // VER_PRODUCTBUILD for 10.0.10158.0 SDK.
+#if defined(_MSC_VER) && VER_PRODUCTBUILD < 10011  // VER_PRODUCTBUILD for 10.0.10158.0 SDK.
 DEFINE_GUID(CLSID_VideoProcessorMFT,
             0x88753b26,
             0x5b24,
diff -ur a/src/3rdparty/chromium/media/learning/common/media_learning_tasks.cc b/src/3rdparty/chromium/media/learning/common/media_learning_tasks.cc
--- a/src/3rdparty/chromium/media/learning/common/media_learning_tasks.cc	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/learning/common/media_learning_tasks.cc	2024-01-02 19:50:34.423764900 +0800
@@ -4,6 +4,8 @@
 
 #include "media/learning/common/media_learning_tasks.h"
 
+#include <cstring>
+
 #include "base/notreached.h"
 
 namespace media {
diff -ur a/src/3rdparty/chromium/media/midi/BUILD.gn b/src/3rdparty/chromium/media/midi/BUILD.gn
--- a/src/3rdparty/chromium/media/midi/BUILD.gn	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/midi/BUILD.gn	2024-01-02 19:50:34.470596700 +0800
@@ -150,12 +150,18 @@
       "midi_manager_winrt.cc",
       "midi_manager_winrt.h",
     ]
+    if (is_mingw) {
+      sources -= [
+        "midi_manager_winrt.cc",
+        "midi_manager_winrt.h",
+      ]
+    }
 
-    libs += [ "setupapi.lib" ]
+    libs += [ "setupapi" ]
 
     # This library is included in base in static builds.
     if (is_component_build) {
-      libs += [ "cfgmgr32.lib" ]
+      libs += [ "cfgmgr32" ]
     }
   }
 
diff -ur a/src/3rdparty/chromium/media/mojo/clients/BUILD.gn b/src/3rdparty/chromium/media/mojo/clients/BUILD.gn
--- a/src/3rdparty/chromium/media/mojo/clients/BUILD.gn	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/mojo/clients/BUILD.gn	2024-01-02 19:50:34.486239100 +0800
@@ -87,7 +87,7 @@
       "//ui/gl:gl",
     ]
   }
-  if (is_win) {
+  if (is_win && !is_mingw) {
     sources += [
       "win/media_foundation_renderer_client.cc",
       "win/media_foundation_renderer_client.h",
diff -ur a/src/3rdparty/chromium/media/mojo/mojom/BUILD.gn b/src/3rdparty/chromium/media/mojo/mojom/BUILD.gn
--- a/src/3rdparty/chromium/media/mojo/mojom/BUILD.gn	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/mojo/mojom/BUILD.gn	2024-01-02 19:50:34.533096500 +0800
@@ -663,7 +663,7 @@
     },
   ]
 
-  if (is_win) {
+  if (is_win && !is_mingw) {
     cpp_typemaps += [
       {
         types = [
diff -ur a/src/3rdparty/chromium/media/mojo/mojom/cdm_document_service.mojom b/src/3rdparty/chromium/media/mojo/mojom/cdm_document_service.mojom
--- a/src/3rdparty/chromium/media/mojo/mojom/cdm_document_service.mojom	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/mojo/mojom/cdm_document_service.mojom	2024-01-02 19:50:34.533096500 +0800
@@ -63,18 +63,18 @@
   // Gets the Media FoundationCDM data for the origin associated with the CDM.
   // - `media_foundation_cdm_data`: The CDM data for the origin associated with
   //                                the CDM.
-  [EnableIf=is_win]
+  [EnableIf=is_msvc]
   GetMediaFoundationCdmData() => (MediaFoundationCdmData cdm_data);
 
   // Sets the client token for the origin associated with the CDM. The token is
   // set by the CDM. The token is then saved in the Pref Service so that it can
   // be reused by the CDM for that same origin in the future.
-  [EnableIf=is_win]
+  [EnableIf=is_msvc]
   SetCdmClientToken(array<uint8> client_token);
 
   // Reports a CDM event, which can facilitate metrics reporting or fallback
   // logic.  For error events, the `hresult` provides more details about the
   // error.
-  [EnableIf=is_win]
+  [EnableIf=is_msvc]
   OnCdmEvent(CdmEvent event, uint32 hresult);
 };
diff -ur a/src/3rdparty/chromium/media/mojo/services/BUILD.gn b/src/3rdparty/chromium/media/mojo/services/BUILD.gn
--- a/src/3rdparty/chromium/media/mojo/services/BUILD.gn	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/mojo/services/BUILD.gn	2024-01-02 19:50:34.548725700 +0800
@@ -179,7 +179,7 @@
     deps += [ "//media/cdm:cdm_api" ]
   }
 
-  if (is_win) {
+  if (is_win && !is_mingw) {
     sources += [
       "media_foundation_gpu_info_monitor.cc",
       "media_foundation_gpu_info_monitor.h",
diff -ur a/src/3rdparty/chromium/media/mojo/services/mojo_cdm_helper.cc b/src/3rdparty/chromium/media/mojo/services/mojo_cdm_helper.cc
--- a/src/3rdparty/chromium/media/mojo/services/mojo_cdm_helper.cc	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/mojo/services/mojo_cdm_helper.cc	2024-01-02 19:50:34.564350500 +0800
@@ -51,7 +51,7 @@
   return cdm_origin;
 }
 
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
 void MojoCdmHelper::GetMediaFoundationCdmData(
     GetMediaFoundationCdmDataCB callback) {
   ConnectToCdmDocumentService();
@@ -68,7 +68,7 @@
   ConnectToCdmDocumentService();
   cdm_document_service_->OnCdmEvent(event, hresult);
 }
-#endif  // BUILDFLAG(IS_WIN)
+#endif  // defined(COMPILER_MSVC)
 
 cdm::Buffer* MojoCdmHelper::CreateCdmBuffer(size_t capacity) {
   return GetAllocator()->CreateCdmBuffer(capacity);
diff -ur a/src/3rdparty/chromium/media/mojo/services/mojo_cdm_helper.h b/src/3rdparty/chromium/media/mojo/services/mojo_cdm_helper.h
--- a/src/3rdparty/chromium/media/mojo/services/mojo_cdm_helper.h	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/mojo/services/mojo_cdm_helper.h	2024-01-02 19:50:34.579980600 +0800
@@ -48,11 +48,11 @@
                          const std::string& challenge,
                          ChallengePlatformCB callback) final;
   void GetStorageId(uint32_t version, StorageIdCB callback) final;
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
   void GetMediaFoundationCdmData(GetMediaFoundationCdmDataCB callback) final;
   void SetCdmClientToken(const std::vector<uint8_t>& client_token) final;
   void OnCdmEvent(CdmEvent event, HRESULT hresult) final;
-#endif  // BUILDFLAG(IS_WIN)
+#endif  // defined(COMPILER_MSVC)
 
   // MojoCdmFileIO::Delegate implementation.
   void CloseCdmFileIO(MojoCdmFileIO* cdm_file_io) final;
diff -ur a/src/3rdparty/chromium/media/renderers/BUILD.gn b/src/3rdparty/chromium/media/renderers/BUILD.gn
--- a/src/3rdparty/chromium/media/renderers/BUILD.gn	2023-11-21 00:08:07.000000000 +0800
+++ b/src/3rdparty/chromium/media/renderers/BUILD.gn	2024-01-02 19:50:34.611222100 +0800
@@ -59,7 +59,7 @@
     "//ui/gl",
   ]
 
-  if (is_win) {
+  if (is_win && !is_mingw) {
     sources += [
       "win/media_engine_extension.cc",
       "win/media_engine_extension.h",
