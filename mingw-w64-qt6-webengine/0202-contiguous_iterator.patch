diff -ur a/src/3rdparty/chromium/base/containers/checked_iterators.h b/src/3rdparty/chromium/base/containers/checked_iterators.h
--- a/src/3rdparty/chromium/base/containers/checked_iterators.h	2023-10-04 03:49:54.000000000 +0800
+++ b/src/3rdparty/chromium/base/containers/checked_iterators.h	2023-12-17 11:47:21.147511000 +0800
@@ -24,6 +24,9 @@
   using pointer = T*;
   using reference = T&;
   using iterator_category = std::random_access_iterator_tag;
+#if __cplusplus >= 202002L
+  using iterator_concept = std::contiguous_iterator_tag;
+#endif
 
   // Required for converting constructor below.
   template <typename U>
@@ -242,13 +245,32 @@
 // [1] https://wg21.link/iterator.concept.contiguous
 // [2] https://wg21.link/std.iterator.tags
 // [3] https://wg21.link/pointer.traits.optmem
-namespace std {
+
+// TODO(crbug.com/1284275): Remove when C++20 is on by default, as the use
+// of `iterator_concept` above should suffice.
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+// TODO(crbug.com/1449299): https://reviews.llvm.org/D150801 renamed this from
+// `__is_cpp17_contiguous_iterator` to `__libcpp_is_contiguous_iterator`. Clean
+// up the old spelling after libc++ rolls.
+template <typename T>
+struct __is_cpp17_contiguous_iterator;
 
 template <typename T>
 struct __is_cpp17_contiguous_iterator<::base::CheckedContiguousIterator<T>>
     : true_type {};
 
 template <typename T>
+struct __libcpp_is_contiguous_iterator;
+template <typename T>
+struct __libcpp_is_contiguous_iterator<::base::CheckedContiguousIterator<T>>
+    : true_type {};
+
+_LIBCPP_END_NAMESPACE_STD
+
+namespace std {
+
+template <typename T>
 struct pointer_traits<::base::CheckedContiguousIterator<T>> {
   using pointer = ::base::CheckedContiguousIterator<T>;
   using element_type = T;
