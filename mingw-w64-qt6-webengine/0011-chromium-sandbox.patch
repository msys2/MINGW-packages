diff -ur a/src/3rdparty/chromium/sandbox/win/BUILD.gn b/src/3rdparty/chromium/sandbox/win/BUILD.gn
--- a/src/3rdparty/chromium/sandbox/win/BUILD.gn	2023-10-04 03:49:54.000000000 +0800
+++ b/src/3rdparty/chromium/sandbox/win/BUILD.gn	2023-12-20 17:37:06.968360300 +0800
@@ -183,8 +183,8 @@
   ]
 
   libs = [
-    "ntdll.lib",
-    "userenv.lib",
+    "ntdll",
+    "userenv",
   ]
 }
 
@@ -231,7 +231,7 @@
     ":sbox_integration_test_win_proc",
   ]
 
-  libs = [ "ktmw32.lib" ]
+  libs = [ "ktmw32" ]
 }
 
 group("maybe_set_appcontainer_acls") {
@@ -296,7 +296,7 @@
     "//testing/gtest",
   ]
 
-  libs = [ "shlwapi.lib" ]
+  libs = [ "shlwapi" ]
 }
 
 test("sbox_unittests") {
diff -ur a/src/3rdparty/chromium/sandbox/win/src/interception_agent.cc b/src/3rdparty/chromium/sandbox/win/src/interception_agent.cc
--- a/src/3rdparty/chromium/sandbox/win/src/interception_agent.cc	2023-10-04 03:49:54.000000000 +0800
+++ b/src/3rdparty/chromium/sandbox/win/src/interception_agent.cc	2023-12-14 20:12:22.615609400 +0800
@@ -42,7 +42,7 @@
 
     size_t array_bytes = g_interceptions->num_intercepted_dlls * sizeof(void*);
     s_singleton = reinterpret_cast<InterceptionAgent*>(
-        new (NT_ALLOC) char[array_bytes + sizeof(InterceptionAgent)]);
+        new char[array_bytes + sizeof(InterceptionAgent)]);
 
     bool success = s_singleton->Init(g_interceptions);
     if (!success) {
@@ -106,7 +106,7 @@
   size_t buffer_bytes = offsetof(DllInterceptionData, thunks) +
                         dll_info->num_functions * sizeof(ThunkData);
   dlls_[i] = reinterpret_cast<DllInterceptionData*>(
-      new (NT_PAGE, base_address) char[buffer_bytes]);
+      new char[buffer_bytes]);
 
   DCHECK_NT(dlls_[i]);
   if (!dlls_[i])
diff -ur a/src/3rdparty/chromium/sandbox/win/src/nt_internals.h b/src/3rdparty/chromium/sandbox/win/src/nt_internals.h
--- a/src/3rdparty/chromium/sandbox/win/src/nt_internals.h	2023-10-04 03:49:54.000000000 +0800
+++ b/src/3rdparty/chromium/sandbox/win/src/nt_internals.h	2023-12-19 01:59:45.392510800 +0800
@@ -40,6 +40,7 @@
 
 typedef NTSTATUS(WINAPI* NtCloseFunction)(IN HANDLE Handle);
 
+#ifdef _MSC_VER
 // Uses undocumented value not in FILE_INFORMATION_CLASS.
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wenum-constexpr-conversion"
@@ -52,6 +53,7 @@
   ULONG FileNameLength;
   WCHAR FileName[1];
 } FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;
+#endif
 
 typedef NTSTATUS(WINAPI* NtSetInformationFileFunction)(
     IN HANDLE FileHandle,
@@ -60,6 +62,7 @@
     IN ULONG Length,
     IN FILE_INFORMATION_CLASS FileInformationClass);
 
+#ifdef _MSC_VER
 typedef struct FILE_BASIC_INFORMATION {
   LARGE_INTEGER CreationTime;
   LARGE_INTEGER LastAccessTime;
@@ -67,11 +70,13 @@
   LARGE_INTEGER ChangeTime;
   ULONG FileAttributes;
 } FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;
+#endif
 
 typedef NTSTATUS(WINAPI* NtQueryAttributesFileFunction)(
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PFILE_BASIC_INFORMATION FileAttributes);
 
+#ifdef _MSC_VER
 typedef struct _FILE_NETWORK_OPEN_INFORMATION {
   LARGE_INTEGER CreationTime;
   LARGE_INTEGER LastAccessTime;
@@ -81,6 +86,7 @@
   LARGE_INTEGER EndOfFile;
   ULONG FileAttributes;
 } FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;
+#endif
 
 typedef NTSTATUS(WINAPI* NtQueryFullAttributesFileFunction)(
     IN POBJECT_ATTRIBUTES ObjectAttributes,
@@ -153,8 +159,10 @@
                                                     ObjectAttributes,
                                                 IN PCLIENT_ID ClientId);
 
+#ifdef _MSC_VER
 // Provide ThreadImpersonationToken which is not in THREADINFOCLASS.
 constexpr auto ThreadImpersonationToken = static_cast<THREADINFOCLASS>(5);
+#endif
 
 typedef NTSTATUS(WINAPI* NtSetInformationThreadFunction)(
     IN HANDLE ThreadHandle,
@@ -238,8 +246,10 @@
 // -----------------------------------------------------------------------
 // Memory
 
+#ifdef _MSC_VER
 // Don't really need this structure right now.
 typedef PVOID PRTL_HEAP_PARAMETERS;
+#endif
 
 typedef PVOID(WINAPI* RtlCreateHeapFunction)(IN ULONG Flags,
                                              IN PVOID HeapBase OPTIONAL,
@@ -301,8 +311,10 @@
 // -----------------------------------------------------------------------
 // Objects
 
+#ifdef _MSC_VER
 // Add some field not in OBJECT_INFORMATION_CLASS.
 constexpr auto ObjectNameInformation = static_cast<OBJECT_INFORMATION_CLASS>(1);
+#endif
 
 typedef enum _POOL_TYPE {
   NonPagedPool,
@@ -314,6 +326,7 @@
   NonPagedPoolCacheAlignedMustS
 } POOL_TYPE;
 
+#ifdef _MSC_VER
 typedef struct _OBJECT_BASIC_INFORMATION {
   ULONG Attributes;
   ACCESS_MASK GrantedAccess;
@@ -327,9 +340,11 @@
   ULONG SecurityDescriptorLength;
   LARGE_INTEGER CreateTime;
 } OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;
+#endif
 
+#ifdef _MSC_VER
 typedef struct _OBJECT_TYPE_INFORMATION {
-  UNICODE_STRING Name;
+  UNICODE_STRING TypeName;
   ULONG TotalNumberOfObjects;
   ULONG TotalNumberOfHandles;
   ULONG TotalPagedPoolUsage;
@@ -352,10 +367,13 @@
   ULONG PagedPoolUsage;
   ULONG NonPagedPoolUsage;
 } OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;
+#endif
 
+#ifdef _MSC_VER
 typedef struct _OBJECT_NAME_INFORMATION {
-  UNICODE_STRING ObjectName;
+  UNICODE_STRING Name;
 } OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;
+#endif
 
 typedef NTSTATUS(WINAPI* NtQueryObjectFunction)(
     IN HANDLE Handle,
diff -ur a/src/3rdparty/chromium/sandbox/win/src/sandbox_nt_util.cc b/src/3rdparty/chromium/sandbox/win/src/sandbox_nt_util.cc
--- a/src/3rdparty/chromium/sandbox/win/src/sandbox_nt_util.cc	2023-10-04 03:49:54.000000000 +0800
+++ b/src/3rdparty/chromium/sandbox/win/src/sandbox_nt_util.cc	2023-12-19 01:58:50.501888600 +0800
@@ -311,7 +311,7 @@
         break;
 
       size_t size = in_object->ObjectName->Length / sizeof(wchar_t);
-      out_name->reset(new (NT_ALLOC) wchar_t[size + 1]);
+      out_name->reset(new wchar_t[size + 1]);
       if (!*out_name)
         break;
 
@@ -434,7 +434,7 @@
       ansi_string.MaximumLength * sizeof(wchar_t) + sizeof(UNICODE_STRING);
 
   UNICODE_STRING* out_string =
-      reinterpret_cast<UNICODE_STRING*>(new (NT_ALLOC) char[name_bytes]);
+      reinterpret_cast<UNICODE_STRING*>(new char[name_bytes]);
   if (!out_string)
     return nullptr;
 
@@ -517,7 +517,7 @@
 
   for (;;) {
     MEMORY_SECTION_NAME* section_name = reinterpret_cast<MEMORY_SECTION_NAME*>(
-        new (NT_ALLOC) char[buffer_bytes]);
+        new char[buffer_bytes]);
 
     if (!section_name)
       return nullptr;
@@ -570,7 +570,7 @@
   // Because module_path is a UNICODE_STRING, size_bytes will be small enough
   // to make the static_cast below safe.
   DCHECK_NT(UINT16_MAX > size_bytes);
-  char* str_buffer = new (NT_ALLOC) char[size_bytes + sizeof(UNICODE_STRING)];
+  char* str_buffer = new char[size_bytes + sizeof(UNICODE_STRING)];
   if (!str_buffer)
     return nullptr;
 
@@ -674,7 +674,7 @@
   std::unique_ptr<BYTE[], NtAllocDeleter> name_ptr;
   if (!size)
     return false;
-  name_ptr.reset(new (NT_ALLOC) BYTE[size]);
+  name_ptr.reset(new BYTE[size]);
   name = reinterpret_cast<OBJECT_NAME_INFORMATION*>(name_ptr.get());
 
   // Query the name information a second time to get the name of the
@@ -684,10 +684,10 @@
 
   if (STATUS_SUCCESS != status)
     return false;
-  size_t num_path_wchars = (name->ObjectName.Length / sizeof(wchar_t)) + 1;
-  path->reset(new (NT_ALLOC) wchar_t[num_path_wchars]);
+  size_t num_path_wchars = (name->Name.Length / sizeof(wchar_t)) + 1;
+  path->reset(new wchar_t[num_path_wchars]);
   status =
-      CopyData(path->get(), name->ObjectName.Buffer, name->ObjectName.Length);
+      CopyData(path->get(), name->Name.Buffer, name->Name.Length);
   path->get()[num_path_wchars - 1] = L'\0';
   if (STATUS_SUCCESS != status)
     return false;
diff -ur a/src/3rdparty/chromium/sandbox/win/src/target_process.cc b/src/3rdparty/chromium/sandbox/win/src/target_process.cc
--- a/src/3rdparty/chromium/sandbox/win/src/target_process.cc	2023-10-04 03:49:54.000000000 +0800
+++ b/src/3rdparty/chromium/sandbox/win/src/target_process.cc	2023-12-14 20:12:22.928142700 +0800
@@ -238,7 +238,7 @@
   if (!module)
     return SBOX_ERROR_CANNOT_LOADLIBRARY_EXECUTABLE;
 
-  child_var = ::GetProcAddress(module, name);
+  child_var = reinterpret_cast<void*>(::GetProcAddress(module, name));
   ::FreeLibrary(module);
 
   if (!child_var)
diff -ur a/src/3rdparty/chromium/sandbox/win/src/win_utils.cc b/src/3rdparty/chromium/sandbox/win/src/win_utils.cc
--- a/src/3rdparty/chromium/sandbox/win/src/win_utils.cc	2023-10-04 03:49:54.000000000 +0800
+++ b/src/3rdparty/chromium/sandbox/win/src/win_utils.cc	2023-12-19 02:01:58.580011100 +0800
@@ -458,8 +458,8 @@
   OBJECT_NAME_INFORMATION* name =
       reinterpret_cast<OBJECT_NAME_INFORMATION*>(buffer->data());
   return std::wstring(
-      name->ObjectName.Buffer,
-      name->ObjectName.Length / sizeof(name->ObjectName.Buffer[0]));
+      name->Name.Buffer,
+      name->Name.Length / sizeof(name->Name.Buffer[0]));
 }
 
 absl::optional<std::wstring> GetTypeNameFromHandle(HANDLE handle) {
@@ -470,8 +470,8 @@
     return absl::nullopt;
   OBJECT_TYPE_INFORMATION* name =
       reinterpret_cast<OBJECT_TYPE_INFORMATION*>(buffer->data());
-  return std::wstring(name->Name.Buffer,
-                      name->Name.Length / sizeof(name->Name.Buffer[0]));
+  return std::wstring(name->TypeName.Buffer,
+                      name->TypeName.Length / sizeof(name->TypeName.Buffer[0]));
 }
 
 bool WriteProtectedChildMemory(HANDLE child_process,
