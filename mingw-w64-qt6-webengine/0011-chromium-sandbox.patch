diff --git a/src/3rdparty/chromium/sandbox/win/BUILD.gn b/src/3rdparty/chromium/sandbox/win/BUILD.gn
index c339592..78b3ebe 100644
--- a/src/3rdparty/chromium/sandbox/win/BUILD.gn
+++ b/src/3rdparty/chromium/sandbox/win/BUILD.gn
@@ -190,8 +190,8 @@ static_library("sandbox") {
   ]
 
   libs = [
-    "ntdll.lib",
-    "userenv.lib",
+    "ntdll",
+    "userenv",
   ]
 }
 
@@ -239,7 +239,7 @@ test("sbox_integration_tests") {
     ":sbox_integration_test_win_proc",
   ]
 
-  libs = [ "ktmw32.lib" ]
+  libs = [ "ktmw32" ]
 }
 
 group("maybe_set_appcontainer_acls") {
@@ -302,7 +302,7 @@ test("sbox_validation_tests") {
     "//testing/gtest",
   ]
 
-  libs = [ "shlwapi.lib" ]
+  libs = [ "shlwapi" ]
 }
 
 test("sbox_unittests") {
diff --git a/src/3rdparty/chromium/sandbox/win/src/interception_agent.cc b/src/3rdparty/chromium/sandbox/win/src/interception_agent.cc
index 82c50ca..207089f 100644
--- a/src/3rdparty/chromium/sandbox/win/src/interception_agent.cc
+++ b/src/3rdparty/chromium/sandbox/win/src/interception_agent.cc
@@ -42,7 +42,7 @@ InterceptionAgent* InterceptionAgent::GetInterceptionAgent() {
 
     size_t array_bytes = g_interceptions->num_intercepted_dlls * sizeof(void*);
     s_singleton = reinterpret_cast<InterceptionAgent*>(
-        new (NT_ALLOC) char[array_bytes + sizeof(InterceptionAgent)]);
+        new char[array_bytes + sizeof(InterceptionAgent)]);
 
     bool success = s_singleton->Init(g_interceptions);
     if (!success) {
@@ -106,7 +106,7 @@ bool InterceptionAgent::OnDllLoad(const UNICODE_STRING* full_path,
   size_t buffer_bytes = offsetof(DllInterceptionData, thunks) +
                         dll_info->num_functions * sizeof(ThunkData);
   dlls_[i] = reinterpret_cast<DllInterceptionData*>(
-      new (NT_PAGE, base_address) char[buffer_bytes]);
+      new char[buffer_bytes]);
 
   DCHECK_NT(dlls_[i]);
   if (!dlls_[i])
diff --git a/src/3rdparty/chromium/sandbox/win/src/nt_internals.h b/src/3rdparty/chromium/sandbox/win/src/nt_internals.h
index 72d96b9..221b27e 100644
--- a/src/3rdparty/chromium/sandbox/win/src/nt_internals.h
+++ b/src/3rdparty/chromium/sandbox/win/src/nt_internals.h
@@ -40,6 +40,7 @@ typedef NTSTATUS(WINAPI* NtOpenFileFunction)(OUT PHANDLE FileHandle,
 
 typedef NTSTATUS(WINAPI* NtCloseFunction)(IN HANDLE Handle);
 
+#ifdef _MSC_VER
 // Uses undocumented value not in FILE_INFORMATION_CLASS.
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wenum-constexpr-conversion"
@@ -52,6 +53,7 @@ typedef struct _FILE_RENAME_INFORMATION {
   ULONG FileNameLength;
   WCHAR FileName[1];
 } FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;
+#endif
 
 typedef NTSTATUS(WINAPI* NtSetInformationFileFunction)(
     IN HANDLE FileHandle,
@@ -60,6 +62,7 @@ typedef NTSTATUS(WINAPI* NtSetInformationFileFunction)(
     IN ULONG Length,
     IN FILE_INFORMATION_CLASS FileInformationClass);
 
+#ifdef _MSC_VER
 typedef struct FILE_BASIC_INFORMATION {
   LARGE_INTEGER CreationTime;
   LARGE_INTEGER LastAccessTime;
@@ -67,11 +70,13 @@ typedef struct FILE_BASIC_INFORMATION {
   LARGE_INTEGER ChangeTime;
   ULONG FileAttributes;
 } FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;
+#endif
 
 typedef NTSTATUS(WINAPI* NtQueryAttributesFileFunction)(
     IN POBJECT_ATTRIBUTES ObjectAttributes,
     OUT PFILE_BASIC_INFORMATION FileAttributes);
 
+#ifdef _MSC_VER
 typedef struct _FILE_NETWORK_OPEN_INFORMATION {
   LARGE_INTEGER CreationTime;
   LARGE_INTEGER LastAccessTime;
@@ -81,6 +86,7 @@ typedef struct _FILE_NETWORK_OPEN_INFORMATION {
   LARGE_INTEGER EndOfFile;
   ULONG FileAttributes;
 } FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;
+#endif
 
 typedef NTSTATUS(WINAPI* NtQueryFullAttributesFileFunction)(
     IN POBJECT_ATTRIBUTES ObjectAttributes,
@@ -153,8 +159,10 @@ typedef NTSTATUS(WINAPI* NtOpenProcessFunction)(OUT PHANDLE ProcessHandle,
                                                     ObjectAttributes,
                                                 IN PCLIENT_ID ClientId);
 
+#ifdef _MSC_VER
 // Provide ThreadImpersonationToken which is not in THREADINFOCLASS.
 constexpr auto ThreadImpersonationToken = static_cast<THREADINFOCLASS>(5);
+#endif
 
 typedef NTSTATUS(WINAPI* NtSetInformationThreadFunction)(
     IN HANDLE ThreadHandle,
@@ -220,8 +228,10 @@ typedef NTSTATUS(WINAPI* NtOpenProcessTokenExFunction)(
 // -----------------------------------------------------------------------
 // Memory
 
+#ifdef _MSC_VER
 // Don't really need this structure right now.
 typedef PVOID PRTL_HEAP_PARAMETERS;
+#endif
 
 typedef PVOID(WINAPI* RtlCreateHeapFunction)(IN ULONG Flags,
                                              IN PVOID HeapBase OPTIONAL,
@@ -283,8 +293,10 @@ typedef NTSTATUS(WINAPI* NtProtectVirtualMemoryFunction)(
 // -----------------------------------------------------------------------
 // Objects
 
+#ifdef _MSC_VER
 // Add some field not in OBJECT_INFORMATION_CLASS.
 constexpr auto ObjectNameInformation = static_cast<OBJECT_INFORMATION_CLASS>(1);
+#endif
 
 typedef enum _POOL_TYPE {
   NonPagedPool,
@@ -296,6 +308,7 @@ typedef enum _POOL_TYPE {
   NonPagedPoolCacheAlignedMustS
 } POOL_TYPE;
 
+#ifdef _MSC_VER
 typedef struct _OBJECT_BASIC_INFORMATION {
   ULONG Attributes;
   ACCESS_MASK GrantedAccess;
@@ -338,6 +351,7 @@ typedef struct _OBJECT_TYPE_INFORMATION {
 typedef struct _OBJECT_NAME_INFORMATION {
   UNICODE_STRING ObjectName;
 } OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;
+#endif
 
 typedef NTSTATUS(WINAPI* NtQueryObjectFunction)(
     IN HANDLE Handle,
diff --git a/src/3rdparty/chromium/sandbox/win/src/sandbox_nt_util.cc b/src/3rdparty/chromium/sandbox/win/src/sandbox_nt_util.cc
index 27942c9..e5fe3d8 100644
--- a/src/3rdparty/chromium/sandbox/win/src/sandbox_nt_util.cc
+++ b/src/3rdparty/chromium/sandbox/win/src/sandbox_nt_util.cc
@@ -19,6 +19,13 @@
 #include "sandbox/win/src/sandbox_factory.h"
 #include "sandbox/win/src/target_services.h"
 
+#ifndef _MSC_VER
+#undef __try
+#define __try try
+#undef __except
+#define __except(x) catch(...)
+#endif
+
 namespace sandbox {
 
 // This is the list of all imported symbols from ntdll.dll.
@@ -318,7 +325,9 @@ NTSTATUS CopyData(void* destination, const void* source, size_t bytes) {
   __try {
     GetNtExports()->memcpy(destination, source, bytes);
   } __except (EXCEPTION_EXECUTE_HANDLER) {
+#ifdef _MSC_VER
     ret = (NTSTATUS)GetExceptionCode();
+#endif
   }
   return ret;
 }
@@ -344,7 +353,7 @@ NTSTATUS CopyNameAndAttributes(
         break;
 
       size_t size = in_object->ObjectName->Length / sizeof(wchar_t);
-      out_name->reset(new (NT_ALLOC) wchar_t[size + 1]);
+      out_name->reset(new wchar_t[size + 1]);
       if (!*out_name)
         break;
 
@@ -361,7 +370,9 @@ NTSTATUS CopyNameAndAttributes(
       ret = STATUS_SUCCESS;
     } while (false);
   } __except (EXCEPTION_EXECUTE_HANDLER) {
+#ifdef _MSC_VER
     ret = (NTSTATUS)GetExceptionCode();
+#endif
   }
 
   if (!NT_SUCCESS(ret) && *out_name)
@@ -467,7 +478,7 @@ UNICODE_STRING* AnsiToUnicode(const char* string) {
       ansi_string.MaximumLength * sizeof(wchar_t) + sizeof(UNICODE_STRING);
 
   UNICODE_STRING* out_string =
-      reinterpret_cast<UNICODE_STRING*>(new (NT_ALLOC) char[name_bytes]);
+      reinterpret_cast<UNICODE_STRING*>(new char[name_bytes]);
   if (!out_string)
     return nullptr;
 
@@ -550,7 +561,7 @@ UNICODE_STRING* GetBackingFilePath(PVOID address) {
 
   for (;;) {
     MEMORY_SECTION_NAME* section_name = reinterpret_cast<MEMORY_SECTION_NAME*>(
-        new (NT_ALLOC) char[buffer_bytes]);
+        new char[buffer_bytes]);
 
     if (!section_name)
       return nullptr;
@@ -603,7 +614,7 @@ UNICODE_STRING* ExtractModuleName(const UNICODE_STRING* module_path) {
   // Because module_path is a UNICODE_STRING, size_bytes will be small enough
   // to make the static_cast below safe.
   DCHECK_NT(UINT16_MAX > size_bytes);
-  char* str_buffer = new (NT_ALLOC) char[size_bytes + sizeof(UNICODE_STRING)];
+  char* str_buffer = new char[size_bytes + sizeof(UNICODE_STRING)];
   if (!str_buffer)
     return nullptr;
 
@@ -707,7 +718,7 @@ bool NtGetPathFromHandle(HANDLE handle,
   std::unique_ptr<BYTE[], NtAllocDeleter> name_ptr;
   if (!size)
     return false;
-  name_ptr.reset(new (NT_ALLOC) BYTE[size]);
+  name_ptr.reset(new BYTE[size]);
   name = reinterpret_cast<OBJECT_NAME_INFORMATION*>(name_ptr.get());
 
   // Query the name information a second time to get the name of the
@@ -717,10 +728,10 @@ bool NtGetPathFromHandle(HANDLE handle,
 
   if (STATUS_SUCCESS != status)
     return false;
-  size_t num_path_wchars = (name->ObjectName.Length / sizeof(wchar_t)) + 1;
-  path->reset(new (NT_ALLOC) wchar_t[num_path_wchars]);
+  size_t num_path_wchars = (name->Name.Length / sizeof(wchar_t)) + 1;
+  path->reset(new wchar_t[num_path_wchars]);
   status =
-      CopyData(path->get(), name->ObjectName.Buffer, name->ObjectName.Length);
+      CopyData(path->get(), name->Name.Buffer, name->Name.Length);
   path->get()[num_path_wchars - 1] = L'\0';
   if (STATUS_SUCCESS != status)
     return false;
diff --git a/src/3rdparty/chromium/sandbox/win/src/target_process.cc b/src/3rdparty/chromium/sandbox/win/src/target_process.cc
index aa12a71..9ad8e75 100644
--- a/src/3rdparty/chromium/sandbox/win/src/target_process.cc
+++ b/src/3rdparty/chromium/sandbox/win/src/target_process.cc
@@ -243,7 +243,7 @@ ResultCode TargetProcess::TransferVariable(const char* name,
   if (!module)
     return SBOX_ERROR_CANNOT_LOADLIBRARY_EXECUTABLE;
 
-  target_address = ::GetProcAddress(module, name);
+  target_address = reinterpret_cast<void*>(::GetProcAddress(module, name));
   ::FreeLibrary(module);
 
   if (!target_address)
diff --git a/src/3rdparty/chromium/sandbox/win/src/win_utils.cc b/src/3rdparty/chromium/sandbox/win/src/win_utils.cc
index 6b34ade..308ab4a 100644
--- a/src/3rdparty/chromium/sandbox/win/src/win_utils.cc
+++ b/src/3rdparty/chromium/sandbox/win/src/win_utils.cc
@@ -459,8 +459,8 @@ std::optional<std::wstring> GetPathFromHandle(HANDLE handle) {
   OBJECT_NAME_INFORMATION* name =
       reinterpret_cast<OBJECT_NAME_INFORMATION*>(buffer->data());
   return std::wstring(
-      name->ObjectName.Buffer,
-      name->ObjectName.Length / sizeof(name->ObjectName.Buffer[0]));
+      name->Name.Buffer,
+      name->Name.Length / sizeof(name->Name.Buffer[0]));
 }
 
 std::optional<std::wstring> GetTypeNameFromHandle(HANDLE handle) {
@@ -471,8 +471,8 @@ std::optional<std::wstring> GetTypeNameFromHandle(HANDLE handle) {
     return std::nullopt;
   OBJECT_TYPE_INFORMATION* name =
       reinterpret_cast<OBJECT_TYPE_INFORMATION*>(buffer->data());
-  return std::wstring(name->Name.Buffer,
-                      name->Name.Length / sizeof(name->Name.Buffer[0]));
+  return std::wstring(name->TypeName.Buffer,
+                      name->TypeName.Length / sizeof(name->TypeName.Buffer[0]));
 }
 
 bool CopyToChildMemory(HANDLE child,
