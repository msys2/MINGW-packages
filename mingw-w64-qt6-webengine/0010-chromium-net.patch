diff -ur a/src/3rdparty/chromium/net/BUILD.gn b/src/3rdparty/chromium/net/BUILD.gn
--- a/src/3rdparty/chromium/net/BUILD.gn	2023-10-04 03:49:54.000000000 +0800
+++ b/src/3rdparty/chromium/net/BUILD.gn	2023-12-20 04:25:51.377558200 +0800
@@ -1324,6 +1324,12 @@
       "ssl/client_cert_store_win.h",
       "ssl/ssl_platform_key_win.cc",
     ]
+    if (is_mingw) {
+      sources -= [
+        "base/network_change_notifier_win.cc",
+        "base/network_change_notifier_win.h",
+      ]
+    }
   }
 
   if (use_kerberos) {
@@ -1523,7 +1529,7 @@
     ]
   }
 
-  if (is_win) {
+  if (is_win && !is_mingw) {
     libs = [
       "crypt32.lib",
       "dhcpcsvc.lib",
@@ -1536,6 +1542,17 @@
     ]
 
     ldflags = [ "/DELAYLOAD:urlmon.dll" ]
+  } else if (is_mingw) {
+    libs = [
+      "crypt32",
+      "dhcpcsvc",
+      "iphlpapi",
+      "ncrypt",
+      "rpcrt4",
+      "secur32",
+      "urlmon",
+      "winhttp",
+    ]
   }
 
   if (!disable_file_support) {
@@ -3165,8 +3182,8 @@
 
   if (is_win) {
     libs = [
-      "iphlpapi.lib",
-      "ncrypt.lib",
+      "iphlpapi",
+      "ncrypt",
     ]
   }
 
@@ -3177,7 +3194,7 @@
     if (is_win) {
       sources += [ "cert/internal/trust_store_win_unittest.cc" ]
       sources += [ "cert/internal/path_builder_trust_store_win_unittest.cc" ]
-      libs += [ "crypt32.lib" ]
+      libs += [ "crypt32" ]
     }
   }
 
diff -ur a/src/3rdparty/chromium/net/base/network_interfaces_win.cc b/src/3rdparty/chromium/net/base/network_interfaces_win.cc
--- a/src/3rdparty/chromium/net/base/network_interfaces_win.cc	2023-10-04 03:49:54.000000000 +0800
+++ b/src/3rdparty/chromium/net/base/network_interfaces_win.cc	2023-12-14 03:08:54.518120600 +0800
@@ -277,12 +277,14 @@
       return WIFI_PHY_LAYER_PROTOCOL_G;
     case dot11_phy_type_ht:
       return WIFI_PHY_LAYER_PROTOCOL_N;
+#if defined(COMPILER_MSVC)
     case dot11_phy_type_vht:
       return WIFI_PHY_LAYER_PROTOCOL_AC;
     case dot11_phy_type_dmg:
       return WIFI_PHY_LAYER_PROTOCOL_AD;
     case dot11_phy_type_he:
       return WIFI_PHY_LAYER_PROTOCOL_AX;
+#endif
     default:
       return WIFI_PHY_LAYER_PROTOCOL_UNKNOWN;
   }
diff -ur a/src/3rdparty/chromium/net/dns/host_resolver_system_task.cc b/src/3rdparty/chromium/net/dns/host_resolver_system_task.cc
--- a/src/3rdparty/chromium/net/dns/host_resolver_system_task.cc	2023-10-04 03:49:54.000000000 +0800
+++ b/src/3rdparty/chromium/net/dns/host_resolver_system_task.cc	2023-12-14 03:08:54.596248000 +0800
@@ -418,13 +418,13 @@
   if (host_resolver_flags & HOST_RESOLVER_CANONNAME)
     hints.ai_flags |= AI_CANONNAME;
 
-#if BUILDFLAG(IS_WIN)
+#if defined(COMPILER_MSVC)
   // See crbug.com/1176970. Flag not documented (other than the declaration
   // comment in ws2def.h) but confirmed by Microsoft to work for this purpose
   // and be safe.
   if (host_resolver_flags & HOST_RESOLVER_AVOID_MULTICAST)
     hints.ai_flags |= AI_DNS_ONLY;
-#endif  // BUILDFLAG(IS_WIN)
+#endif  // defined(COMPILER_MSVC)
 
   // Restrict result set to only this socket type to avoid duplicates.
   hints.ai_socktype = SOCK_STREAM;
diff -ur a/src/3rdparty/chromium/net/socket/udp_socket_win.cc b/src/3rdparty/chromium/net/socket/udp_socket_win.cc
--- a/src/3rdparty/chromium/net/socket/udp_socket_win.cc	2023-10-04 03:49:54.000000000 +0800
+++ b/src/3rdparty/chromium/net/socket/udp_socket_win.cc	2023-12-14 03:08:54.752458300 +0800
@@ -477,6 +477,7 @@
   DCHECK(!is_connected());
   DCHECK(!remote_address_.get());
 
+#if defined(COMPILER_MSVC)
   // Always do a random bind.
   //
   // Ignore failures, which may happen if the socket was already bound.
@@ -486,6 +487,7 @@
   setsockopt(socket_, SOL_SOCKET, SO_RANDOMIZE_PORT,
              reinterpret_cast<const char*>(&randomize_port_value),
              sizeof(randomize_port_value));
+#endif
 
   SockaddrStorage storage;
   if (!address.ToSockAddr(storage.addr, &storage.addr_len))
@@ -1255,6 +1257,7 @@
   // We won't try this address again if we get an error.
   configured_.emplace(remote_address);
 
+#if defined(COMPILER_MSVC)
   // We don't need to call SetFlow if we already have a qos flow.
   bool new_flow = flow_id_ == 0;
 
@@ -1283,6 +1286,7 @@
     api_->SetFlow(qos_handle_, flow_id_, QOSSetOutgoingDSCPValue, sizeof(buf),
                   &buf, 0, nullptr);
   }
+#endif
 
   return OK;
 }
diff -ur a/src/3rdparty/chromium/net/ssl/ssl_platform_key_win.cc b/src/3rdparty/chromium/net/ssl/ssl_platform_key_win.cc
--- a/src/3rdparty/chromium/net/ssl/ssl_platform_key_win.cc	2023-10-04 03:49:54.000000000 +0800
+++ b/src/3rdparty/chromium/net/ssl/ssl_platform_key_win.cc	2023-12-14 03:15:05.245711100 +0800
@@ -259,6 +259,7 @@
     // result, if this is a TPM-based key, we only report PSS as supported if
     // the salt length will match the digest length.
     bool supports_pss = true;
+#if defined(COMPILER_MSVC)
     if (provider_name_ == MS_PLATFORM_KEY_STORAGE_PROVIDER) {
       DWORD salt_size = 0;
       DWORD size_of_salt_size = sizeof(salt_size);
@@ -270,6 +271,7 @@
         supports_pss = false;
       }
     }
+#endif
     if (prefer_sha1_) {
       std::vector<uint16_t> ret = {
           SSL_SIGN_RSA_PKCS1_SHA1,
diff -ur a/src/3rdparty/chromium/net/third_party/quiche/src/quiche/http2/adapter/window_manager.h b/src/3rdparty/chromium/net/third_party/quiche/src/quiche/http2/adapter/window_manager.h
--- a/src/3rdparty/chromium/net/third_party/quiche/src/quiche/http2/adapter/window_manager.h	2023-10-04 03:49:54.000000000 +0800
+++ b/src/3rdparty/chromium/net/third_party/quiche/src/quiche/http2/adapter/window_manager.h	2023-12-14 03:08:54.939917300 +0800
@@ -4,6 +4,7 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include <cstdint>
 #include <functional>
 
 #include "quiche/common/platform/api/quiche_export.h"
