diff -aurN 001/SCons/Config/gnu 002/SCons/Config/gnu
--- 001/SCons/Config/gnu
+++ 002/SCons/Config/gnu
@@ -21,6 +21,8 @@
 def cross_env(env):
 	if env['PLATFORM'] != 'win32':
 		env.Tool('crossmingw', toolpath = [Dir('../Tools').rdir()])
+	else:
+		env.Tool('mingw_w64')
 
 ### flags
 
@@ -44,6 +46,8 @@
 defenv['SUBSYS_WIN'] = '-Wl,--subsystem,windows'
 defenv['MSVCRT_FLAG'] = ''
 defenv['STDCALL'] = '"__attribute__((__stdcall__))"'
+defenv['SHLIBPREFIX'] = ''
+defenv['PLATFORM'] = 'win32'
 
 # Don't allow mingw to link with LIBGCC*.DLL and LIBSTDC++-*.DLL 
 if defenv['PLATFORM'] == 'win32':
diff -aurN 001/SCons/utils.py 002/SCons/utils.py
--- 001/SCons/utils.py
+++ 002/SCons/utils.py
@@ -16,19 +16,6 @@
 	appropriate compiler and linker options to the environment
 	"""
 	zlib = 'z'
-	if platform == 'win32':
-		if 'ZLIB_W32' in env:
-			# Add include and library path of zlib for Win32
-			env.Append(CPPPATH = env['ZLIB_W32_INC'])
-			env.Append(LIBPATH = env['ZLIB_W32_LIB'])
-			zlib = ['zdll', 'z']
-			if 'ZLIB_W32_DLL' in env and env['ZLIB_W32_DLL']:
-				env.DistributeW32Bin(env['ZLIB_W32_DLL'], alias=alias)
-			if 'ZLIB_W32_NEW_DLL' in env and env['ZLIB_W32_NEW_DLL']:
-				env.DistributeW32Bin(env['ZLIB_W32_NEW_DLL'], alias=alias)
-		else:
-			print 'Please specify folder of zlib for Win32 via ZLIB_W32'
-			Exit(1)
 
 	# Avoid unnecessary configuring when cleaning targets 
 	# and a clash when scons is run in parallel operation.
diff -aurN 001/SConstruct 002/SConstruct
--- 001/SConstruct
+++ 002/SConstruct
@@ -252,7 +252,7 @@
 # write version into version.h
 f = open(defenv.File('#$BUILD_CONFIG/nsis-version.h').abspath, 'w')
 f.write('// This file is automatically generated by SCons\n// DO NOT EDIT THIS FILE\n')
-f.write('#include "%s"\n' % File('#/Source/tchar.h').abspath)
+f.write('#include "../../../Source/tchar.h"\n')
 
 if (not defenv.has_key('VER_PACKED')) and defenv.has_key('VER_MAJOR') and defenv.has_key('VER_MINOR'):
 	packed_r = packed_b = 0
diff -aurN 001/Source/script.cpp 002/Source/script.cpp
--- nsis-3.0-src/Source/script.cpp.orig	2016-10-30 08:58:32.542179500 -0400
+++ nsis-3.0-src/Source/script.cpp	2016-10-30 09:10:24.511527100 -0400
@@ -3181,7 +3181,8 @@
         TCHAR* cmdstr=line.gettoken_str(1);
         int validparams=false;
         struct postbuild_cmd *newcmd, *prevcmd;
-        newcmd=(struct postbuild_cmd*) (new BYTE[FIELD_OFFSET(struct postbuild_cmd,cmd[_tcsclen(cmdstr)+1])]);
+        const size_t newcmd_size = offsetof(struct postbuild_cmd,cmd[0]) + ((_tcsclen(cmdstr) + 1) * sizeof(TCHAR));
+        newcmd=(struct postbuild_cmd*) new BYTE[newcmd_size];
         newcmd->next=NULL, _tcscpy(newcmd->cmd,cmdstr);
         newcmd->cmpop=line.gettoken_enum(2,_T("<\0>\0<>\0=\0ignore\0")), newcmd->cmpval=line.gettoken_int(3,&validparams);
         if (line.getnumtokens() == 1+1) newcmd->cmpop=4, validparams=true; // just a command, ignore the exit code
diff -aurN 001/Source/util.cpp 002/Source/util.cpp
--- 001/Source/util.cpp
+++ 002/Source/util.cpp
@@ -965,7 +965,10 @@
 {
   STARTUPINFO si = { sizeof(STARTUPINFO), };
   PROCESS_INFORMATION pi;
-  if (!CreateProcess(NULL, const_cast<LPSTR>(cmd), NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
+  LPSTR modifiable_cmd = strdup(cmd);
+  BOOL result = CreateProcess(NULL, modifiable_cmd, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
+  free(modifiable_cmd);
+  if (!result)
     return GetLastError();
   WaitForSingleObject(pi.hProcess, INFINITE);
   GetExitCodeProcess(pi.hProcess, &si.cb);
