From 63cbeb782cf138a89ab2ffe6612b14e53ad56b3e Mon Sep 17 00:00:00 2001
From: Hannah von Reth <vonreth@kde.org>
Date: Mon, 24 Nov 2025 12:16:01 +0100
Subject: [PATCH] Use std::filesystem to generate symlinks

For historic reasons QFile::link creates a .lnk file on Windows
---
 tools/generate-symbolic-dark.cpp | 25 ++++++++++++++++++++++++-
 tools/qrcAlias.cpp               |  4 ++--
 2 files changed, 26 insertions(+), 3 deletions(-)

diff --git a/tools/generate-symbolic-dark.cpp b/tools/generate-symbolic-dark.cpp
index 7e94c934..0907e974 100644
--- a/tools/generate-symbolic-dark.cpp
+++ b/tools/generate-symbolic-dark.cpp
@@ -131,7 +131,30 @@ int main(int argc, char **argv)

             // keep symlinks
             if (inputFileInfo.isSymLink()) {
-                QFile::link(inputFileInfo.absoluteDir().relativeFilePath(inputFileInfo.symLinkTarget()), outputFilePath);
+                if (outputFileInfo.exists()) {
+                    if (!QFile::remove(outputFileInfo.filePath())) {
+                        qWarning() << u"Failed to remove old symlink:" << outputFilePath;
+                        return 1;
+                    }
+                }
+                std::error_code ec;
+                const auto targetAbsolute = QFileInfo(inputFileInfo.symLinkTarget()).filesystemFilePath();
+                const auto targetRelative = std::filesystem::relative(targetAbsolute, inputFileInfo.filesystemAbsolutePath(), ec);
+                if (ec) {
+                    qWarning() << u"Failed to resolve symlink:" << targetAbsolute.native() << u"Error:" << ec.message();
+                    return 1;
+                }
+                const auto symlink = outputFileInfo.filesystemFilePath();
+                // qInfo() << u"Create symlink:" << symlink.native() << u"with target" << targetRelative.native();
+                std::filesystem::create_symlink(targetRelative, symlink, ec);
+                if (ec) {
+                    // qWarning() << u"Failed to create symlink:" << symlink.native() << u"with target" << targetRelative.native() << u"Error:" << ec.message()
+                               // << u"falling back to copy";
+                    if (!QFile::copy(inputFilePath, outputFilePath)) {
+                        qWarning() << u"Failed to create copy:" << outputFilePath << u"of" << inputFilePath << qt_error_string();
+                        return 1;
+                    }
+                }
                 continue;
             }

diff --git a/tools/qrcAlias.cpp b/tools/qrcAlias.cpp
index 82280ecf..fe00cbbe 100644
--- a/tools/qrcAlias.cpp
+++ b/tools/qrcAlias.cpp
@@ -184,8 +184,8 @@ static void generateQRCAndCheckInputs(const QStringList &indirs, const QString &

             // more checks for links
             if (isLink) {
-                // empty canonical path means not found
-                if (fullPath.isEmpty()) {
+                // empty canonical path means not found, on Windows the path will be resolved
+                if (fullPath.isEmpty() || !QFileInfo::exists(fullPath)) {
                     // qFatal() << "Broken symlink" << file << "in input directory" << indir;
                     // ATM we allow that as otherwise the generation misses links
                     // see https://invent.kde.org/frameworks/breeze-icons/-/merge_requests/467
--
2.51.1.windows.1
