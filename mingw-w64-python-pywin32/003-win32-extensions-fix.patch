diff --git a/win32/src/PerfMon/PerfCounterDefn.cpp b/win32/src/PerfMon/PerfCounterDefn.cpp
index 9e3e17b..77516ec 100644
--- a/win32/src/PerfMon/PerfCounterDefn.cpp
+++ b/win32/src/PerfMon/PerfCounterDefn.cpp
@@ -81,7 +81,7 @@ PyObject *PyPERF_COUNTER_DEFINITION::Get(PyObject *self, PyObject *args)
     PyPERF_COUNTER_DEFINITION *This = (PyPERF_COUNTER_DEFINITION *)self;
     if (!PyArg_ParseTuple(args, ":Get"))
         return NULL;
-    if (!This->m_pCounterValue == NULL) {
+    if (This->m_pCounterValue != NULL) {
         PyErr_SetString(PyExc_ValueError, "The counter does not exist in a counter block");
         return NULL;
     }
diff --git a/win32/src/PerfMon/PyPerfMon.cpp b/win32/src/PerfMon/PyPerfMon.cpp
index fc4decf..e4e2995 100644
--- a/win32/src/PerfMon/PyPerfMon.cpp
+++ b/win32/src/PerfMon/PyPerfMon.cpp
@@ -13,7 +13,7 @@ generates Windows .hlp files.
 ******************************************************************/
 
 #include "PyWinTypes.h"
-#include "Pyperfmon.h"
+#include "pyperfmon.h"
 #include "tchar.h"
 
 extern PyObject *PerfmonMethod_NewPERF_COUNTER_DEFINITION(PyObject *self, PyObject *args);
diff --git a/win32/src/PerfMon/PyPerfMonControl.h b/win32/src/PerfMon/PyPerfMonControl.h
index 8a45068..6ac2f15 100644
--- a/win32/src/PerfMon/PyPerfMonControl.h
+++ b/win32/src/PerfMon/PyPerfMonControl.h
@@ -18,6 +18,6 @@ struct MappingManagerControlData {
     DWORD ControlSize;  // Size of this structure.
     DWORD TotalSize;    // Total Size allocated in the mapped file.
     SupplierStatus supplierStatus;
-    WCHAR ServiceName[MMCD_SERVICE_SIZE];          // The name of the service or application.
-    WCHAR EventSourceName[MMCD_EVENTSOURCE_SIZE];  // Source Name that appears in Event Log for errors.
+    WCHAR ServiceName[MMCD_SERVICE_SIZE+1];          // The name of the service or application.
+    WCHAR EventSourceName[MMCD_EVENTSOURCE_SIZE+1];  // Source Name that appears in Event Log for errors.
 };
diff --git a/win32/src/PerfMon/PyPerfMsgs.mc b/win32/src/PerfMon/PyPerfMsgs.mc
index b50f764..965b5f1 100644
--- a/win32/src/PerfMon/PyPerfMsgs.mc
+++ b/win32/src/PerfMon/PyPerfMsgs.mc
@@ -86,3 +86,4 @@ The collection DLL and application have mismatched structure sizes.  The version
 .
 ;//
 ;#endif // _PYPERFMSG_H_
+
diff --git a/win32/src/PyHANDLE.cpp b/win32/src/PyHANDLE.cpp
index c1baf75..999fab9 100644
--- a/win32/src/PyHANDLE.cpp
+++ b/win32/src/PyHANDLE.cpp
@@ -129,7 +129,7 @@ static PyNumberMethods PyHANDLE_NumberMethods = {
     PyHANDLE::binaryFailureFunc, /* nb_xor */
     PyHANDLE::binaryFailureFunc, /* nb_or */
     PyHANDLE::intFunc,           /* nb_int */
-    PyHANDLE::longFunc,          /* nb_long */
+    0,                           /* nb_long */
     PyHANDLE::unaryFailureFunc,  /* nb_float */
                                  // These removed in 3.0
 };
diff --git a/win32/src/PyWinTypes.h b/win32/src/PyWinTypes.h
index 620aada..310ed05 100644
--- a/win32/src/PyWinTypes.h
+++ b/win32/src/PyWinTypes.h
@@ -18,6 +18,18 @@
 #include "structmember.h"
 #include "windows.h"
 
+#ifndef _MSC_VER
+#define min(x,y) (((x) < (y)) ? (x) : (y))
+#define max(x,y) (((x) > (y)) ? (x) : (y))
+
+#ifndef __try
+#define __try try
+#endif
+#ifndef __except
+#define __except(filter) catch(...)
+#endif
+#endif
+
 // Helpers for our modules.
 // Some macros to help the pywin32 modules co-exist in py2x and py3k.
 // Creates and initializes local variables called 'module' and 'dict'.
diff --git a/win32/src/PyWinTypesmodule.cpp b/win32/src/PyWinTypesmodule.cpp
index 1564f84..25068f6 100644
--- a/win32/src/PyWinTypesmodule.cpp
+++ b/win32/src/PyWinTypesmodule.cpp
@@ -1062,11 +1062,17 @@ extern "C" __declspec(dllexport) BOOL WINAPI DllMain(HANDLE hInstance, DWORD dwR
 }
 
 // Function to format a python traceback into a character string.
+#ifdef _MSC_VER
 #define GPEM_ERROR(what)                                      \
     {                                                         \
         errorMsg = L"<Error getting traceback - "##what##">"; \
-        goto done;                                            \
     }
+#else
+#define GPEM_ERROR(what)                                      \
+    {                                                         \
+        errorMsg = L"<Error getting traceback - " what ">";   \
+    }
+#endif
 PYWINTYPES_EXPORT WCHAR *GetPythonTraceback(PyObject *exc_type, PyObject *exc_value, PyObject *exc_tb)
 {
     WCHAR *result = NULL;
@@ -1085,22 +1091,27 @@ PYWINTYPES_EXPORT WCHAR *GetPythonTraceback(PyObject *exc_type, PyObject *exc_va
 
     if (modStringIO == NULL)
         GPEM_ERROR("can't import cStringIO");
+        Py_XDECREF(modStringIO);
     modTB = PyImport_ImportModule("traceback");
     if (modTB == NULL)
         GPEM_ERROR("can't import traceback");
+        Py_XDECREF(modTB);
 
     /* Construct a cStringIO object */
     obFuncStringIO = PyObject_GetAttrString(modStringIO, "StringIO");
     if (obFuncStringIO == NULL)
         GPEM_ERROR("can't find cStringIO.StringIO");
+        Py_XDECREF(obFuncStringIO);
     obStringIO = PyObject_CallObject(obFuncStringIO, NULL);
     if (obStringIO == NULL)
         GPEM_ERROR("cStringIO.StringIO() failed");
+        Py_XDECREF(obStringIO);
 
     /* Get the traceback.print_exception function, and call it. */
     obFuncTB = PyObject_GetAttrString(modTB, "print_exception");
     if (obFuncTB == NULL)
         GPEM_ERROR("can't find traceback.print_exception");
+        Py_XDECREF(obFuncTB);
     // Py3k has added an undocumented 'chain' argument which defaults to True
     // and causes all kinds of exceptions while trying to print a traceback!
     // This *could* be useful thought if we can tame it - later!
@@ -1112,6 +1123,7 @@ PYWINTYPES_EXPORT WCHAR *GetPythonTraceback(PyObject *exc_type, PyObject *exc_va
                            obStringIO, chain);
     if (argsTB == NULL)
         GPEM_ERROR("can't make print_exception arguments");
+        Py_XDECREF(argsTB);
 
     obResult = PyObject_CallObject(obFuncTB, argsTB);
     if (obResult == NULL) {
@@ -1122,32 +1134,27 @@ PYWINTYPES_EXPORT WCHAR *GetPythonTraceback(PyObject *exc_type, PyObject *exc_va
         // PyUnicodeObject *uo=(PyUnicodeObject *)v;
         // DebugBreak();
         GPEM_ERROR("traceback.print_exception() failed");
+        Py_XDECREF(obResult);
     }
     /* Now call the getvalue() method in the StringIO instance */
     Py_DECREF(obFuncStringIO);
     obFuncStringIO = PyObject_GetAttrString(obStringIO, "getvalue");
     if (obFuncStringIO == NULL)
         GPEM_ERROR("can't find getvalue function");
+        Py_XDECREF(obFuncStringIO);
     Py_DECREF(obResult);
     obResult = PyObject_CallObject(obFuncStringIO, NULL);
     if (obResult == NULL)
         GPEM_ERROR("getvalue() failed.");
+        Py_XDECREF(obResult);
 
     /* And it should be a string all ready to go - duplicate it. */
     if (PyWinObject_AsWCHAR(obResult, &resultPtr, FALSE))
         result = wcsdup(resultPtr);
     else
         GPEM_ERROR("getvalue() did not return a string");
+        if (result == NULL && errorMsg != NULL)
+            result = wcsdup(errorMsg);
 
-done:
-    if (result == NULL && errorMsg != NULL)
-        result = wcsdup(errorMsg);
-    Py_XDECREF(modStringIO);
-    Py_XDECREF(modTB);
-    Py_XDECREF(obFuncStringIO);
-    Py_XDECREF(obStringIO);
-    Py_XDECREF(obFuncTB);
-    Py_XDECREF(argsTB);
-    Py_XDECREF(obResult);
     return result;
 }
diff --git a/win32/src/PythonService.cpp b/win32/src/PythonService.cpp
index 181c97b..3bc1ece 100644
--- a/win32/src/PythonService.cpp
+++ b/win32/src/PythonService.cpp
@@ -1298,7 +1298,7 @@ static void ReportAPIError(DWORD msgCode, DWORD errCode /*= 0*/)
 
     TCHAR cvtBuf[20];
     wsprintf(cvtBuf, L"%d", errCode);
-    LPTSTR lpszStrings[] = {cvtBuf, buf, L'\0'};
+    LPTSTR lpszStrings[] = {cvtBuf, buf, L"\0"};
     ReportError(msgCode, (LPCTSTR *)lpszStrings);
 }
 
diff --git a/win32/src/PythonServiceMessages.mc b/win32/src/PythonServiceMessages.mc
index 40d9c0f..8ecce64 100644
--- a/win32/src/PythonServiceMessages.mc
+++ b/win32/src/PythonServiceMessages.mc
@@ -137,7 +137,7 @@ MessageId=0x7
 Severity=Error
 SymbolicName=E_UNUSED2
 Language=English
-
+Unknown error.
 .
 
 MessageId=0x8
diff --git a/win32/src/_winxptheme.i b/win32/src/_winxptheme.i
index 3ef07bb..9f2b9b2 100644
--- a/win32/src/_winxptheme.i
+++ b/win32/src/_winxptheme.i
@@ -15,10 +15,11 @@
 %include "pywintypes.i"
 
 %{
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x0501
 
 #undef PyHANDLE
-#include "pywinobjects.h"
+#include "PyWinObjects.h"
 #include "windows.h"
 #include "Uxtheme.h"
 #include "commctrl.h"
@@ -91,6 +92,8 @@ typedef float HDC;
 		return NULL;
 }
 
+%typedef RECT RECT;
+
 %typemap(python,ignore) RECT *OUTPUT(RECT temp)
 {
   $target = &temp;
diff --git a/win32/src/mmapfilemodule.cpp b/win32/src/mmapfilemodule.cpp
index 44b1eda..1f7834d 100644
--- a/win32/src/mmapfilemodule.cpp
+++ b/win32/src/mmapfilemodule.cpp
@@ -71,7 +71,7 @@ static PyObject *mmapfile_read_byte_method(mmapfile_object *self, PyObject *args
 {
     char *where = (self->data + self->pos);
     CHECK_VALID;
-    if ((where >= 0) && (where < (self->data + self->size))) {
+    if (((INT_PTR)where >= 0) && (where < (self->data + self->size))) {
         PyObject *ret = PyBytes_FromStringAndSize(where, 1);
         if (ret)
             self->pos += 1;
diff --git a/win32/src/odbc.cpp b/win32/src/odbc.cpp
index 6190ce5..2e7523b 100644
--- a/win32/src/odbc.cpp
+++ b/win32/src/odbc.cpp
@@ -93,8 +93,8 @@ typedef struct {
 static cursorObject *cursor(PyObject *o) { return (cursorObject *)o; }
 
 static void cursorDealloc(PyObject *self);
-PyMethodDef cursorMethods[];
-PyMemberDef cursorMembers[];
+extern PyMethodDef cursorMethods[];
+extern PyMemberDef cursorMembers[];
 
 static PyTypeObject Cursor_Type = {
     PYWIN_OBJECT_HEAD "odbccur", /*tp_name */
@@ -137,8 +137,8 @@ static PyTypeObject Cursor_Type = {
 };
 
 static void connectionDealloc(PyObject *self);
-PyMethodDef connectionMethods[];
-PyMemberDef connectionMembers[];
+extern PyMethodDef connectionMethods[];
+extern PyMemberDef connectionMembers[];
 static PyTypeObject Connection_Type = {
     PYWIN_OBJECT_HEAD "odbcconn", /*tp_name */
     sizeof(connectionObject),     /*tp_basicsize */
@@ -379,7 +379,7 @@ static PyObject *odbcClose(PyObject *self, PyObject *args)
 }
 
 /* @object connection|An object representing an ODBC connection */
-static struct PyMethodDef connectionMethods[] = {
+struct PyMethodDef connectionMethods[] = {
     {"setautocommit", odbcSetAutoCommit, 1}, /* @pymeth setautocommit|Sets the autocommit mode. */
     {"commit", odbcCommit, 1},               /* @pymeth commit|Commits a transaction. */
     {"rollback", odbcRollback, 1},           /* @pymeth rollback|Rollsback a transaction. */
@@ -387,7 +387,7 @@ static struct PyMethodDef connectionMethods[] = {
     {"close", odbcClose, 1},                 /* @pymeth close|Closes the connection. */
     {0, 0}};
 
-static PyMemberDef connectionMembers[] = {{"error", T_OBJECT, offsetof(connectionObject, connectionError), READONLY},
+struct PyMemberDef connectionMembers[] = {{"error", T_OBJECT, offsetof(connectionObject, connectionError), READONLY},
                                           {NULL}};
 
 static void connectionDealloc(PyObject *self)
@@ -856,7 +856,7 @@ static int rewriteQuery(TCHAR *out, const TCHAR *in)
     parseContext ctx;
 
     initParseContext(&ctx, in);
-    while (*out++ = doParse(&ctx));
+    while (*out++ == doParse(&ctx));
     return ctx.parmCount;
 }
 
@@ -1420,7 +1420,7 @@ static PyObject *odbcCurSetOutputSize(PyObject *self, PyObject *args)
 }
 
 /* @object cursor|An object representing an ODBC cursor. */
-static PyMethodDef cursorMethods[] = {
+struct PyMethodDef cursorMethods[] = {
     {"close", odbcCurClose, 1},                 /* @pymeth close|Closes the cursor */
     {"execute", odbcCurExec, 1},                /* @pymeth execute|Execute some SQL */
     {"fetchone", odbcCurFetchOne, 1},           /* @pymeth fetchone|Fetch one row of data */
@@ -1430,7 +1430,7 @@ static PyMethodDef cursorMethods[] = {
     {"setoutputsize", odbcCurSetOutputSize, 1}, /* @pymeth setoutputsize| */
     {0, 0}};
 
-static PyMemberDef cursorMembers[] = {{"description", T_OBJECT, offsetof(cursorObject, description), READONLY},
+struct PyMemberDef cursorMembers[] = {{"description", T_OBJECT, offsetof(cursorObject, description), READONLY},
                                       {"error", T_OBJECT, offsetof(cursorObject, cursorError), READONLY},
                                       {NULL}};
 
@@ -1450,13 +1450,25 @@ static void parseInfo(connectionObject *conn, const TCHAR *c)
 
     if (!firstEqualsSign || (firstSlash && firstSlash < firstEqualsSign)) {
         _tcsncpy(buf, c, sizeof(buf) / sizeof(TCHAR));
+#ifdef _UCRT
+        p = _tcstok(buf, _T("/"), 0);
+#else
         p = _tcstok(buf, _T("/"));
+#endif
         if (p) {
             _tcsncpy(dsn, p, sizeof(dsn) / sizeof(TCHAR));
+#ifdef _UCRT
+            p = _tcstok(buf, _T("/"), 0);
+#else
             p = _tcstok(0, _T("/"));
+#endif
             if (p) {
                 _tcsncpy(uid, p, sizeof(uid) / sizeof(TCHAR));
+#ifdef _UCRT
+                p = _tcstok(buf, _T("/"), 0);
+#else
                 p = _tcstok(0, _T("/"));
+#endif
                 if (p) {
                     _tcsncpy(pwd, p, sizeof(pwd) / sizeof(TCHAR));
                 }
diff --git a/win32/src/timermodule.cpp b/win32/src/timermodule.cpp
index f06e8a4..b2ec845 100644
--- a/win32/src/timermodule.cpp
+++ b/win32/src/timermodule.cpp
@@ -8,7 +8,7 @@
 
 // @doc - Contains autoduck comments for documentation
 
-#include "pywintypes.h"
+#include "PyWinTypes.h"
 // #include "abstract.h"
 
 static PyObject *timer_id_callback_map = NULL;
diff --git a/win32/src/win32apimodule.cpp b/win32/src/win32apimodule.cpp
index 026816e..3072b6e 100644
--- a/win32/src/win32apimodule.cpp
+++ b/win32/src/win32apimodule.cpp
@@ -528,7 +528,7 @@ static PyObject *PyFindExecutable(PyObject *self, PyObject *args)
             if (rc == (HINSTANCE)31)
                 PyErr_SetString(PyWinExc_ApiError, "FindExecutable: There is no association for the file");
             else
-                PyWin_SetAPIError("FindExecutable", (int)rc);
+                PyWin_SetAPIError("FindExecutable", (INT_PTR)rc);
         }
         else ret = Py_BuildValue("(NN)", PyWinLong_FromHANDLE(rc), PyWinObject_FromTCHAR(res));
     }
@@ -1173,7 +1173,7 @@ static PyObject *PyLoadCursor(PyObject *self, PyObject *args)
     if (!PyWinObject_AsResourceId(obid, &id))
         return NULL;
     // @pyseeapi LoadCursor
-    PyW32_BEGIN_ALLOW_THREADS HCURSOR ret = ::LoadCursor(hInstance, MAKEINTRESOURCE(id));
+    PyW32_BEGIN_ALLOW_THREADS HCURSOR ret = ::LoadCursor(hInstance, MAKEINTRESOURCE((ULONG_PTR)id));
     PyW32_END_ALLOW_THREADS PyWinObject_FreeResourceId(id);
     if (ret == NULL)
         ReturnAPIError("LoadCursor");
@@ -1787,7 +1787,7 @@ static PyObject *PyGetProcAddress(PyObject *self, PyObject *args)
     if (proc == NULL)
         return ReturnAPIError("GetProcAddress");
     // @pyseeapi GetProcAddress
-    return PyWinLong_FromVoidPtr(proc);
+    return PyWinLong_FromVoidPtr((PVOID)proc);
 }
 
 // @pymethod <o PyUnicode>|win32api|GetDllDirectory|Returns the DLL search path
@@ -4298,7 +4298,7 @@ static PyObject *PyShellExecute(PyObject *self, PyObject *args)
         PyW32_BEGIN_ALLOW_THREADS HINSTANCE rc = ::ShellExecute(hwnd, op, file, params, dir, show);
         PyW32_END_ALLOW_THREADS
             // @pyseeapi ShellExecute
-            if (rc <= (HINSTANCE)32) PyWin_SetAPIError("ShellExecute", (int)rc);
+            if (rc <= (HINSTANCE)32) PyWin_SetAPIError("ShellExecute", (INT_PTR)rc);
         else ret = PyWinLong_FromVoidPtr(rc);
     }
     PyWinObject_FreeTCHAR(op);
@@ -5277,8 +5277,8 @@ static PyObject *PyApply(PyObject *self, PyObject *args)
     }
     PyThreadState *stateSave = PyThreadState_Swap(NULL);
     PyThreadState_Swap(stateSave);
-    _try { ret = PyObject_CallObject(obFunc, obArgs); }
-    _except(PyApplyExceptionFilter(GetExceptionCode(), GetExceptionInformation(), obHandler, &exc_type, &exc_value))
+    __try { ret = PyObject_CallObject(obFunc, obArgs); }
+    __except(PyApplyExceptionFilter(GetExceptionCode(), GetExceptionInformation(), obHandler, &exc_type, &exc_value))
     {
         // Do my best to restore the thread state to a sane spot.
         PyThreadState *stateCur = PyThreadState_Swap(NULL);
diff --git a/win32/src/win32clipboardmodule.cpp b/win32/src/win32clipboardmodule.cpp
index 9ffe4b0..c89bef6 100644
--- a/win32/src/win32clipboardmodule.cpp
+++ b/win32/src/win32clipboardmodule.cpp
@@ -15,7 +15,7 @@
 
 #define PY_SSIZE_T_CLEAN  // this should be Py_ssize_t clean!
 
-#include "pywintypes.h"
+#include "PyWinTypes.h"
 
 #define CHECK_NO_ARGS2(args, fnName)              \
     do {                                          \
@@ -1107,12 +1107,11 @@ static struct PyMethodDef clipboard_functions[] = {
     {NULL, NULL}};
 
 #define ADD_CONSTANT(tok)                                \
-    if (rc = PyModule_AddIntConstant(module, #tok, tok)) \
+    if (int rc = PyModule_AddIntConstant(module, #tok, tok)) \
     return rc
 
 static int AddConstants(PyObject *module)
 {
-    int rc;
     ADD_CONSTANT(CF_TEXT);
     ADD_CONSTANT(CF_BITMAP);
     ADD_CONSTANT(CF_METAFILEPICT);
diff --git a/win32/src/win32consolemodule.cpp b/win32/src/win32consolemodule.cpp
index daae981..df0ba07 100644
--- a/win32/src/win32consolemodule.cpp
+++ b/win32/src/win32consolemodule.cpp
@@ -1,4 +1,5 @@
 // @doc
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x501
 #include "PyWinTypes.h"
 #include "PyWinObjects.h"
diff --git a/win32/src/win32credmodule.cpp b/win32/src/win32credmodule.cpp
index 2825c22..084b85d 100644
--- a/win32/src/win32credmodule.cpp
+++ b/win32/src/win32credmodule.cpp
@@ -1,4 +1,5 @@
 // @doc
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x501  // Credentials functions only available on WinXP
 #include "PyWinTypes.h"
 #include "PyWinObjects.h"
@@ -1175,8 +1176,10 @@ PYWIN_MODULE_INIT_FUNC(win32cred)
     PyModule_AddIntConstant(module, "CRED_TYPE_DOMAIN_PASSWORD", CRED_TYPE_DOMAIN_PASSWORD);
     PyModule_AddIntConstant(module, "CRED_TYPE_DOMAIN_CERTIFICATE", CRED_TYPE_DOMAIN_CERTIFICATE);
     PyModule_AddIntConstant(module, "CRED_TYPE_DOMAIN_VISIBLE_PASSWORD", CRED_TYPE_DOMAIN_VISIBLE_PASSWORD);
+#ifdef _MSC_VER
     PyModule_AddIntConstant(module, "CRED_TYPE_GENERIC_CERTIFICATE", CRED_TYPE_GENERIC_CERTIFICATE);
     PyModule_AddIntConstant(module, "CRED_TYPE_DOMAIN_EXTENDED", CRED_TYPE_DOMAIN_EXTENDED);
+#endif
     PyModule_AddIntConstant(module, "CRED_TYPE_MAXIMUM", CRED_TYPE_MAXIMUM);
     PyModule_AddIntConstant(module, "CRED_TYPE_MAXIMUM_EX", CRED_TYPE_MAXIMUM + 1000);
     // credential flags
@@ -1238,7 +1241,9 @@ PYWIN_MODULE_INIT_FUNC(win32cred)
     PyModule_AddIntConstant(module, "CREDUI_MAX_USERNAME_LENGTH", CREDUI_MAX_USERNAME_LENGTH);
     PyModule_AddIntConstant(module, "CREDUI_MAX_PASSWORD_LENGTH", CREDUI_MAX_PASSWORD_LENGTH);
 
+#ifdef _MSC_VER
     PyModule_AddIntConstant(module, "CRED_ENUMERATE_ALL_CREDENTIALS", CRED_ENUMERATE_ALL_CREDENTIALS);
+#endif
 
     PYWIN_MODULE_INIT_RETURN_SUCCESS;
 }
diff --git a/win32/src/win32crypt/win32cryptmodule.cpp b/win32/src/win32crypt/win32cryptmodule.cpp
index 3f801fc..2a1c637 100644
--- a/win32/src/win32crypt/win32cryptmodule.cpp
+++ b/win32/src/win32crypt/win32cryptmodule.cpp
@@ -1,4 +1,5 @@
 // @doc
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x502
 #include "win32crypt.h"
 
@@ -583,6 +584,7 @@ static PyObject *PyCertOpenStore(PyObject *self, PyObject *args, PyObject *kwarg
         pvPara = (void *)&cssrp;
     }
     else {
+#ifdef _MSC_VER
         switch ((ULONG_PTR)StoreProvider) {
             case CERT_STORE_PROV_PHYSICAL:
             case CERT_STORE_PROV_FILENAME:
@@ -624,6 +626,41 @@ static PyObject *PyCertOpenStore(PyObject *self, PyObject *args, PyObject *kwarg
                 return NULL;
             }
         }
+#else
+        if (StoreProvider == CERT_STORE_PROV_PHYSICAL)
+        if (StoreProvider == CERT_STORE_PROV_FILENAME)
+        if (StoreProvider == CERT_STORE_PROV_SYSTEM)
+        if (StoreProvider == CERT_STORE_PROV_SYSTEM_REGISTRY)
+        if (StoreProvider == CERT_STORE_PROV_LDAP) {
+            if (!PyWinObject_AsWCHAR(obpvPara, (WCHAR **)&pvPara))
+                return NULL;
+            free_wchar = TRUE;
+	}
+        if (StoreProvider == CERT_STORE_PROV_REG) {
+            if (!PyWinObject_AsHKEY(obpvPara, (HKEY *)&pvPara))
+                return NULL;
+	}
+        if (StoreProvider == CERT_STORE_PROV_FILE) {
+            if (!PyWinObject_AsHANDLE(obpvPara, (HANDLE *)&pvPara))
+                return NULL;
+	}
+        if (StoreProvider == CERT_STORE_PROV_SERIALIZED)
+        if (StoreProvider == CERT_STORE_PROV_PKCS7) {
+            if (!pybuf.init(obpvPara))
+                return NULL;
+            crypt_data_blob.pbData = (BYTE*)pybuf.ptr();
+            crypt_data_blob.cbData = pybuf.len();
+            pvPara = (void *)&crypt_data_blob;
+	}
+        if (StoreProvider == CERT_STORE_PROV_MEMORY) {
+            // pvPara is not used, warn if something passed in
+            if (obpvPara != Py_None)
+                PyErr_Warn(PyExc_RuntimeWarning, "Para ignored for CERT_STORE_PROV_MEMORY");
+	}
+
+        PyErr_SetString(PyExc_NotImplementedError, "Specified store provider type not supported");
+        return NULL;
+#endif
     }
 
     Py_BEGIN_ALLOW_THREADS hcertstore = CertOpenStore(StoreProvider, dwEncodingType, hcryptprov, dwFlags, pvPara);
diff --git a/win32/src/win32dynamicdialog.cpp b/win32/src/win32dynamicdialog.cpp
index bef6473..9e159a3 100644
--- a/win32/src/win32dynamicdialog.cpp
+++ b/win32/src/win32dynamicdialog.cpp
@@ -31,14 +31,14 @@
 
 #ifdef WIN32GUI  // being compiled from WIN32GUI
 #define PYW_EXPORT
-#include "python.h"
+#include "Python.h"
 #undef PyHANDLE
 #include <windows.h>
 #include "commctrl.h"
 #include "windowsx.h"  // For edit control hacks.
 
-#include "pywintypes.h"
-#include "pywinobjects.h"
+#include "PyWinTypes.h"
+#include "PyWinObjects.h"
 #include "tchar.h"
 
 #define BASED_CODE
@@ -51,7 +51,7 @@
 #endif
 
 #include "win32dynamicdialog.h"
-static void DwordAlign(PCHAR *ptr)
+void DwordAlign(PCHAR *ptr)
 {
     size_t offset = ((ULONG_PTR)*ptr) & 0x03;
     if (offset > 0) {
@@ -211,7 +211,7 @@ void CPythonDialogTemplate::Set(DLGTEMPLATE *tmpl)
 
 HGLOBAL CPythonDialogTemplate::ClaimTemplate()
 {
-    register HGLOBAL h = m_h;
+    HGLOBAL h = m_h;
     m_h = NULL;
     m_alloc = 0;
     m_len = 0;
@@ -597,7 +597,7 @@ static BOOL ParseDlgItemList(CPythonDialogTemplate *dlg, PyObject *tmpl)
         goto cleanup;
 
     if (IS_INTRESOURCE(wclass))
-        ret = dlg->Add((WORD)wclass, &tpl, caption);
+        ret = dlg->Add((DWORD_PTR)wclass, &tpl, caption);
     else
         ret = dlg->Add(wclass, &tpl, caption, pybuf.len(), (BYTE *)pybuf.ptr());
 
@@ -628,7 +628,7 @@ PYW_EXPORT HGLOBAL MakeResourceFromDlgList(PyObject *tmpl)
     if (dlg == NULL)
         return NULL;
 
-    for (register Py_ssize_t i = 1; i < size; i++) {
+    for (Py_ssize_t i = 1; i < size; i++) {
         if (!ParseDlgItemList(dlg, PyTuple_GET_ITEM(obdlg, i))) {
             delete dlg;
             Py_DECREF(obdlg);
diff --git a/win32/src/win32event.i b/win32/src/win32event.i
index 2ed1fab..992b1b6 100644
--- a/win32/src/win32event.i
+++ b/win32/src/win32event.i
@@ -18,6 +18,7 @@
 
 // only seem able to make this work with an incorrect level of
 // indirection, and fixing it up inline with a temp.
+%typedef PTIMERAPCROUTINE PTIMERAPCROUTINE;
 %typemap(python,in) PTIMERAPCROUTINE *(PTIMERAPCROUTINE temp) {
 	if ($source != Py_None) {
 		PyErr_SetString(PyExc_TypeError, "This param must be None");
@@ -84,14 +85,13 @@
 
 #define EVENT_ALL_ACCESS EVENT_ALL_ACCESS // Specifies all possible access flags for the event object.
 
-#define EVENT_MODIFY_STATE EVENT_MODIFY_STATE // Enables use of the event handle in the SetEvent and ResetEvent�functions to modify the event�s state.
+#define EVENT_MODIFY_STATE EVENT_MODIFY_STATE // Enables use of the event handle in the SetEvent and ResetEvent functions to modify the event's state.
 
-#define SYNCHRONIZE SYNCHRONIZE // Windows NT only:�Enables use of the event handle in any of the wait functions�to wait for the event�s state to be signaled.
+#define SYNCHRONIZE SYNCHRONIZE // Windows NT only: Enables use of the event handle in any of the wait functions to wait for the event's state to be signaled.
 
 // @pyswig |CancelWaitableTimer|Cancels a waiting timer.
 BOOLAPI CancelWaitableTimer(PyHANDLE handle);
 
-#end
 
 // @pyswig <o PyHANDLE>|CreateEvent|Creates a waitable event
 // @rdesc The result is a handle to the created object
@@ -384,7 +384,7 @@ static PyObject *MyWaitForMultipleObjectsEx(
     DWORD dwMilliseconds,	// @pyparm int|milliseconds||time-out interval in milliseconds
     BOOL bAlertable 	// @pyparm bool|bAlertable||alertable wait flag.
    );
-%typedef DWORD DWORD_WAITAPI
+%typedef DWORD DWORD_WAITAPI;
 %typemap(python,except) DWORD_WAITAPI {
       Py_BEGIN_ALLOW_THREADS
       $function
diff --git a/win32/src/win32evtlog.i b/win32/src/win32evtlog.i
index 111b0a3..dd865f2 100644
--- a/win32/src/win32evtlog.i
+++ b/win32/src/win32evtlog.i
@@ -4,9 +4,18 @@
 // <nl>The Evt* functions are only available on Vista and later.  Attempting to call
 //	them on XP will result in the process exiting, rather than a python exception.
 
+%{
+#ifndef _MSC_VER
+#undef _WIN32_WINNT
+#define _WIN32_WINNT 0x0600 // for EVT_SUBSCRIBE_NOTIFY_ACTION
+#endif
+%}
+
 %include "typemaps.i"
 %include "pywin32.i"
 
+%typedef HANDLE EVT_HANDLE;
+
 %{
 
 #include <structmember.h>
diff --git a/win32/src/win32file.i b/win32/src/win32file.i
index 5b1b010..4f05d0b 100644
--- a/win32/src/win32file.i
+++ b/win32/src/win32file.i
@@ -47,7 +47,7 @@
 
 #include "winsock2.h"
 #include "mswsock.h"
-#include "pywintypes.h"
+#include "PyWinTypes.h"
 #include "winbase.h"
 #include "assert.h"
 #include <stddef.h>
@@ -71,6 +71,9 @@
 %include "typemaps.i"
 %include "pywin32.i"
 
+%typedef DCB DCB;
+%typedef COMMTIMEOUTS COMMTIMEOUTS;
+
 %{
 
 #include "datetime.h" // python's datetime header.
@@ -697,8 +700,8 @@ static PyObject *PySetFileTime (PyObject *self, PyObject *args, PyObject *kwargs
 		&obHandle, &obCreationTime, &obLastAccessTime, &obLastWriteTime, &UTCTimes))
 		return NULL;
 
-    if (!PyWinObject_AsHANDLE(obHandle, &hHandle))
-        return NULL;
+	if (!PyWinObject_AsHANDLE(obHandle, &hHandle))
+		return NULL;
 	if (obCreationTime != Py_None){
 		if (!PyWinObject_AsFILETIME(obCreationTime, &FileTime))
 			return NULL;
@@ -5297,7 +5300,7 @@ static PyObject *py_GetFullPathName(PyObject *self, PyObject *args, PyObject *kw
 
 	PyErr_Clear();
 	char *cpathin;
-	if (cpathin=PyBytes_AsString(obpathin)){
+	if (cpathin==PyBytes_AsString(obpathin)){
 		if (htrans)
 			CHECK_PFN(GetFullPathNameTransactedA);
 		char *cpathret=NULL, *cfilepart, *cpathsave=NULL;
diff --git a/win32/src/win32file_comm.cpp b/win32/src/win32file_comm.cpp
index bcd2d36..cb2eda0 100644
--- a/win32/src/win32file_comm.cpp
+++ b/win32/src/win32file_comm.cpp
@@ -165,7 +165,7 @@ PyDCB::~PyDCB(void) {}
 #define GET_BITFIELD_ENTRY(bitfield_name)                     \
     else if (strcmp(name, #bitfield_name) == 0)               \
     {                                                         \
-        return PyLong_FromLong(pydcb->m_DCB.##bitfield_name); \
+        return PyLong_FromLong(pydcb->m_DCB.bitfield_name);   \
     }
 
 PyObject *PyDCB::getattro(PyObject *self, PyObject *obname)
@@ -201,7 +201,7 @@ PyObject *PyDCB::getattro(PyObject *self, PyObject *obname)
             PyErr_Format(PyExc_TypeError, szNeedIntAttr, #bitfield_name); \
             return -1;                                                    \
         }                                                                 \
-        pydcb->m_DCB.##bitfield_name = PyLong_AsLong(v);                  \
+        pydcb->m_DCB.bitfield_name = PyLong_AsLong(v);                    \
         return 0;                                                         \
     }
 
@@ -367,7 +367,7 @@ PyCOMSTAT::~PyCOMSTAT(void) {}
 #define GET_BITFIELD_ENTRY(bitfield_name)                             \
     else if (strcmp(name, #bitfield_name) == 0)                       \
     {                                                                 \
-        return PyLong_FromLong(pyCOMSTAT->m_COMSTAT.##bitfield_name); \
+        return PyLong_FromLong(pyCOMSTAT->m_COMSTAT.bitfield_name);   \
     }
 
 PyObject *PyCOMSTAT::getattro(PyObject *self, PyObject *obname)
@@ -397,7 +397,7 @@ PyObject *PyCOMSTAT::getattro(PyObject *self, PyObject *obname)
             PyErr_Format(PyExc_TypeError, szNeedIntAttr, #bitfield_name); \
             return -1;                                                    \
         }                                                                 \
-        pyCOMSTAT->m_COMSTAT.##bitfield_name = PyLong_AsLong(v);          \
+        pyCOMSTAT->m_COMSTAT.bitfield_name = PyLong_AsLong(v);            \
         return 0;                                                         \
     }
 
diff --git a/win32/src/win32gui.i b/win32/src/win32gui.i
index 518e84c..ecc30ef 100644
--- a/win32/src/win32gui.i
+++ b/win32/src/win32gui.i
@@ -4,15 +4,28 @@
 %module win32gui // A module which provides an interface to the native win32 GUI API.
 
 %{
+#ifndef _WIN32_WINNT
 #define _WIN32_WINNT 0x0501
+#endif
 
 %}
 %include "typemaps.i"
 %include "pywintypes.i"
 
+%typedef POINT POINT;
+%typedef RECT RECT;
+%typedef MSG MSG;
+%typedef TRACKMOUSEEVENT TRACKMOUSEEVENT;
+%typedef PAINTSTRUCT PAINTSTRUCT;
+%typedef ICONINFO ICONINFO;
+%typedef LOGFONT LOGFONT;
+%typedef MENUITEMINFO MENUITEMINFO;
+%typedef NOTIFYICONDATA NOTIFYICONDATA;
+%typedef OPENFILENAME OPENFILENAME;
+
 %{
 #undef PyHANDLE
-#include "pywinobjects.h"
+#include "PyWinObjects.h"
 #include "winuser.h"
 #include "commctrl.h"
 #include "windowsx.h" // For edit control hacks.
@@ -336,14 +349,14 @@ typedef float HDC, HCURSOR, HINSTANCE, HMENU, HICON, HGDIOBJ, HIMAGELIST, HACCEL
 }
 
 %apply COLORREF {long};
-typedef long COLORREF
+typedef long COLORREF;
 
 typedef HANDLE WPARAM;
 typedef HANDLE LPARAM;
 typedef HANDLE LRESULT;
 typedef int UINT;
 
-%typedef void *NULL_ONLY
+%typedef void *NULL_ONLY;
 
 %typemap(python,in) NULL_ONLY {
 	if ($source != Py_None) {
@@ -1711,9 +1724,9 @@ static PyObject *PyGetBufferAddressAndLen(PyObject *self, PyObject *args)
 %native (PyGetBufferAddressAndLen) PyGetBufferAddressAndLen;
 
 
-%typedef TCHAR *STRING_OR_ATOM_CW
-%typedef TCHAR *RESOURCE_ID
-%typedef TCHAR *RESOURCE_ID_NULLOK
+%typedef TCHAR *STRING_OR_ATOM_CW;
+%typedef TCHAR *RESOURCE_ID;
+%typedef TCHAR *RESOURCE_ID_NULLOK;
 
 %typemap(python,arginit) STRING_OR_ATOM_CW, RESOURCE_ID, RESOURCE_ID_NULLOK{
 	$target=NULL;
@@ -1776,12 +1789,12 @@ PyObject *PyFlashWindowEx(PyObject *self, PyObject *args)
 		return NULL;
     // not on NT
 	HMODULE hmod = GetModuleHandle(_T("user32"));
-    BOOL (WINAPI *pfnFW)(PFLASHWINFO) = NULL;
-    if (hmod)
-        pfnFW = (BOOL (WINAPI *)(PFLASHWINFO))GetProcAddress(hmod, "FlashWindowEx");
-    if (pfnFW==NULL)
-        return PyErr_Format(PyExc_NotImplementedError,
-                            "FlashWindowsEx is not supported on this version of windows");
+	BOOL (WINAPI *pfnFW)(PFLASHWINFO) = NULL;
+	if (hmod)
+		pfnFW = (BOOL (WINAPI *)(PFLASHWINFO))GetProcAddress(hmod, "FlashWindowEx");
+	if (pfnFW==NULL)
+		return PyErr_Format(PyExc_NotImplementedError,
+			"FlashWindowsEx is not supported on this version of windows");
 	Py_BEGIN_ALLOW_THREADS
 	rc = (*pfnFW)(&f);
 	Py_END_ALLOW_THREADS
@@ -7521,13 +7534,13 @@ PyObject *PyRegisterDeviceNotification(PyObject *self, PyObject *args)
 				"structure says it has %d bytes, but %d was provided",
 				(int)struct_bytes, (int)pybuf.len());
 	// @pyseeapi RegisterDeviceNotification
-	HDEVNOTIFY not;
+	HDEVNOTIFY notify;
 	Py_BEGIN_ALLOW_THREADS
-	not = RegisterDeviceNotification(handle, pybuf.ptr(), flags);
+	notify = RegisterDeviceNotification(handle, pybuf.ptr(), flags);
 	Py_END_ALLOW_THREADS
-	if (not == NULL)
+	if (notify == NULL)
 		return PyWin_SetAPIError("RegisterDeviceNotification");
-	return PyWinObject_FromHDEVNOTIFY(not);
+	return PyWinObject_FromHDEVNOTIFY(notify);
 }
 %}
 %native(RegisterDeviceNotification) PyRegisterDeviceNotification;
diff --git a/win32/src/win32helpmodule.cpp b/win32/src/win32helpmodule.cpp
index 9bf9bf7..ee48fdd 100644
--- a/win32/src/win32helpmodule.cpp
+++ b/win32/src/win32helpmodule.cpp
@@ -2544,13 +2544,11 @@ data tuple items must be integers");
 
 // Module constants:
 #define ADD_CONSTANT(tok)                                \
-    if (rc = PyModule_AddIntConstant(module, #tok, tok)) \
+    if (int rc = PyModule_AddIntConstant(module, #tok, tok)) \
     return rc
 
 int AddConstants(PyObject *module)
 {
-    int rc;
-
 #ifdef _DEBUG
     int debug = 1;
 #else
@@ -3091,7 +3089,7 @@ int AddConstants(PyObject *module)
     // @const win32help|HH_GPROPID_CONTENT_LANGUAGE|long: LandId for desired
     // content.
 
-    return rc;
+    return 0;
 }
 
 /* List of functions exported by this module */
diff --git a/win32/src/win32inet_winhttp.cpp b/win32/src/win32inet_winhttp.cpp
index a3292da..2c7b0ea 100644
--- a/win32/src/win32inet_winhttp.cpp
+++ b/win32/src/win32inet_winhttp.cpp
@@ -6,8 +6,8 @@
 // The intent is to only wrap stuff which isn't otherwise doable from
 // Python, such as the proxy stuff.
 
-#include "pywintypes.h"
-#include "pywinobjects.h"
+#include "PyWinTypes.h"
+#include "PyWinObjects.h"
 #include "winhttp.h"
 
 // @doc
diff --git a/win32/src/win32lzmodule.cpp b/win32/src/win32lzmodule.cpp
index 651bdcf..9ac5406 100644
--- a/win32/src/win32lzmodule.cpp
+++ b/win32/src/win32lzmodule.cpp
@@ -11,7 +11,7 @@ generates Windows .hlp files.
 
 ******************************************************************/
 
-#include "Pywintypes.h"
+#include "PyWinTypes.h"
 #include "lzexpand.h"
 
 static PyObject *obHandleMap = NULL;
diff --git a/win32/src/win32net/win32netmisc.cpp b/win32/src/win32net/win32netmisc.cpp
index 025665e..7277690 100644
--- a/win32/src/win32net/win32netmisc.cpp
+++ b/win32/src/win32net/win32netmisc.cpp
@@ -1355,7 +1355,8 @@ PyObject *PyNetServerComputerNameDel(PyObject *self, PyObject *args)
 
 #if WINVER >= 0x0500
 
-extern "C" NetValidateNamefunc pfnNetValidateName = NULL;
+extern "C" NetValidateNamefunc pfnNetValidateName;
+NetValidateNamefunc pfnNetValidateName = NULL;
 // @pymethod |win32net|NetValidateName|Checks that domain/machine/workgroup name is valid for given context
 // @rdesc Returns none if valid, exception if not
 // @comm If Account and Password aren't passed, current logon credentials are used
@@ -1398,8 +1399,10 @@ PyObject *PyNetValidateName(PyObject *self, PyObject *args)
     return ret;
 }
 
-extern "C" NetValidatePasswordPolicyfunc pfnNetValidatePasswordPolicy = NULL;
-extern "C" NetValidatePasswordPolicyFreefunc pfnNetValidatePasswordPolicyFree = NULL;
+extern "C" NetValidatePasswordPolicyfunc pfnNetValidatePasswordPolicy;
+NetValidatePasswordPolicyfunc pfnNetValidatePasswordPolicy = NULL;
+extern "C" NetValidatePasswordPolicyFreefunc pfnNetValidatePasswordPolicyFree;
+NetValidatePasswordPolicyFreefunc pfnNetValidatePasswordPolicyFree = NULL;
 
 static void PyObject_CleanupAUTH_INPUT(NET_VALIDATE_AUTHENTICATION_INPUT_ARG *p)
 {
diff --git a/win32/src/win32pdhmodule.cpp b/win32/src/win32pdhmodule.cpp
index 8d3c7d7..1b08a04 100644
--- a/win32/src/win32pdhmodule.cpp
+++ b/win32/src/win32pdhmodule.cpp
@@ -1002,7 +1002,7 @@ PDH_STATUS __stdcall PyCounterPathCallback(DWORD_PTR dwArg)
     {                                                             \
         if (i < seqLen) {                                         \
             PyObject *subItem = PyTuple_GET_ITEM(flags_tuple, i); \
-            myCfg.cfg.##r = PyObject_IsTrue(subItem);             \
+            myCfg.cfg.r = PyObject_IsTrue(subItem);               \
         }                                                         \
     }
 
diff --git a/win32/src/win32process.i b/win32/src/win32process.i
index 331ed0f..6689827 100644
--- a/win32/src/win32process.i
+++ b/win32/src/win32process.i
@@ -1598,6 +1598,7 @@ PyObject *PyIsWow64Process(PyObject *self, PyObject *args)
 	$target = PyWinLong_FromVoidPtr($source);
 }
 
+%typedef ULONG_PTR ULONG_PTR;
 
 // @pyswig long|VirtualAllocEx|
 LONG_VOIDPTR VirtualAllocEx(
diff --git a/win32/src/win32rasmodule.cpp b/win32/src/win32rasmodule.cpp
index 3ed8c33..9aeac86 100644
--- a/win32/src/win32rasmodule.cpp
+++ b/win32/src/win32rasmodule.cpp
@@ -15,7 +15,7 @@ generates Windows .hlp files.
 #define WINVER 0x500
 #endif
 
-#include "pywintypes.h"
+#include "PyWinTypes.h"
 #include "ras.h"
 #include "raserror.h"
 
@@ -549,7 +549,7 @@ static PyObject *PyRasDial(PyObject *self, PyObject *args)
         pNotification = NULL;
     }
     else if (PyCallable_Check(obCallback)) {
-        pNotification = PyRasDialFunc1;
+        pNotification = (LPVOID)PyRasDialFunc1;
         notType = 1;
     }
     else if (PyLong_Check(obCallback)) {
@@ -782,15 +782,15 @@ static PyObject *PyRasGetEntryDialParams(PyObject *self, PyObject *args)
 // @pymethod string|win32ras|GetErrorString|Returns an error string for a RAS error code.
 static PyObject *PyRasGetErrorString(PyObject *self, PyObject *args)
 {
+    TCHAR buf[512];
     DWORD error;
-    DWORD rc;
+    DWORD rc = RasGetErrorString(error, buf, sizeof(buf) / sizeof(buf[0]));
     if (!PyArg_ParseTuple(args, "i:GetErrorString",
                           &error))  // @pyparm int|error||The error value being queried.
         return NULL;
 
-    TCHAR buf[512];
     // @pyseeapi RasGetErrorString
-    if (rc = RasGetErrorString(error, buf, sizeof(buf) / sizeof(buf[0])))
+    if (rc)
         return ReturnRasError("RasGetErrorString");
     return PyWinObject_FromTCHAR(buf);
 }
@@ -798,14 +798,14 @@ static PyObject *PyRasGetErrorString(PyObject *self, PyObject *args)
 // @pymethod |win32ras|HangUp|Terminates a remote access session.
 static PyObject *PyRasHangUp(PyObject *self, PyObject *args)
 {
-    DWORD rc;
     HRASCONN hras;
+    DWORD rc = RasHangUp(hras);
     if (!PyArg_ParseTuple(args, "O&:HangUp", PyWinObject_AsHANDLE,
                           &hras))  // @pyparm int|hras||The handle to the RAS connection to be terminated.
         return NULL;
 
     // @pyseeapi RasHangUp
-    if (rc = RasHangUp(hras))
+    if (rc)
         return ReturnRasError("RasHangup");
     Py_INCREF(Py_None);
     return Py_None;
@@ -818,7 +818,7 @@ static PyObject *PyRasIsHandleValid(PyObject *self, PyObject *args)
     if (!PyArg_ParseTuple(args, "O&:IsHandleValid", PyWinObject_AsHANDLE,
                           &hras))  // @pyparm int|hras||The handle to the RAS connection being checked.
         return NULL;
-    BOOL bRet = (hras >= 0);
+    BOOL bRet = ((INT_PTR)hras >= 0);
     return PyBool_FromLong(bRet);
 }
 
@@ -924,7 +924,7 @@ static struct PyMethodDef win32ras_functions[] = {
     {NULL, NULL}};
 
 #define ADD_CONSTANT(tok)                                \
-    if (rc = PyModule_AddIntConstant(module, #tok, tok)) \
+    if (int rc = PyModule_AddIntConstant(module, #tok, tok)) \
     return rc
 #define ADD_ENUM(parta, partb)                                                 \
     if (rc = PyModule_AddIntConstant(module, #parta "_" #partb, parta::partb)) \
@@ -935,7 +935,6 @@ static struct PyMethodDef win32ras_functions[] = {
 
 static int AddConstants(PyObject *module)
 {
-    int rc;
     ADD_CONSTANT(RASCS_OpenPort);             // @const win32ras|RASCS_OpenPort|Constant for RAS state.
     ADD_CONSTANT(RASCS_PortOpened);           // @const win32ras|RASCS_PortOpened|Constant for RAS state.
     ADD_CONSTANT(RASCS_ConnectDevice);        // @const win32ras|RASCS_ConnectDevice|Constant for RAS state.
diff --git a/win32/src/win32security.i b/win32/src/win32security.i
index c614d30..c0de13a 100644
--- a/win32/src/win32security.i
+++ b/win32/src/win32security.i
@@ -5,6 +5,7 @@
 %module win32security // An interface to the win32 security API's
 
 %{
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x0600 // Vista!
 %}
 
@@ -76,7 +77,7 @@ static IsTokenRestrictedfunc pfnIsTokenRestricted = NULL;
 
 typedef PSecurityFunctionTableW (SEC_ENTRY *InitSecurityInterfacefunc)(void);
 static InitSecurityInterfacefunc pfnInitSecurityInterface=NULL;
-extern PSecurityFunctionTableW psecurityfunctiontable=NULL;
+PSecurityFunctionTableW psecurityfunctiontable=NULL;
 
 typedef BOOL (WINAPI *TranslateNamefunc)(LPCTSTR, EXTENDED_NAME_FORMAT, EXTENDED_NAME_FORMAT, LPTSTR, PULONG);
 static TranslateNamefunc pfnTranslateName=NULL;
@@ -89,20 +90,20 @@ static LogonUserExExfunc pfnLogonUserExEx = NULL;
 
 
 // function pointers used in win32security_sspi.cpp and win32security_ds.cpp
-extern DsBindfunc pfnDsBind=NULL;
-extern DsUnBindfunc pfnDsUnBind=NULL;
-extern DsGetSpnfunc pfnDsGetSpn=NULL;
-extern DsWriteAccountSpnfunc pfnDsWriteAccountSpn=NULL;
-extern DsFreeSpnArrayfunc pfnDsFreeSpnArray=NULL;
-extern DsGetDcNamefunc pfnDsGetDcName=NULL;
-extern DsCrackNamesfunc pfnDsCrackNames=NULL;
-extern DsListInfoForServerfunc pfnDsListInfoForServer=NULL;
-extern DsListServersForDomainInSitefunc pfnDsListServersForDomainInSite=NULL;
-extern DsListServersInSitefunc pfnDsListServersInSite=NULL;
-extern DsListSitesfunc pfnDsListSites=NULL;
-extern DsListDomainsInSitefunc pfnDsListDomainsInSite=NULL;
-extern DsListRolesfunc pfnDsListRoles=NULL;
-extern DsFreeNameResultfunc pfnDsFreeNameResult=NULL;
+DsBindfunc pfnDsBind=NULL;
+DsUnBindfunc pfnDsUnBind=NULL;
+DsGetSpnfunc pfnDsGetSpn=NULL;
+DsWriteAccountSpnfunc pfnDsWriteAccountSpn=NULL;
+DsFreeSpnArrayfunc pfnDsFreeSpnArray=NULL;
+DsGetDcNamefunc pfnDsGetDcName=NULL;
+DsCrackNamesfunc pfnDsCrackNames=NULL;
+DsListInfoForServerfunc pfnDsListInfoForServer=NULL;
+DsListServersForDomainInSitefunc pfnDsListServersForDomainInSite=NULL;
+DsListServersInSitefunc pfnDsListServersInSite=NULL;
+DsListSitesfunc pfnDsListSites=NULL;
+DsListDomainsInSitefunc pfnDsListDomainsInSite=NULL;
+DsListRolesfunc pfnDsListRoles=NULL;
+DsFreeNameResultfunc pfnDsFreeNameResult=NULL;
 
 static HMODULE advapi32_dll=NULL;
 static HMODULE secur32_dll =NULL;
@@ -114,8 +115,8 @@ static HMODULE netapi32_dll=NULL;
 HMODULE loadmodule(WCHAR *dllname)
 {
 	HMODULE hmodule = GetModuleHandle(dllname);
-    if (hmodule==NULL)
-        hmodule = LoadLibrary(dllname);
+	if (hmodule==NULL)
+		hmodule = LoadLibrary(dllname);
 	return hmodule;
 }
 
@@ -3337,12 +3338,14 @@ static PyObject *PyCreateRestrictedToken(PyObject *self, PyObject *args, PyObjec
 	if (PyWinObject_AsHANDLE(obExistingTokenHandle, &ExistingTokenHandle))
 		if (PyWinObject_AsSID_AND_ATTRIBUTESArray(obSidsToDisable, &SidsToDisable, &DisableSidCount))
 			if (PyWinObject_AsSID_AND_ATTRIBUTESArray(obSidsToRestrict, &SidsToRestrict, &RestrictedSidCount))
-				if (PyWinObject_AsLUID_AND_ATTRIBUTESArray(obPrivilegesToDelete, &PrivilegesToDelete, &DeletePrivilegeCount))
+				if (PyWinObject_AsLUID_AND_ATTRIBUTESArray(obPrivilegesToDelete, &PrivilegesToDelete, &DeletePrivilegeCount)){
 					if ((*pfnCreateRestrictedToken)(ExistingTokenHandle,Flags,DisableSidCount,SidsToDisable,
-							DeletePrivilegeCount,PrivilegesToDelete,RestrictedSidCount,SidsToRestrict,&NewTokenHandle))
+							DeletePrivilegeCount,PrivilegesToDelete,RestrictedSidCount,SidsToRestrict,&NewTokenHandle)){
 						ret=PyWinObject_FromHANDLE(NewTokenHandle);
-					else
+					}else{
 						PyWin_SetAPIError("CreateRestrictedToken",GetLastError());
+					}
+				}
 	if (SidsToDisable!=NULL)
 		free(SidsToDisable);
 	if (PrivilegesToDelete!=NULL)
diff --git a/win32/src/win32service.i b/win32/src/win32service.i
index 1150dff..c43ad17 100644
--- a/win32/src/win32service.i
+++ b/win32/src/win32service.i
@@ -3,9 +3,18 @@
 %module win32service // An interface to the Windows NT Service API
 
 
+%{
+#ifndef _MSC_VER
+#undef _WIN32_WINNT
+#define _WIN32_WINNT 0x0600 // for SERVICE_*
+#endif
+%}
+
 %include "typemaps.i"
 %include "pywin32.i"
 
+%typedef SERVICE_STATUS SERVICE_STATUS;
+
 %{
 #undef PyHANDLE
 #include "PyWinObjects.h"
diff --git a/win32/src/win32tsmodule.cpp b/win32/src/win32tsmodule.cpp
index c4156f9..c5f8e37 100644
--- a/win32/src/win32tsmodule.cpp
+++ b/win32/src/win32tsmodule.cpp
@@ -1,5 +1,7 @@
 // @doc
+#ifndef _WIN32_WINNT
 #define _WIN32_WINNT 0x501
+#endif
 #include "PyWinTypes.h"
 #include "PyWinObjects.h"
 #include "structmember.h"
diff --git a/win32/src/win32wnet/PyNCB.cpp b/win32/src/win32wnet/PyNCB.cpp
index e2290be..ee73e80 100644
--- a/win32/src/win32wnet/PyNCB.cpp
+++ b/win32/src/win32wnet/PyNCB.cpp
@@ -17,9 +17,9 @@
  ******************************************************************/
 // @doc
 
-#include "Pywintypes.h"
+#include "PyWinTypes.h"
 #include <windows.h>
-#include "python.h"
+#include "Python.h"
 #include "PyNCB.h"
 
 #include <crtdbg.h>
diff --git a/win32/src/win32wnet/PyNetresource.cpp b/win32/src/win32wnet/PyNetresource.cpp
index 9d928b3..8e258ae 100644
--- a/win32/src/win32wnet/PyNetresource.cpp
+++ b/win32/src/win32wnet/PyNetresource.cpp
@@ -18,7 +18,7 @@
 // @doc
 
 #include "PyWinTypes.h"
-#include "netres.h"  // C++ header file for NETRESOURCE object
+#include "Netres.h"  // C++ header file for NETRESOURCE object
 
 static PyObject *NETRESOURCE_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
 {
diff --git a/win32/src/win32wnet/win32wnet.cpp b/win32/src/win32wnet/win32wnet.cpp
index fe5c6cc..a57ff9d 100644
--- a/win32/src/win32wnet/win32wnet.cpp
+++ b/win32/src/win32wnet/win32wnet.cpp
@@ -38,8 +38,8 @@
 
 #include "PyWinTypes.h"
 #include "PyWinObjects.h"  // for the PyHANDLE impl.
-#include "netres.h"        // NETRESOURCE Type
-#include "pyncb.h"
+#include "Netres.h"        // NETRESOURCE Type
+#include "PyNCB.h"
 
 /****************************************************************************
         HELPER FUNCTIONS
