diff -urN pywin32-b304-orig/win32/src/PerfMon/PyPerfMon.cpp pywin32-b304/win32/src/PerfMon/PyPerfMon.cpp
--- pywin32-b304-orig/win32/src/PerfMon/PyPerfMon.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/PerfMon/PyPerfMon.cpp	2022-11-06 01:33:32.255207800 +0800
@@ -13,7 +13,7 @@
 ******************************************************************/
 
 #include "PyWinTypes.h"
-#include "Pyperfmon.h"
+#include "pyperfmon.h"
 #include "tchar.h"
 
 extern PyObject *PerfmonMethod_NewPERF_COUNTER_DEFINITION(PyObject *self, PyObject *args);
diff -urN pywin32-b304-orig/win32/src/PerfMon/PyPerfMonControl.h pywin32-b304/win32/src/PerfMon/PyPerfMonControl.h
--- pywin32-b304-orig/win32/src/PerfMon/PyPerfMonControl.h	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/PerfMon/PyPerfMonControl.h	2022-11-06 01:33:32.259208000 +0800
@@ -18,6 +18,6 @@
     DWORD ControlSize;  // Size of this structure.
     DWORD TotalSize;    // Total Size allocated in the mapped file.
     SupplierStatus supplierStatus;
-    WCHAR ServiceName[MMCD_SERVICE_SIZE];          // The name of the service or application.
-    WCHAR EventSourceName[MMCD_EVENTSOURCE_SIZE];  // Source Name that appears in Event Log for errors.
+    WCHAR ServiceName[MMCD_SERVICE_SIZE+1];          // The name of the service or application.
+    WCHAR EventSourceName[MMCD_EVENTSOURCE_SIZE+1];  // Source Name that appears in Event Log for errors.
 };
diff -urN pywin32-b304-orig/win32/src/PerfMon/PyPerfMsgs.mc pywin32-b304/win32/src/PerfMon/PyPerfMsgs.mc
--- pywin32-b304-orig/win32/src/PerfMon/PyPerfMsgs.mc	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/PerfMon/PyPerfMsgs.mc	2022-11-06 01:33:32.315211300 +0800
@@ -86,3 +86,4 @@
 .
 ;//
 ;#endif // _PYPERFMSG_H_
+
diff -urN pywin32-b304-orig/win32/src/PerfMon/perfmondata.cpp pywin32-b304/win32/src/PerfMon/perfmondata.cpp
--- pywin32-b304-orig/win32/src/PerfMon/perfmondata.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/PerfMon/perfmondata.cpp	2022-11-06 01:33:32.324211800 +0800
@@ -414,7 +414,7 @@
 --*/
 {
     HKEY hAppKey;
-    TCHAR LogLevelKeyName[] = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
+    TCHAR LogLevelKeyName[] = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib");
 
     TCHAR LogLevelValueName[] = _T("EventLogLevel");
     LONG lStatus;
diff -urN pywin32-b304-orig/win32/src/PyDEVMODE.cpp pywin32-b304/win32/src/PyDEVMODE.cpp
--- pywin32-b304-orig/win32/src/PyDEVMODE.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/PyDEVMODE.cpp	2022-11-06 01:33:32.333212300 +0800
@@ -361,6 +361,7 @@
 BOOL PyWinObject_AsDEVMODE(PyObject *ob, PDEVMODE *ppDEVMODE, BOOL bNoneOk)
 {
     if (ob == Py_None)
+    {
         if (bNoneOk) {
             *ppDEVMODE = NULL;
             return TRUE;
@@ -369,6 +370,7 @@
             PyErr_SetString(PyExc_ValueError, "PyDEVMODE cannot be None in this context");
             return FALSE;
         }
+    }
     if (!PyDEVMODE_Check(ob))
         return FALSE;
     *ppDEVMODE = ((PyDEVMODEA *)ob)->GetDEVMODE();
@@ -759,6 +761,7 @@
 BOOL PyWinObject_AsDEVMODE(PyObject *ob, PDEVMODEW *ppDEVMODE, BOOL bNoneOk)
 {
     if (ob == Py_None)
+    {
         if (bNoneOk) {
             *ppDEVMODE = NULL;
             return TRUE;
@@ -767,6 +770,7 @@
             PyErr_SetString(PyExc_ValueError, "PyDEVMODE cannot be None in this context");
             return FALSE;
         }
+    }
     if (!PyDEVMODEW_Check(ob))
         return FALSE;
     *ppDEVMODE = ((PyDEVMODEW *)ob)->GetDEVMODE();
diff -urN pywin32-b304-orig/win32/src/PyHANDLE.cpp pywin32-b304/win32/src/PyHANDLE.cpp
--- pywin32-b304-orig/win32/src/PyHANDLE.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/PyHANDLE.cpp	2022-11-06 01:33:32.344212900 +0800
@@ -135,7 +135,11 @@
     0, /* nb_coerce (allowed to be zero) - removed in 3.0 */
 #endif
     PyHANDLE::intFunc,          /* nb_int */
+#if (PY_VERSION_HEX < 0x03000000)
     PyHANDLE::longFunc,         /* nb_long */
+#else
+    0,
+#endif
     PyHANDLE::unaryFailureFunc, /* nb_float */
                                 // These removed in 3.0
 #if (PY_VERSION_HEX < 0x03000000)
diff -urN pywin32-b304-orig/win32/src/PySecurityObjects.h pywin32-b304/win32/src/PySecurityObjects.h
--- pywin32-b304-orig/win32/src/PySecurityObjects.h	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/PySecurityObjects.h	2022-11-06 01:33:32.352213400 +0800
@@ -118,7 +118,7 @@
     static PyObject *GetSubAuthorityCount(PyObject *self, PyObject *args);
     static PyObject *GetSubAuthority(PyObject *self, PyObject *args);
     static PyObject *GetSidIdentifierAuthority(PyObject *self, PyObject *args);
-    static struct PyMethodDef PySID::methods[];
+    static struct PyMethodDef methods[];
 
    protected:
     PSID m_psid;
@@ -155,7 +155,7 @@
     /* Python support */
     int compare(PyObject *ob);
     static void deallocFunc(PyObject *ob);
-    static struct PyMethodDef PyACL::methods[];
+    static struct PyMethodDef methods[];
 
     static PyObject *Initialize(PyObject *self, PyObject *args);
     static PyObject *IsValid(PyObject *self, PyObject *args);
diff -urN pywin32-b304-orig/win32/src/PyWinTypes.h pywin32-b304/win32/src/PyWinTypes.h
--- pywin32-b304-orig/win32/src/PyWinTypes.h	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/PyWinTypes.h	2022-11-06 01:33:32.359213800 +0800
@@ -28,6 +28,18 @@
 #include "windows.h"
 #undef WRITE_RESTRICTED  // stop anyone using the wrong one accidently...
 
+#ifndef _MSC_VER
+#define min(x,y) (((x) < (y)) ? (x) : (y))
+#define max(x,y) (((x) > (y)) ? (x) : (y))
+
+#ifndef __try
+#define __try try
+#endif
+#ifndef __except
+#define __except(filter) catch(...)
+#endif
+#endif
+
 // Helpers for our modules.
 // Some macros to help the pywin32 modules co-exist in py2x and py3k.
 // Creates and initializes local variables called 'module' and 'dict'.
diff -urN pywin32-b304-orig/win32/src/PyWinTypesmodule.cpp pywin32-b304/win32/src/PyWinTypesmodule.cpp
--- pywin32-b304-orig/win32/src/PyWinTypesmodule.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/PyWinTypesmodule.cpp	2022-11-06 02:31:48.810199300 +0800
@@ -1136,11 +1136,18 @@
 }
 
 // Function to format a python traceback into a character string.
+#ifdef _MSC_VER
 #define GPEM_ERROR(what)                                     \
     {                                                        \
         errorMsg = L"<Error getting traceback - "##what##">"; \
         goto done;                                           \
     }
+#else
+#define GPEM_ERROR(what)                                     \
+    {                                                        \
+        errorMsg = L"<Error getting traceback - " what ">";  \
+    }
+#endif
 PYWINTYPES_EXPORT WCHAR *GetPythonTraceback(PyObject *exc_type, PyObject *exc_value, PyObject *exc_tb)
 {
     WCHAR *result = NULL;
@@ -1159,22 +1166,27 @@
 
     if (modStringIO == NULL)
         GPEM_ERROR("cant import cStringIO");
+        Py_XDECREF(modStringIO);
     modTB = PyImport_ImportModule("traceback");
     if (modTB == NULL)
         GPEM_ERROR("cant import traceback");
+        Py_XDECREF(modTB);
 
     /* Construct a cStringIO object */
     obFuncStringIO = PyObject_GetAttrString(modStringIO, "StringIO");
     if (obFuncStringIO == NULL)
         GPEM_ERROR("cant find cStringIO.StringIO");
+        Py_XDECREF(obFuncStringIO);
     obStringIO = PyObject_CallObject(obFuncStringIO, NULL);
     if (obStringIO == NULL)
         GPEM_ERROR("cStringIO.StringIO() failed");
+        Py_XDECREF(obStringIO);
 
     /* Get the traceback.print_exception function, and call it. */
     obFuncTB = PyObject_GetAttrString(modTB, "print_exception");
     if (obFuncTB == NULL)
         GPEM_ERROR("cant find traceback.print_exception");
+        Py_XDECREF(obFuncTB);
     // Py3k has added an undocumented 'chain' argument which defaults to True
     // and causes all kinds of exceptions while trying to print a traceback!
     // This *could* be useful thought if we can tame it - later!
@@ -1189,6 +1201,7 @@
     );
     if (argsTB == NULL)
         GPEM_ERROR("cant make print_exception arguments");
+        Py_XDECREF(argsTB);
 
     obResult = PyObject_CallObject(obFuncTB, argsTB);
     if (obResult == NULL) {
@@ -1199,32 +1212,27 @@
         // PyUnicodeObject *uo=(PyUnicodeObject *)v;
         // DebugBreak();
         GPEM_ERROR("traceback.print_exception() failed");
+        Py_XDECREF(obResult);
     }
     /* Now call the getvalue() method in the StringIO instance */
     Py_DECREF(obFuncStringIO);
     obFuncStringIO = PyObject_GetAttrString(obStringIO, "getvalue");
     if (obFuncStringIO == NULL)
         GPEM_ERROR("cant find getvalue function");
+        Py_XDECREF(obFuncStringIO);
     Py_DECREF(obResult);
     obResult = PyObject_CallObject(obFuncStringIO, NULL);
     if (obResult == NULL)
         GPEM_ERROR("getvalue() failed.");
+        Py_XDECREF(obResult);
 
     /* And it should be a string all ready to go - duplicate it. */
     if (PyWinObject_AsWCHAR(obResult, &resultPtr, FALSE))
         result = wcsdup(resultPtr);
     else
         GPEM_ERROR("getvalue() did not return a string");
+        if (result == NULL && errorMsg != NULL)
+            result = wcsdup(errorMsg);
 
-done:
-    if (result == NULL && errorMsg != NULL)
-        result = wcsdup(errorMsg);
-    Py_XDECREF(modStringIO);
-    Py_XDECREF(modTB);
-    Py_XDECREF(obFuncStringIO);
-    Py_XDECREF(obStringIO);
-    Py_XDECREF(obFuncTB);
-    Py_XDECREF(argsTB);
-    Py_XDECREF(obResult);
     return result;
 }
diff -urN pywin32-b304-orig/win32/src/PythonService.cpp pywin32-b304/win32/src/PythonService.cpp
--- pywin32-b304-orig/win32/src/PythonService.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/PythonService.cpp	2022-11-06 01:33:32.372214500 +0800
@@ -881,6 +881,7 @@
             ReportPythonError(E_PYS_NOT_CONTROL_HANDLER);
         // else no instance - an error has already been reported.
         if (!bServiceDebug)
+        {
             if (g_RegisterServiceCtrlHandlerEx) {
                 // Use 2K/XP extended registration if available
                 pe->sshStatusHandle = g_RegisterServiceCtrlHandlerEx(lpszArgv[0], service_ctrl_ex, pe);
@@ -889,6 +890,7 @@
                 // Otherwise fall back to NT
                 pe->sshStatusHandle = RegisterServiceCtrlHandler(lpszArgv[0], service_ctrl);
             }
+        }
     }
     // No instance - we can't start.
     if (!instance) {
@@ -1156,7 +1158,7 @@
         else {
             // Some other nasty error - log it.
             ReportAPIError(PYS_E_API_CANT_START_SERVICE, errCode);
-            printf("Could not start the service - error %d\n", errCode);
+            printf("Could not start the service - error %ld\n", errCode);
             // Just incase the error was caused by this EXE not being registered
 #ifndef BUILD_FREEZE
             RegisterPythonServiceExe();
@@ -1312,13 +1314,13 @@
 // Register the EXE.
 // This writes an entry to the Python registry and also
 // to the EventLog so I can stick in messages.
-static BOOL RegisterPythonServiceExe(void)
+BOOL RegisterPythonServiceExe(void)
 {
     printf("Registering the Python Service Manager...\n");
     const int fnameBufSize = MAX_PATH + 1;
     TCHAR fnameBuf[fnameBufSize];
     if (GetModuleFileName(NULL, fnameBuf, fnameBufSize) == 0) {
-        printf("Registration failed due to GetModuleFileName() failing (error %d)\n", GetLastError());
+        printf("Registration failed due to GetModuleFileName() failing (error %ld)\n", GetLastError());
         return FALSE;
     }
     assert(Py_IsInitialized());
@@ -1337,7 +1339,7 @@
     wsprintf(keyBuf, _T("Software\\Python\\PythonService\\%hs"), szVerString);
     DWORD rc;
     if ((rc = RegSetValue(HKEY_LOCAL_MACHINE, keyBuf, REG_SZ, fnameBuf, _tcslen(fnameBuf))) != ERROR_SUCCESS) {
-        printf("Registration failed due to RegSetValue() of service EXE - error %d\n", rc);
+        printf("Registration failed due to RegSetValue() of service EXE - error %ld\n", rc);
         return FALSE;
     }
     // don't bother registering in the event log - do it when we write a log entry.
@@ -1373,7 +1375,7 @@
 
     TCHAR cvtBuf[20];
     wsprintf(cvtBuf, L"%d", errCode);
-    LPTSTR lpszStrings[] = {cvtBuf, buf, L'\0'};
+    LPTSTR lpszStrings[] = {cvtBuf, buf, L"\0"};
     ReportError(msgCode, (LPCTSTR *)lpszStrings);
 }
 
diff -urN pywin32-b304-orig/win32/src/PythonServiceMessages.mc pywin32-b304/win32/src/PythonServiceMessages.mc
--- pywin32-b304-orig/win32/src/PythonServiceMessages.mc	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/PythonServiceMessages.mc	2022-11-06 01:33:32.378214900 +0800
@@ -137,7 +137,7 @@
 Severity=Error
 SymbolicName=E_UNUSED2
 Language=English
-
+Unknown error.
 .
 
 MessageId=0x8
diff -urN pywin32-b304-orig/win32/src/_winxptheme.i pywin32-b304/win32/src/_winxptheme.i
--- pywin32-b304-orig/win32/src/_winxptheme.i	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/_winxptheme.i	2022-11-06 01:33:32.384215200 +0800
@@ -15,12 +15,14 @@
 %include "pywintypes.i"
 
 %{
+#undef _WIN32_IE
 #define _WIN32_IE 0x0501 // to enable balloon notifications in Shell_NotifyIcon
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x0501
 //#define ISOLATION_AWARE_ENABLED 1
 
 #undef PyHANDLE
-#include "pywinobjects.h"
+#include "PyWinObjects.h"
 #include "windows.h"
 #include "Uxtheme.h"
 #include "commctrl.h"
@@ -93,6 +95,8 @@
 		return NULL;
 }
 
+%typedef RECT RECT;
+
 %typemap(python,ignore) RECT *OUTPUT(RECT temp)
 {
   $target = &temp;
diff -urN pywin32-b304-orig/win32/src/mmapfilemodule.cpp pywin32-b304/win32/src/mmapfilemodule.cpp
--- pywin32-b304-orig/win32/src/mmapfilemodule.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/mmapfilemodule.cpp	2022-11-06 01:33:32.388215400 +0800
@@ -71,7 +71,7 @@
 {
     char *where = (self->data + self->pos);
     CHECK_VALID;
-    if ((where >= 0) && (where < (self->data + self->size))) {
+    if (((INT_PTR)where >= 0) && (where < (self->data + self->size))) {
         PyObject *ret = PyBytes_FromStringAndSize(where, 1);
         if (ret)
             self->pos += 1;
diff -urN pywin32-b304-orig/win32/src/odbc.cpp pywin32-b304/win32/src/odbc.cpp
--- pywin32-b304-orig/win32/src/odbc.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/odbc.cpp	2022-11-06 01:33:32.393215700 +0800
@@ -93,8 +93,8 @@
 static cursorObject *cursor(PyObject *o) { return (cursorObject *)o; }
 
 static void cursorDealloc(PyObject *self);
-PyMethodDef cursorMethods[];
-PyMemberDef cursorMembers[];
+extern PyMethodDef cursorMethods[];
+extern PyMemberDef cursorMembers[];
 
 static PyTypeObject Cursor_Type = {
     PYWIN_OBJECT_HEAD "odbccur", /*tp_name */
@@ -137,8 +137,8 @@
 };
 
 static void connectionDealloc(PyObject *self);
-PyMethodDef connectionMethods[];
-PyMemberDef connectionMembers[];
+extern PyMethodDef connectionMethods[];
+extern PyMemberDef connectionMembers[];
 static PyTypeObject Connection_Type = {
     PYWIN_OBJECT_HEAD "odbcconn", /*tp_name */
     sizeof(connectionObject),     /*tp_basicsize */
@@ -379,7 +379,7 @@
 }
 
 /* @object connection|An object representing an ODBC connection */
-static struct PyMethodDef connectionMethods[] = {
+struct PyMethodDef connectionMethods[] = {
     {"setautocommit", odbcSetAutoCommit, 1}, /* @pymeth setautocommit|Sets the autocommit mode. */
     {"commit", odbcCommit, 1},               /* @pymeth commit|Commits a transaction. */
     {"rollback", odbcRollback, 1},           /* @pymeth rollback|Rollsback a transaction. */
@@ -387,7 +387,7 @@
     {"close", odbcClose, 1},                 /* @pymeth close|Closes the connection. */
     {0, 0}};
 
-static PyMemberDef connectionMembers[] = {{"error", T_OBJECT, offsetof(connectionObject, connectionError), READONLY},
+struct PyMemberDef connectionMembers[] = {{"error", T_OBJECT, offsetof(connectionObject, connectionError), READONLY},
                                           {NULL}};
 
 static void connectionDealloc(PyObject *self)
@@ -1422,7 +1422,7 @@
 }
 
 /* @object cursor|An object representing an ODBC cursor. */
-static PyMethodDef cursorMethods[] = {
+struct PyMethodDef cursorMethods[] = {
     {"close", odbcCurClose, 1},                 /* @pymeth close|Closes the cursor */
     {"execute", odbcCurExec, 1},                /* @pymeth execute|Execute some SQL */
     {"fetchone", odbcCurFetchOne, 1},           /* @pymeth fetchone|Fetch one row of data */
@@ -1432,7 +1432,7 @@
     {"setoutputsize", odbcCurSetOutputSize, 1}, /* @pymeth setoutputsize| */
     {0, 0}};
 
-static PyMemberDef cursorMembers[] = {{"description", T_OBJECT, offsetof(cursorObject, description), READONLY},
+struct PyMemberDef cursorMembers[] = {{"description", T_OBJECT, offsetof(cursorObject, description), READONLY},
                                       {"error", T_OBJECT, offsetof(cursorObject, cursorError), READONLY},
                                       {NULL}};
 
diff -urN pywin32-b304-orig/win32/src/timermodule.cpp pywin32-b304/win32/src/timermodule.cpp
--- pywin32-b304-orig/win32/src/timermodule.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/timermodule.cpp	2022-11-06 01:33:32.397215900 +0800
@@ -8,7 +8,7 @@
 
 // @doc - Contains autoduck comments for documentation
 
-#include "pywintypes.h"
+#include "PyWinTypes.h"
 //#include "abstract.h"
 
 static PyObject *timer_id_callback_map = NULL;
diff -urN pywin32-b304-orig/win32/src/win32api_display.cpp pywin32-b304/win32/src/win32api_display.cpp
--- pywin32-b304-orig/win32/src/win32api_display.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32api_display.cpp	2022-11-06 01:33:32.401216200 +0800
@@ -134,28 +134,36 @@
         return NULL;
 
     if (strcmp(name, "DeviceName") == 0)
+    {
         if (pdisplay_device->DeviceName[31] == 0)  // in case DeviceName fills space and has no trailing NULL
             return PyWinObject_FromTCHAR(pdisplay_device->DeviceName);
         else
             return PyWinObject_FromTCHAR(pdisplay_device->DeviceName, 32);
+    }
 
     if (strcmp(name, "DeviceString") == 0)
+    {
         if (pdisplay_device->DeviceString[127] == 0)  // in case DeviceString fills space and has no trailing NULL
             return PyWinObject_FromTCHAR(pdisplay_device->DeviceString);
         else
             return PyWinObject_FromTCHAR(pdisplay_device->DeviceString, 128);
+    }
 
     if (strcmp(name, "DeviceID") == 0)
+    {
         if (pdisplay_device->DeviceID[127] == 0)  // in case DeviceID fills space and has no trailing NULL
             return PyWinObject_FromTCHAR(pdisplay_device->DeviceID);
         else
             return PyWinObject_FromTCHAR(pdisplay_device->DeviceID, 128);
+    }
 
     if (strcmp(name, "DeviceKey") == 0)
+    {
         if (pdisplay_device->DeviceKey[127] == 0)  // in case DeviceKey fills space and has no trailing NULL
             return PyWinObject_FromTCHAR(pdisplay_device->DeviceKey);
         else
             return PyWinObject_FromTCHAR(pdisplay_device->DeviceKey, 128);
+    }
 
     return PyObject_GenericGetAttr(self, obname);
 }
@@ -243,6 +251,7 @@
 BOOL PyWinObject_AsDISPLAY_DEVICE(PyObject *ob, PDISPLAY_DEVICE *ppDISPLAY_DEVICE, BOOL bNoneOk)
 {
     if (ob == Py_None)
+    {
         if (bNoneOk) {
             *ppDISPLAY_DEVICE = NULL;
             return TRUE;
@@ -251,6 +260,7 @@
             PyErr_SetString(PyExc_ValueError, "PyDISPLAY_DEVICE cannot be None in this context");
             return FALSE;
         }
+    }
     if (!PyDISPLAY_DEVICE_Check(ob))
         return FALSE;
     *ppDISPLAY_DEVICE = ((PyDISPLAY_DEVICE *)ob)->GetDISPLAY_DEVICE();
diff -urN pywin32-b304-orig/win32/src/win32apimodule.cpp pywin32-b304/win32/src/win32apimodule.cpp
--- pywin32-b304-orig/win32/src/win32apimodule.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32apimodule.cpp	2022-11-06 02:58:48.359306200 +0800
@@ -551,7 +551,7 @@
             if (rc == (HINSTANCE)31)
                 PyErr_SetString(PyWinExc_ApiError, "FindExecutable: There is no association for the file");
             else
-                PyWin_SetAPIError("FindExecutable", (int)rc);
+                PyWin_SetAPIError("FindExecutable", (INT_PTR)rc);
         }
         else ret = Py_BuildValue("(NN)", PyWinLong_FromHANDLE(rc), PyWinObject_FromTCHAR(res));
     }
@@ -1307,7 +1307,7 @@
     if (!PyWinObject_AsResourceId(obid, &id))
         return NULL;
     // @pyseeapi LoadCursor
-    PyW32_BEGIN_ALLOW_THREADS HCURSOR ret = ::LoadCursor(hInstance, MAKEINTRESOURCE(id));
+    PyW32_BEGIN_ALLOW_THREADS HCURSOR ret = ::LoadCursor(hInstance, MAKEINTRESOURCE((ULONG_PTR)id));
     PyW32_END_ALLOW_THREADS PyWinObject_FreeResourceId(id);
     if (ret == NULL)
         ReturnAPIError("LoadCursor");
@@ -1967,7 +1967,7 @@
     if (proc == NULL)
         return ReturnAPIError("GetProcAddress");
     // @pyseeapi GetProcAddress
-    return PyWinLong_FromVoidPtr(proc);
+    return PyWinLong_FromVoidPtr((PVOID)proc);
 }
 
 // @pymethod <o PyUnicode>|win32api|GetDllDirectory|Returns the DLL search path
@@ -4609,7 +4609,7 @@
         PyW32_BEGIN_ALLOW_THREADS HINSTANCE rc = ::ShellExecute(hwnd, op, file, params, dir, show);
         PyW32_END_ALLOW_THREADS
             // @pyseeapi ShellExecute
-            if (rc <= (HINSTANCE)32) PyWin_SetAPIError("ShellExecute", (int)rc);
+            if (rc <= (HINSTANCE)32) PyWin_SetAPIError("ShellExecute", (INT_PTR)rc);
         else ret = PyWinLong_FromVoidPtr(rc);
     }
     PyWinObject_FreeTCHAR(op);
@@ -5593,8 +5593,8 @@
     }
     PyThreadState *stateSave = PyThreadState_Swap(NULL);
     PyThreadState_Swap(stateSave);
-    _try { ret = PyObject_CallObject(obFunc, obArgs); }
-    _except(PyApplyExceptionFilter(GetExceptionCode(), GetExceptionInformation(), obHandler, &exc_type, &exc_value))
+    __try { ret = PyObject_CallObject(obFunc, obArgs); }
+    __except(PyApplyExceptionFilter(GetExceptionCode(), GetExceptionInformation(), obHandler, &exc_type, &exc_value))
     {
         // Do my best to restore the thread state to a sane spot.
         PyThreadState *stateCur = PyThreadState_Swap(NULL);
diff -urN pywin32-b304-orig/win32/src/win32clipboardmodule.cpp pywin32-b304/win32/src/win32clipboardmodule.cpp
--- pywin32-b304-orig/win32/src/win32clipboardmodule.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32clipboardmodule.cpp	2022-11-06 01:33:32.416217000 +0800
@@ -17,7 +17,7 @@
 
 #define PY_SSIZE_T_CLEAN  // this should be Py_ssize_t clean!
 
-#include "pywintypes.h"
+#include "PyWinTypes.h"
 
 #define CHECK_NO_ARGS2(args, fnName)              \
     do {                                          \
@@ -1104,12 +1104,11 @@
     {NULL, NULL}};
 
 #define ADD_CONSTANT(tok)                                \
-    if (rc = PyModule_AddIntConstant(module, #tok, tok)) \
+    if (int rc = PyModule_AddIntConstant(module, #tok, tok)) \
     return rc
 
 static int AddConstants(PyObject *module)
 {
-    int rc;
     ADD_CONSTANT(CF_TEXT);
     ADD_CONSTANT(CF_BITMAP);
     ADD_CONSTANT(CF_METAFILEPICT);
diff -urN pywin32-b304-orig/win32/src/win32consolemodule.cpp pywin32-b304/win32/src/win32consolemodule.cpp
--- pywin32-b304-orig/win32/src/win32consolemodule.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32consolemodule.cpp	2022-11-06 01:33:32.421217300 +0800
@@ -1,4 +1,5 @@
 // @doc
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x501
 #include "PyWinTypes.h"
 #include "PyWinObjects.h"
@@ -1296,6 +1297,7 @@
         PyWinObject_AsSMALL_RECT(obcliprect, &pcliprect, TRUE) &&
         PyWinObject_AsCOORD(obdestcoord, &pdestcoord, FALSE) &&
         PyWinObject_AsSingleWCHAR(obfillchar, &char_info.Char.UnicodeChar))
+    {
         if (!ScrollConsoleScreenBuffer(((PyConsoleScreenBuffer *)self)->m_handle, pscrollrect, pcliprect, *pdestcoord,
                                        &char_info))
             PyWin_SetAPIError("ScrollConsoleScreenBuffer");
@@ -1303,6 +1305,7 @@
             Py_INCREF(Py_None);
             return Py_None;
         }
+    }
     return NULL;
 }
 
@@ -1814,12 +1817,14 @@
     CHECK_PFN(AddConsoleAlias);
     if (PyWinObject_AsWCHAR(obsource, &source, FALSE) && PyWinObject_AsWCHAR(obtarget, &target, TRUE) &&
         PyWinObject_AsWCHAR(obexename, &exename, FALSE))
+    {
         if (!(*pfnAddConsoleAlias)(source, target, exename))
             PyWin_SetAPIError("AddConsoleAlias");
         else {
             Py_INCREF(Py_None);
             ret = Py_None;
         }
+    }
     PyWinObject_FreeWCHAR(source);
     PyWinObject_FreeWCHAR(target);
     PyWinObject_FreeWCHAR(exename);
diff -urN pywin32-b304-orig/win32/src/win32credmodule.cpp pywin32-b304/win32/src/win32credmodule.cpp
--- pywin32-b304-orig/win32/src/win32credmodule.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32credmodule.cpp	2022-11-06 01:33:32.426217600 +0800
@@ -1,4 +1,5 @@
 // @doc
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x501  // Credentials functions only available on WinXP
 #include "PyWinTypes.h"
 #include "PyWinObjects.h"
diff -urN pywin32-b304-orig/win32/src/win32crypt/win32cryptmodule.cpp pywin32-b304/win32/src/win32crypt/win32cryptmodule.cpp
--- pywin32-b304-orig/win32/src/win32crypt/win32cryptmodule.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32crypt/win32cryptmodule.cpp	2022-11-06 01:33:32.431217900 +0800
@@ -1,4 +1,5 @@
 // @doc
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x502
 #include "win32crypt.h"
 
@@ -486,7 +487,7 @@
         CertEnumSystemStore(dwFlags, pvSystemStoreLocationPara, ret, CertEnumSystemStoreCallback);
     Py_END_ALLOW_THREADS
 
-        if (!bsuccess)
+    if (!bsuccess)
     {
         Py_DECREF(ret);
         ret = NULL;
@@ -495,10 +496,12 @@
     }
 
     if (pvSystemStoreLocationPara != NULL)
+    {
         if (dwFlags & CERT_SYSTEM_STORE_RELOCATE_FLAG)
             PyWinObject_FreeWCHAR((WCHAR *)cssrp.pwszSystemStore);
         else
             PyWinObject_FreeWCHAR((WCHAR *)pvSystemStoreLocationPara);
+    }
     return ret;
 }
 
@@ -582,6 +585,7 @@
         pvPara = (void *)&cssrp;
     }
     else {
+#ifdef _MSC_VER
         switch ((ULONG_PTR)StoreProvider) {
             case CERT_STORE_PROV_PHYSICAL:
             case CERT_STORE_PROV_FILENAME:
@@ -623,6 +627,41 @@
                 return NULL;
             }
         }
+#else
+        if (StoreProvider == CERT_STORE_PROV_PHYSICAL)
+        if (StoreProvider == CERT_STORE_PROV_FILENAME)
+        if (StoreProvider == CERT_STORE_PROV_SYSTEM)
+        if (StoreProvider == CERT_STORE_PROV_SYSTEM_REGISTRY)
+        if (StoreProvider == CERT_STORE_PROV_LDAP) {
+            if (!PyWinObject_AsWCHAR(obpvPara, (WCHAR **)&pvPara))
+                return NULL;
+            free_wchar = TRUE;
+	}
+        if (StoreProvider == CERT_STORE_PROV_REG) {
+            if (!PyWinObject_AsHKEY(obpvPara, (HKEY *)&pvPara))
+                return NULL;
+	}
+        if (StoreProvider == CERT_STORE_PROV_FILE) {
+            if (!PyWinObject_AsHANDLE(obpvPara, (HANDLE *)&pvPara))
+                return NULL;
+	}
+        if (StoreProvider == CERT_STORE_PROV_SERIALIZED)
+        if (StoreProvider == CERT_STORE_PROV_PKCS7) {
+            if (!pybuf.init(obpvPara))
+                return NULL;
+            crypt_data_blob.pbData = (BYTE*)pybuf.ptr();
+            crypt_data_blob.cbData = pybuf.len();
+            pvPara = (void *)&crypt_data_blob;
+	}
+        if (StoreProvider == CERT_STORE_PROV_MEMORY) {
+            // pvPara is not used, warn if something passed in
+            if (obpvPara != Py_None)
+                PyErr_Warn(PyExc_RuntimeWarning, "Para ignored for CERT_STORE_PROV_MEMORY");
+	}
+
+        PyErr_SetString(PyExc_NotImplementedError, "Specified store provider type not supported");
+        return NULL;
+#endif
     }
 
     Py_BEGIN_ALLOW_THREADS hcertstore = CertOpenStore(StoreProvider, dwEncodingType, hcryptprov, dwFlags, pvPara);
diff -urN pywin32-b304-orig/win32/src/win32dynamicdialog.cpp pywin32-b304/win32/src/win32dynamicdialog.cpp
--- pywin32-b304-orig/win32/src/win32dynamicdialog.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32dynamicdialog.cpp	2022-11-06 01:33:32.436218200 +0800
@@ -31,7 +31,7 @@
 
 #ifdef WIN32GUI  // being compiled from WIN32GUI
 #define PYW_EXPORT
-#include "python.h"
+#include "Python.h"
 #undef PyHANDLE
 #include <windows.h>
 #include "commctrl.h"
@@ -40,8 +40,8 @@
 #ifdef MS_WINCE
 #include "winbase.h"
 #endif
-#include "pywintypes.h"
-#include "pywinobjects.h"
+#include "PyWinTypes.h"
+#include "PyWinObjects.h"
 #include "tchar.h"
 
 #define BASED_CODE
@@ -54,7 +54,7 @@
 #endif
 
 #include "win32dynamicdialog.h"
-static void DwordAlign(PCHAR *ptr)
+void DwordAlign(PCHAR *ptr)
 {
     size_t offset = ((ULONG_PTR)*ptr) & 0x03;
     if (offset > 0) {
@@ -600,7 +600,7 @@
         goto cleanup;
 
     if (IS_INTRESOURCE(wclass))
-        ret = dlg->Add((WORD)wclass, &tpl, caption);
+        ret = dlg->Add((DWORD_PTR)wclass, &tpl, caption);
     else
         ret = dlg->Add(wclass, &tpl, caption, pybuf.len(), (BYTE*)pybuf.ptr());
 
diff -urN pywin32-b304-orig/win32/src/win32event.i pywin32-b304/win32/src/win32event.i
--- pywin32-b304-orig/win32/src/win32event.i	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32event.i	2022-11-06 01:33:32.440218400 +0800
@@ -5,13 +5,14 @@
 
 %{
 //#define UNICODE
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x0501
 %}
 
 %include "typemaps.i"
 %include "pywin32.i"
 
-%typedef void *NULL_ONLY
+%typedef void *NULL_ONLY;
 
 %typemap(python,in) NULL_ONLY {
 	if ($source != Py_None) {
@@ -23,6 +24,7 @@
 
 // only seem able to make this work with an incorrect level of
 // indirection, and fixing it up inline with a temp.
+%typedef PTIMERAPCROUTINE PTIMERAPCROUTINE;
 %typemap(python,in) PTIMERAPCROUTINE *(PTIMERAPCROUTINE temp) {
 	if ($source != Py_None) {
 		PyErr_SetString(PyExc_TypeError, "This param must be None");
@@ -93,7 +95,6 @@
 BOOLAPI CancelWaitableTimer(PyHANDLE handle);
 #endif
 
-#end
 
 // @pyswig <o PyHANDLE>|CreateEvent|Creates a waitable event
 // @rdesc The result is a handle to the created object
@@ -387,7 +388,7 @@
     BOOL bAlertable 	// @pyparm bool|bAlertable||alertable wait flag.
    );
 #endif
-%typedef DWORD DWORD_WAITAPI
+%typedef DWORD DWORD_WAITAPI;
 %typemap(python,except) DWORD_WAITAPI {
       Py_BEGIN_ALLOW_THREADS
       $function
diff -urN pywin32-b304-orig/win32/src/win32evtlog.i pywin32-b304/win32/src/win32evtlog.i
--- pywin32-b304-orig/win32/src/win32evtlog.i	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32evtlog.i	2022-11-06 02:56:24.529104800 +0800
@@ -4,9 +4,18 @@
 // <nl>The Evt* functions are only available on Vista and later.  Attempting to call
 //	them on XP will result in the process exiting, rather than a python exception.
 
+%{
+#ifndef _MSC_VER
+#undef _WIN32_WINNT
+#define _WIN32_WINNT 0x0600 // for EVT_SUBSCRIBE_NOTIFY_ACTION
+#endif
+%}
+
 %include "typemaps.i"
 %include "pywin32.i"
 
+%typedef HANDLE EVT_HANDLE;
+
 %{
 
 #include <structmember.h>
@@ -15,6 +24,11 @@
 #include "PyWinObjects.h"
 #include "WinEvt.h"
 
+#ifndef _MSC_VER
+// http://msdn.microsoft.com/en-us/library/windows/desktop/aa385781%28v=vs.85%29.aspx
+#define EVT_VARIANT_TYPE_ARRAY  128
+#endif
+
 // @object PyEVTLOG_HANDLE|Object representing a handle to the windows event log.
 //   Identical to <o PyHANDLE>, but calls CloseEventLog() on destruction
 class PyEVTLOG_HANDLE: public PyHANDLE
diff -urN pywin32-b304-orig/win32/src/win32file.i pywin32-b304/win32/src/win32file.i
--- pywin32-b304-orig/win32/src/win32file.i	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32file.i	2022-11-06 01:33:32.451219000 +0800
@@ -48,7 +48,7 @@
 
 #include "winsock2.h"
 #include "mswsock.h"
-#include "pywintypes.h"
+#include "PyWinTypes.h"
 #include "winbase.h"
 #include "assert.h"
 #include <stddef.h>
@@ -73,6 +73,9 @@
 %include "typemaps.i"
 %include "pywin32.i"
 
+%typedef DCB DCB;
+%typedef COMMTIMEOUTS COMMTIMEOUTS;
+
 %{
 
 #include "datetime.h" // python's datetime header.
@@ -753,8 +756,8 @@
 		&obHandle, &obCreationTime, &obLastAccessTime, &obLastWriteTime, &UTCTimes))
 		return NULL;
 
-    if (!PyWinObject_AsHANDLE(obHandle, &hHandle))
-        return NULL;
+	if (!PyWinObject_AsHANDLE(obHandle, &hHandle))
+		return NULL;
 	if (obCreationTime != Py_None){
 		if (!PyWinObject_AsFILETIME(obCreationTime, &FileTime))
 			return NULL;
@@ -5391,7 +5394,7 @@
 		return NULL;
 
 	WCHAR *wpathin;
-	if (wpathin=PyUnicode_AsUnicode(obpathin)){
+	if (wpathin==PyUnicode_AsUnicode(obpathin)){
 		if (htrans)
 			CHECK_PFN(GetFullPathNameTransactedW);
 		WCHAR *wpathret=NULL, *wfilepart, *wpathsave=NULL;
@@ -5430,7 +5433,7 @@
 
 	PyErr_Clear();
 	char *cpathin;
-	if (cpathin=PyBytes_AsString(obpathin)){
+	if (cpathin==PyBytes_AsString(obpathin)){
 		if (htrans)
 			CHECK_PFN(GetFullPathNameTransactedA);
 		char *cpathret=NULL, *cfilepart, *cpathsave=NULL;
diff -urN pywin32-b304-orig/win32/src/win32file_comm.cpp pywin32-b304/win32/src/win32file_comm.cpp
--- pywin32-b304-orig/win32/src/win32file_comm.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32file_comm.cpp	2022-11-06 01:33:32.458219400 +0800
@@ -163,7 +163,7 @@
 PyDCB::~PyDCB(void) {}
 
 #define GET_BITFIELD_ENTRY(bitfield_name) \
-    else if (strcmp(name, #bitfield_name) == 0) { return PyLong_FromLong(pydcb->m_DCB.##bitfield_name); }
+    else if (strcmp(name, #bitfield_name) == 0) { return PyLong_FromLong(pydcb->m_DCB.bitfield_name); }
 
 PyObject *PyDCB::getattro(PyObject *self, PyObject *obname)
 {
@@ -194,11 +194,11 @@
 #define SET_BITFIELD_ENTRY(bitfield_name)                                 \
     else if (strcmp(name, #bitfield_name) == 0)                           \
     {                                                                     \
-        if (!PyLong_Check(v)) {                                            \
+        if (!PyLong_Check(v)) {                                           \
             PyErr_Format(PyExc_TypeError, szNeedIntAttr, #bitfield_name); \
             return -1;                                                    \
         }                                                                 \
-        pydcb->m_DCB.##bitfield_name = PyLong_AsLong(v);                   \
+        pydcb->m_DCB.bitfield_name = PyLong_AsLong(v);                    \
         return 0;                                                         \
     }
 
@@ -362,7 +362,7 @@
 
 #undef GET_BITFIELD_ENTRY
 #define GET_BITFIELD_ENTRY(bitfield_name) \
-    else if (strcmp(name, #bitfield_name) == 0) { return PyLong_FromLong(pyCOMSTAT->m_COMSTAT.##bitfield_name); }
+    else if (strcmp(name, #bitfield_name) == 0) { return PyLong_FromLong(pyCOMSTAT->m_COMSTAT.bitfield_name); }
 
 PyObject *PyCOMSTAT::getattro(PyObject *self, PyObject *obname)
 {
@@ -387,11 +387,11 @@
 #define SET_BITFIELD_ENTRY(bitfield_name)                                 \
     else if (strcmp(name, #bitfield_name) == 0)                           \
     {                                                                     \
-        if (!PyLong_Check(v)) {                                            \
+        if (!PyLong_Check(v)) {                                           \
             PyErr_Format(PyExc_TypeError, szNeedIntAttr, #bitfield_name); \
             return -1;                                                    \
         }                                                                 \
-        pyCOMSTAT->m_COMSTAT.##bitfield_name = PyLong_AsLong(v);           \
+        pyCOMSTAT->m_COMSTAT.bitfield_name = PyLong_AsLong(v);            \
         return 0;                                                         \
     }
 
diff -urN pywin32-b304-orig/win32/src/win32gui.i pywin32-b304/win32/src/win32gui.i
--- pywin32-b304-orig/win32/src/win32gui.i	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32gui.i	2022-11-06 02:56:42.089129400 +0800
@@ -14,7 +14,9 @@
 %{
 // #define UNICODE
 // #define _UNICODE // for CRT string functions
+#undef _WIN32_IE
 #define _WIN32_IE 0x0501 // to enable balloon notifications in Shell_NotifyIcon
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x0501
 #ifdef WINXPGUI
 // This changes the entire world for XP!
@@ -25,9 +27,20 @@
 %include "typemaps.i"
 %include "pywintypes.i"
 
+%typedef POINT POINT;
+%typedef RECT RECT;
+%typedef MSG MSG;
+%typedef TRACKMOUSEEVENT TRACKMOUSEEVENT;
+%typedef PAINTSTRUCT PAINTSTRUCT;
+%typedef ICONINFO ICONINFO;
+%typedef LOGFONT LOGFONT;
+%typedef MENUITEMINFO MENUITEMINFO;
+%typedef NOTIFYICONDATA NOTIFYICONDATA;
+%typedef OPENFILENAME OPENFILENAME;
+
 %{
 #undef PyHANDLE
-#include "pywinobjects.h"
+#include "PyWinObjects.h"
 #include "winuser.h"
 #include "commctrl.h"
 #include "windowsx.h" // For edit control hacks.
@@ -373,14 +386,14 @@
 }
 
 %apply COLORREF {long};
-typedef long COLORREF
+typedef long COLORREF;
 
 typedef HANDLE WPARAM;
 typedef HANDLE LPARAM;
 typedef HANDLE LRESULT;
 typedef int UINT;
 
-%typedef void *NULL_ONLY
+%typedef void *NULL_ONLY;
 
 %typemap(python,in) NULL_ONLY {
 	if ($source != Py_None) {
@@ -1766,9 +1779,9 @@
 %native (PyGetBufferAddressAndLen) PyGetBufferAddressAndLen;
 
 
-%typedef TCHAR *STRING_OR_ATOM_CW
-%typedef TCHAR *RESOURCE_ID
-%typedef TCHAR *RESOURCE_ID_NULLOK
+%typedef TCHAR *STRING_OR_ATOM_CW;
+%typedef TCHAR *RESOURCE_ID;
+%typedef TCHAR *RESOURCE_ID_NULLOK;
 
 %typemap(python,arginit) STRING_OR_ATOM_CW, RESOURCE_ID, RESOURCE_ID_NULLOK{
 	$target=NULL;
@@ -1832,12 +1845,12 @@
 		return NULL;
     // not on NT
 	HMODULE hmod = GetModuleHandle(_T("user32"));
-    BOOL (WINAPI *pfnFW)(PFLASHWINFO) = NULL;
-    if (hmod)
-        pfnFW = (BOOL (WINAPI *)(PFLASHWINFO))GetProcAddress(hmod, "FlashWindowEx");
-    if (pfnFW==NULL)
-        return PyErr_Format(PyExc_NotImplementedError,
-                            "FlashWindowsEx is not supported on this version of windows");
+	BOOL (WINAPI *pfnFW)(PFLASHWINFO) = NULL;
+	if (hmod)
+		pfnFW = (BOOL (WINAPI *)(PFLASHWINFO))GetProcAddress(hmod, "FlashWindowEx");
+	if (pfnFW==NULL)
+		return PyErr_Format(PyExc_NotImplementedError,
+			"FlashWindowsEx is not supported on this version of windows");
 	Py_BEGIN_ALLOW_THREADS
 	rc = (*pfnFW)(&f);
 	Py_END_ALLOW_THREADS
@@ -7587,13 +7600,13 @@
 				"structure says it has %d bytes, but %d was provided",
 				(int)struct_bytes, (int)pybuf.len());
 	// @pyseeapi RegisterDeviceNotification
-	HDEVNOTIFY not;
+	HDEVNOTIFY notify;
 	Py_BEGIN_ALLOW_THREADS
-	not = RegisterDeviceNotification(handle, pybuf.ptr(), flags);
+	notify = RegisterDeviceNotification(handle, pybuf.ptr(), flags);
 	Py_END_ALLOW_THREADS
-	if (not == NULL)
+	if (notify == NULL)
 		return PyWin_SetAPIError("RegisterDeviceNotification");
-	return PyWinObject_FromHDEVNOTIFY(not);
+	return PyWinObject_FromHDEVNOTIFY(notify);
 }
 %}
 %native(RegisterDeviceNotification) PyRegisterDeviceNotification;
diff -urN pywin32-b304-orig/win32/src/win32helpmodule.cpp pywin32-b304/win32/src/win32helpmodule.cpp
--- pywin32-b304-orig/win32/src/win32helpmodule.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32helpmodule.cpp	2022-11-06 01:33:32.472220200 +0800
@@ -2546,13 +2546,11 @@
 
 // Module constants:
 #define ADD_CONSTANT(tok)                                \
-    if (rc = PyModule_AddIntConstant(module, #tok, tok)) \
+    if (int rc = PyModule_AddIntConstant(module, #tok, tok)) \
     return rc
 
 int AddConstants(PyObject *module)
 {
-    int rc;
-
 #ifdef _DEBUG
     int debug = 1;
 #else
@@ -3093,7 +3091,7 @@
     // @const win32help|HH_GPROPID_CONTENT_LANGUAGE|long: LandId for desired
     // content.
 
-    return rc;
+    return 0;
 }
 
 /* List of functions exported by this module */
diff -urN pywin32-b304-orig/win32/src/win32inet.i pywin32-b304/win32/src/win32inet.i
--- pywin32-b304-orig/win32/src/win32inet.i	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32inet.i	2022-11-06 01:33:32.477220500 +0800
@@ -14,7 +14,14 @@
 
 %{
 #undef PyHANDLE // undef earlier define, so we are back to the class.
-#include "pywinobjects.h"
+#include "PyWinObjects.h"
+
+#ifndef _MSC_VER
+#define INTERNET_OPTION_HTTP_DECODING		 65
+#define INTERNET_OPTION_CODEPAGE_PATH		100
+#define INTERNET_OPTION_CODEPAGE_EXTRA		101
+#define INTERNET_OPTION_IDN			102
+#endif
 
 void CALLBACK PyHINTERNET_StatusChange(
 	HINTERNET hInternet,
diff -urN pywin32-b304-orig/win32/src/win32inet_winhttp.cpp pywin32-b304/win32/src/win32inet_winhttp.cpp
--- pywin32-b304-orig/win32/src/win32inet_winhttp.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32inet_winhttp.cpp	2022-11-06 01:33:32.482220800 +0800
@@ -6,8 +6,8 @@
 // The intent is to only wrap stuff which isn't otherwise doable from
 // Python, such as the proxy stuff.
 
-#include "pywintypes.h"
-#include "pywinobjects.h"
+#include "PyWinTypes.h"
+#include "PyWinObjects.h"
 #include "winhttp.h"
 
 // @doc
diff -urN pywin32-b304-orig/win32/src/win32lzmodule.cpp pywin32-b304/win32/src/win32lzmodule.cpp
--- pywin32-b304-orig/win32/src/win32lzmodule.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32lzmodule.cpp	2022-11-06 01:33:32.485221000 +0800
@@ -11,7 +11,7 @@
 
 ******************************************************************/
 
-#include "Pywintypes.h"
+#include "PyWinTypes.h"
 #include "lzexpand.h"
 
 static PyObject *obHandleMap = NULL;
diff -urN pywin32-b304-orig/win32/src/win32net/win32netmisc.cpp pywin32-b304/win32/src/win32net/win32netmisc.cpp
--- pywin32-b304-orig/win32/src/win32net/win32netmisc.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32net/win32netmisc.cpp	2022-11-06 01:33:32.489221200 +0800
@@ -1418,7 +1418,8 @@
 
 #if WINVER >= 0x0500
 
-extern "C" NetValidateNamefunc pfnNetValidateName = NULL;
+extern "C" NetValidateNamefunc pfnNetValidateName;
+NetValidateNamefunc pfnNetValidateName = NULL;
 // @pymethod |win32net|NetValidateName|Checks that domain/machine/workgroup name is valid for given context
 // @rdesc Returns none if valid, exception if not
 // @comm If Account and Password aren't passed, current logon credentials are used
@@ -1461,8 +1462,10 @@
     return ret;
 }
 
-extern "C" NetValidatePasswordPolicyfunc pfnNetValidatePasswordPolicy = NULL;
-extern "C" NetValidatePasswordPolicyFreefunc pfnNetValidatePasswordPolicyFree = NULL;
+extern "C" NetValidatePasswordPolicyfunc pfnNetValidatePasswordPolicy;
+NetValidatePasswordPolicyfunc pfnNetValidatePasswordPolicy = NULL;
+extern "C" NetValidatePasswordPolicyFreefunc pfnNetValidatePasswordPolicyFree;
+NetValidatePasswordPolicyFreefunc pfnNetValidatePasswordPolicyFree = NULL;
 
 static void PyObject_CleanupAUTH_INPUT(NET_VALIDATE_AUTHENTICATION_INPUT_ARG *p)
 {
diff -urN pywin32-b304-orig/win32/src/win32pdhmodule.cpp pywin32-b304/win32/src/win32pdhmodule.cpp
--- pywin32-b304-orig/win32/src/win32pdhmodule.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32pdhmodule.cpp	2022-11-06 01:33:32.494221500 +0800
@@ -1003,7 +1003,7 @@
     {                                                             \
         if (i < seqLen) {                                         \
             PyObject *subItem = PyTuple_GET_ITEM(flags_tuple, i); \
-            myCfg.cfg.##r = PyObject_IsTrue(subItem);             \
+            myCfg.cfg.r = PyObject_IsTrue(subItem);               \
         }                                                         \
     }
 
diff -urN pywin32-b304-orig/win32/src/win32print/win32print.cpp pywin32-b304/win32/src/win32print/win32print.cpp
--- pywin32-b304-orig/win32/src/win32print/win32print.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32print/win32print.cpp	2022-11-06 01:33:32.500221800 +0800
@@ -350,6 +350,7 @@
 
     *pbuf = NULL;
     if (level == 0)
+    {
         if (obinfo == Py_None)
             return TRUE;
         else {
@@ -361,6 +362,7 @@
             }
             return TRUE;
         }
+    }
 
     if (!PyDict_Check(obinfo)) {
         PyErr_Format(PyExc_TypeError, "PRINTER_INFO_%d must be a dictionary", level);
@@ -2434,12 +2436,14 @@
     if (PyArg_ParseTuple(args, "OOO:DeletePrinterDriver", &observername, &obenvironment, &obdrivername) &&
         PyWinObject_AsWCHAR(observername, &servername, TRUE) &&
         PyWinObject_AsWCHAR(obenvironment, &environment, TRUE) && PyWinObject_AsWCHAR(obdrivername, &drivername, FALSE))
+    {
         if (DeletePrinterDriverW(servername, environment, drivername)) {
             Py_INCREF(Py_None);
             ret = Py_None;
         }
         else
             PyWin_SetAPIError("DeletePrinterDriver");
+    }
 
     if (servername != NULL)
         PyWinObject_FreeWCHAR(servername);
@@ -2469,12 +2473,14 @@
                          &versionflag) &&
         PyWinObject_AsWCHAR(observername, &servername, TRUE) &&
         PyWinObject_AsWCHAR(obenvironment, &environment, TRUE) && PyWinObject_AsWCHAR(obdrivername, &drivername, FALSE))
+    {
         if ((*pfnDeletePrinterDriverEx)(servername, environment, drivername, deleteflag, versionflag)) {
             Py_INCREF(Py_None);
             ret = Py_None;
         }
         else
             PyWin_SetAPIError("DeletePrinterDriverEx");
+    }
 
     if (servername != NULL)
         PyWinObject_FreeWCHAR(servername);
diff -urN pywin32-b304-orig/win32/src/win32process.i pywin32-b304/win32/src/win32process.i
--- pywin32-b304-orig/win32/src/win32process.i	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32process.i	2022-11-06 01:33:32.505222100 +0800
@@ -1622,6 +1622,7 @@
 	$target = PyWinLong_FromVoidPtr($source);
 }
 
+%typedef ULONG_PTR ULONG_PTR;
 
 // @pyswig long|VirtualAllocEx|
 LONG_VOIDPTR VirtualAllocEx(
diff -urN pywin32-b304-orig/win32/src/win32rasmodule.cpp pywin32-b304/win32/src/win32rasmodule.cpp
--- pywin32-b304-orig/win32/src/win32rasmodule.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32rasmodule.cpp	2022-11-06 01:33:32.510222400 +0800
@@ -15,7 +15,7 @@
 #define WINVER 0x500
 #endif
 
-#include "pywintypes.h"
+#include "PyWinTypes.h"
 #include "ras.h"
 #include "raserror.h"
 
@@ -549,7 +549,7 @@
         pNotification = NULL;
     }
     else if (PyCallable_Check(obCallback)) {
-        pNotification = PyRasDialFunc1;
+        pNotification = (LPVOID)PyRasDialFunc1;
         notType = 1;
     }
     else if (PyLong_Check(obCallback)) {
@@ -785,15 +785,15 @@
 // @pymethod string|win32ras|GetErrorString|Returns an error string for a RAS error code.
 static PyObject *PyRasGetErrorString(PyObject *self, PyObject *args)
 {
+    TCHAR buf[512];
     DWORD error;
-    DWORD rc;
+    DWORD rc = RasGetErrorString(error, buf, sizeof(buf) / sizeof(buf[0]));
     if (!PyArg_ParseTuple(args, "i:GetErrorString",
                           &error))  // @pyparm int|error||The error value being queried.
         return NULL;
 
-    TCHAR buf[512];
     // @pyseeapi RasGetErrorString
-    if (rc = RasGetErrorString(error, buf, sizeof(buf) / sizeof(buf[0])))
+    if (rc)
         return ReturnRasError("RasGetErrorString");
     return PyWinObject_FromTCHAR(buf);
 }
@@ -801,14 +801,14 @@
 // @pymethod |win32ras|HangUp|Terminates a remote access session.
 static PyObject *PyRasHangUp(PyObject *self, PyObject *args)
 {
-    DWORD rc;
     HRASCONN hras;
+    DWORD rc = RasHangUp(hras);
     if (!PyArg_ParseTuple(args, "O&:HangUp", PyWinObject_AsHANDLE,
                           &hras))  // @pyparm int|hras||The handle to the RAS connection to be terminated.
         return NULL;
 
     // @pyseeapi RasHangUp
-    if (rc = RasHangUp(hras))
+    if (rc)
         return ReturnRasError("RasHangup");
     Py_INCREF(Py_None);
     return Py_None;
@@ -821,7 +821,7 @@
     if (!PyArg_ParseTuple(args, "O&:IsHandleValid", PyWinObject_AsHANDLE,
                           &hras))  // @pyparm int|hras||The handle to the RAS connection being checked.
         return NULL;
-    BOOL bRet = (hras >= 0);
+    BOOL bRet = ((INT_PTR)hras >= 0);
     return PyBool_FromLong(bRet);
 }
 
@@ -927,7 +927,7 @@
     {NULL, NULL}};
 
 #define ADD_CONSTANT(tok)                                \
-    if (rc = PyModule_AddIntConstant(module, #tok, tok)) \
+    if (int rc = PyModule_AddIntConstant(module, #tok, tok)) \
     return rc
 #define ADD_ENUM(parta, partb)                                                 \
     if (rc = PyModule_AddIntConstant(module, #parta "_" #partb, parta::partb)) \
@@ -938,7 +938,6 @@
 
 static int AddConstants(PyObject *module)
 {
-    int rc;
     ADD_CONSTANT(RASCS_OpenPort);             // @const win32ras|RASCS_OpenPort|Constant for RAS state.
     ADD_CONSTANT(RASCS_PortOpened);           // @const win32ras|RASCS_PortOpened|Constant for RAS state.
     ADD_CONSTANT(RASCS_ConnectDevice);        // @const win32ras|RASCS_ConnectDevice|Constant for RAS state.
diff -urN pywin32-b304-orig/win32/src/win32security.i pywin32-b304/win32/src/win32security.i
--- pywin32-b304-orig/win32/src/win32security.i	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32security.i	2022-11-06 01:33:32.516222700 +0800
@@ -5,6 +5,7 @@
 %module win32security // An interface to the win32 security API's
 
 %{
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x0600 // Vista!
 %}
 
@@ -76,7 +77,7 @@
 
 typedef PSecurityFunctionTableW (SEC_ENTRY *InitSecurityInterfacefunc)(void);
 static InitSecurityInterfacefunc pfnInitSecurityInterface=NULL;
-extern PSecurityFunctionTableW psecurityfunctiontable=NULL;
+PSecurityFunctionTableW psecurityfunctiontable=NULL;
 
 typedef BOOL (WINAPI *TranslateNamefunc)(LPCTSTR, EXTENDED_NAME_FORMAT, EXTENDED_NAME_FORMAT, LPTSTR, PULONG);
 static TranslateNamefunc pfnTranslateName=NULL;
@@ -89,20 +90,20 @@
 
 
 // function pointers used in win32security_sspi.cpp and win32security_ds.cpp
-extern DsBindfunc pfnDsBind=NULL;
-extern DsUnBindfunc pfnDsUnBind=NULL;
-extern DsGetSpnfunc pfnDsGetSpn=NULL;
-extern DsWriteAccountSpnfunc pfnDsWriteAccountSpn=NULL;
-extern DsFreeSpnArrayfunc pfnDsFreeSpnArray=NULL;
-extern DsGetDcNamefunc pfnDsGetDcName=NULL;
-extern DsCrackNamesfunc pfnDsCrackNames=NULL;
-extern DsListInfoForServerfunc pfnDsListInfoForServer=NULL;
-extern DsListServersForDomainInSitefunc pfnDsListServersForDomainInSite=NULL;
-extern DsListServersInSitefunc pfnDsListServersInSite=NULL;
-extern DsListSitesfunc pfnDsListSites=NULL;
-extern DsListDomainsInSitefunc pfnDsListDomainsInSite=NULL;
-extern DsListRolesfunc pfnDsListRoles=NULL;
-extern DsFreeNameResultfunc pfnDsFreeNameResult=NULL;
+DsBindfunc pfnDsBind=NULL;
+DsUnBindfunc pfnDsUnBind=NULL;
+DsGetSpnfunc pfnDsGetSpn=NULL;
+DsWriteAccountSpnfunc pfnDsWriteAccountSpn=NULL;
+DsFreeSpnArrayfunc pfnDsFreeSpnArray=NULL;
+DsGetDcNamefunc pfnDsGetDcName=NULL;
+DsCrackNamesfunc pfnDsCrackNames=NULL;
+DsListInfoForServerfunc pfnDsListInfoForServer=NULL;
+DsListServersForDomainInSitefunc pfnDsListServersForDomainInSite=NULL;
+DsListServersInSitefunc pfnDsListServersInSite=NULL;
+DsListSitesfunc pfnDsListSites=NULL;
+DsListDomainsInSitefunc pfnDsListDomainsInSite=NULL;
+DsListRolesfunc pfnDsListRoles=NULL;
+DsFreeNameResultfunc pfnDsFreeNameResult=NULL;
 
 static HMODULE advapi32_dll=NULL;
 static HMODULE secur32_dll =NULL;
@@ -114,8 +115,8 @@
 HMODULE loadmodule(WCHAR *dllname)
 {
 	HMODULE hmodule = GetModuleHandle(dllname);
-    if (hmodule==NULL)
-        hmodule = LoadLibrary(dllname);
+	if (hmodule==NULL)
+		hmodule = LoadLibrary(dllname);
 	return hmodule;
 }
 
@@ -3339,12 +3340,14 @@
 	if (PyWinObject_AsHANDLE(obExistingTokenHandle, &ExistingTokenHandle))
 		if (PyWinObject_AsSID_AND_ATTRIBUTESArray(obSidsToDisable, &SidsToDisable, &DisableSidCount))
 			if (PyWinObject_AsSID_AND_ATTRIBUTESArray(obSidsToRestrict, &SidsToRestrict, &RestrictedSidCount))
-				if (PyWinObject_AsLUID_AND_ATTRIBUTESArray(obPrivilegesToDelete, &PrivilegesToDelete, &DeletePrivilegeCount))
+				if (PyWinObject_AsLUID_AND_ATTRIBUTESArray(obPrivilegesToDelete, &PrivilegesToDelete, &DeletePrivilegeCount)){
 					if ((*pfnCreateRestrictedToken)(ExistingTokenHandle,Flags,DisableSidCount,SidsToDisable,
-							DeletePrivilegeCount,PrivilegesToDelete,RestrictedSidCount,SidsToRestrict,&NewTokenHandle))
+							DeletePrivilegeCount,PrivilegesToDelete,RestrictedSidCount,SidsToRestrict,&NewTokenHandle)){
 						ret=PyWinObject_FromHANDLE(NewTokenHandle);
-					else
+					}else{
 						PyWin_SetAPIError("CreateRestrictedToken",GetLastError());
+					}
+				}
 	if (SidsToDisable!=NULL)
 		free(SidsToDisable);
 	if (PrivilegesToDelete!=NULL)
diff -urN pywin32-b304-orig/win32/src/win32service.i pywin32-b304/win32/src/win32service.i
--- pywin32-b304-orig/win32/src/win32service.i	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32service.i	2022-11-06 01:33:32.522223100 +0800
@@ -3,9 +3,18 @@
 %module win32service // An interface to the Windows NT Service API
 
 
+%{
+#ifndef _MSC_VER
+#undef _WIN32_WINNT
+#define _WIN32_WINNT 0x0600 // for SERVICE_*
+#endif
+%}
+
 %include "typemaps.i"
 %include "pywin32.i"
 
+%typedef SERVICE_STATUS SERVICE_STATUS;
+
 %{
 #undef PyHANDLE
 #include "PyWinObjects.h"
@@ -24,6 +33,13 @@
 // according to msdn, 256 is limit for service names and service display names
 #define MAX_SERVICE_NAME_LEN 256   
 
+#ifndef _MSC_VER
+#define SERVICE_ACCEPT_PRESHUTDOWN	0x00000100
+#define SERVICE_CONTROL_PRESHUTDOWN	0x0000000F
+#define SERVICE_SID_TYPE_NONE		0x00000000
+#define SERVICE_SID_TYPE_RESTRICTED	0x00000003
+#define SERVICE_SID_TYPE_UNRESTRICTED	0x00000001
+#endif
 %}
 
 %init %{
diff -urN pywin32-b304-orig/win32/src/win32tsmodule.cpp pywin32-b304/win32/src/win32tsmodule.cpp
--- pywin32-b304-orig/win32/src/win32tsmodule.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32tsmodule.cpp	2022-11-06 01:33:32.529223500 +0800
@@ -1,4 +1,5 @@
 // @doc
+#undef _WIN32_WINNT
 #define _WIN32_WINNT 0x501
 #include "PyWinTypes.h"
 #include "PyWinObjects.h"
@@ -96,6 +97,7 @@
             &WTSConfigClass))  // @pyparm int|ConfigClass||Type of information to be returned, win32ts.WTSUserConfig*
         return NULL;
     if (PyWinObject_AsWCHAR(obServerName, &ServerName, TRUE) && PyWinObject_AsWCHAR(obUserName, &UserName, FALSE))
+    {
         if (!WTSQueryUserConfig(ServerName, UserName, WTSConfigClass, &buf, &bufsize))
             PyWin_SetAPIError("WTSQueryUserConfig");
         else
@@ -137,6 +139,7 @@
                 default:
                     PyErr_SetString(PyExc_NotImplementedError, "Config class not supported yet");
             }
+    }
 
     PyWinObject_FreeWCHAR(ServerName);
     PyWinObject_FreeWCHAR(UserName);
diff -urN pywin32-b304-orig/win32/src/win32wnet/PyNCB.cpp pywin32-b304/win32/src/win32wnet/PyNCB.cpp
--- pywin32-b304-orig/win32/src/win32wnet/PyNCB.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32wnet/PyNCB.cpp	2022-11-06 01:33:32.534223800 +0800
@@ -29,9 +29,9 @@
 
 #endif
 
-#include "Pywintypes.h"
+#include "PyWinTypes.h"
 #include <windows.h>
-#include "python.h"
+#include "Python.h"
 #include "PyNCB.h"
 
 #include <crtdbg.h>
diff -urN pywin32-b304-orig/win32/src/win32wnet/PyNetresource.cpp pywin32-b304/win32/src/win32wnet/PyNetresource.cpp
--- pywin32-b304-orig/win32/src/win32wnet/PyNetresource.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32wnet/PyNetresource.cpp	2022-11-06 01:33:32.537224000 +0800
@@ -30,7 +30,7 @@
 #endif
 
 #include "PyWinTypes.h"
-#include "netres.h"  // C++ header file for NETRESOURCE object
+#include "Netres.h"  // C++ header file for NETRESOURCE object
 
 static PyObject *NETRESOURCE_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
 {
diff -urN pywin32-b304-orig/win32/src/win32wnet/win32wnet.cpp pywin32-b304/win32/src/win32wnet/win32wnet.cpp
--- pywin32-b304-orig/win32/src/win32wnet/win32wnet.cpp	2022-05-02 15:48:48.000000000 +0800
+++ pywin32-b304/win32/src/win32wnet/win32wnet.cpp	2022-11-06 01:33:32.541224200 +0800
@@ -54,8 +54,8 @@
 
 #include "PyWinTypes.h"
 #include "PyWinObjects.h"  // for the PyHANDLE impl.
-#include "netres.h"        // NETRESOURCE Type
-#include "pyncb.h"
+#include "Netres.h"        // NETRESOURCE Type
+#include "PyNCB.h"
 
 /****************************************************************************
         HELPER FUNCTIONS
