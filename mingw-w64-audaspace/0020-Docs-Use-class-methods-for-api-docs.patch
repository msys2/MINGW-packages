From a0c37b2ce1af7f6662441a71634e7a4c7c355d19 Mon Sep 17 00:00:00 2001
From: Aaron Carlisle <carlisle.b3d@gmail.com>
Date: Sun, 29 Mar 2020 18:43:19 -0400
Subject: [PATCH 20/35] Docs: Use class methods for api docs

This commit also includes some cleanup and spelling
---
 bindings/python/PyDevice.cpp          |  50 +-
 bindings/python/PyDynamicMusic.cpp    |  58 +--
 bindings/python/PyHRTF.cpp            |  52 +-
 bindings/python/PyHandle.cpp          |  28 +-
 bindings/python/PyPlaybackManager.cpp |  97 ++--
 bindings/python/PySequence.cpp        |  54 +--
 bindings/python/PySequenceEntry.cpp   |  36 +-
 bindings/python/PySound.cpp           | 659 +++++++++++++-------------
 8 files changed, 523 insertions(+), 511 deletions(-)

diff --git a/bindings/python/PyDevice.cpp b/bindings/python/PyDevice.cpp
index a6beef5..3dedc8d 100644
--- a/bindings/python/PyDevice.cpp
+++ b/bindings/python/PyDevice.cpp
@@ -124,15 +124,17 @@ Device_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
 }
 
 PyDoc_STRVAR(M_aud_Device_lock_doc,
-			 "lock()\n\n"
-			 "Locks the device so that it's guaranteed, that no samples are "
-			 "read from the streams until :meth:`unlock` is called.\n"
-			 "This is useful if you want to do start/stop/pause/resume some "
-			 "sounds at the same time.\n\n"
-			 ".. note:: The device has to be unlocked as often as locked to be "
-			 "able to continue playback.\n\n"
-			 ".. warning:: Make sure the time between locking and unlocking is "
-			 "as short as possible to avoid clicks.");
+			 ".. classmethod:: lock()\n\n"
+			 "   Locks the device so that it's guaranteed, that no samples are\n"
+			 "   read from the streams until :meth:`unlock` is called.\n"
+			 "   This is useful if you want to do start/stop/pause/resume some\n"
+			 "   sounds at the same time.\n\n"
+			 "   .. note::\n\n"
+			 "      The device has to be unlocked as often as locked to be\n"
+			 "      able to continue playback.\n\n"
+			 "   .. warning::\n\n"
+			 "      Make sure the time between locking and unlocking is\n"
+			 "      as short as possible to avoid clicks.");
 
 static PyObject *
 Device_lock(Device* self)
@@ -150,15 +152,15 @@ Device_lock(Device* self)
 }
 
 PyDoc_STRVAR(M_aud_Device_play_doc,
-			 "play(sound, keep=False)\n\n"
-			 "Plays a sound.\n\n"
-			 ":arg sound: The sound to play.\n"
-			 ":type sound: :class:`Sound`\n"
-			 ":arg keep: See :attr:`Handle.keep`.\n"
-			 ":type keep: bool\n"
-			 ":return: The playback handle with which playback can be "
-			 "controlled with.\n"
-			 ":rtype: :class:`Handle`");
+			 ".. classmethod:: play(sound, keep=False)\n\n"
+			 "   Plays a sound.\n\n"
+			 "   :arg sound: The sound to play.\n"
+			 "   :type sound: :class:`Sound`\n"
+			 "   :arg keep: See :attr:`Handle.keep`.\n"
+			 "   :type keep: bool\n"
+			 "   :return: The playback handle with which playback can be\n"
+			 "      controlled with.\n"
+			 "   :rtype: :class:`Handle`");
 
 static PyObject *
 Device_play(Device* self, PyObject* args, PyObject* kwds)
@@ -210,8 +212,8 @@ Device_play(Device* self, PyObject* args, PyObject* kwds)
 }
 
 PyDoc_STRVAR(M_aud_Device_stopAll_doc,
-			 "stopAll()\n\n"
-			 "Stops all playing and paused sounds.");
+			 ".. classmethod:: stopAll()\n\n"
+			 "   Stops all playing and paused sounds.");
 
 static PyObject *
 Device_stopAll(Device* self)
@@ -229,9 +231,9 @@ Device_stopAll(Device* self)
 }
 
 PyDoc_STRVAR(M_aud_Device_unlock_doc,
-			 "unlock()\n\n"
-			 "Unlocks the device after a lock call, see :meth:`lock` for "
-			 "details.");
+			 ".. classmethod:: unlock()\n\n"
+			 "   Unlocks the device after a lock call, see :meth:`lock` for\n"
+			 "   details.");
 
 static PyObject *
 Device_unlock(Device* self)
@@ -284,7 +286,7 @@ Device_get_channels(Device* self, void* nothing)
 
 PyDoc_STRVAR(M_aud_Device_distance_model_doc,
 			 "The distance model of the device.\n\n"
-			 ".. seealso:: http://connect.creativelabs.com/openal/Documentation/OpenAL%201.1%20Specification.htm#_Toc199835864");
+			 ".. seealso:: `OpenAL Documentation <https://www.openal.org/documentation/>`__");
 
 static PyObject *
 Device_get_distance_model(Device* self, void* nothing)
diff --git a/bindings/python/PyDynamicMusic.cpp b/bindings/python/PyDynamicMusic.cpp
index d49f737..cab8563 100644
--- a/bindings/python/PyDynamicMusic.cpp
+++ b/bindings/python/PyDynamicMusic.cpp
@@ -60,12 +60,12 @@ DynamicMusic_dealloc(DynamicMusicP* self)
 }
 
 PyDoc_STRVAR(M_aud_DynamicMusic_addScene_doc,
-	"addScene(scene)\n\n"
-	"Adds a new scene.\n\n"
-	":arg scene: The scene sound.\n"
-	":type scene: :class:`Sound`\n"
-	":return: The new scene id.\n"
-	":rtype: int");
+	".. classmethod:: addScene(scene)\n\n"
+	"   Adds a new scene.\n\n"
+	"   :arg scene: The scene sound.\n"
+	"   :type scene: :class:`Sound`\n"
+	"   :return: The new scene id.\n"
+	"   :rtype: int");
 
 static PyObject *
 DynamicMusic_addScene(DynamicMusicP* self, PyObject* args)
@@ -90,16 +90,16 @@ DynamicMusic_addScene(DynamicMusicP* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_DynamicMusic_addTransition_doc,
-	"addTransition(ini, end, transition)\n\n"
-	"Adds a new scene.\n\n"
-	":arg ini: the initial scene foor the transition.\n"
-	":type ini: int\n"
-	":arg end: The final scene for the transition.\n"
-	":type end: int\n"
-	":arg transition: The transition sound.\n"
-	":type transition: :class:`Sound`\n"
-	":return: false if the ini or end scenes don't exist, true othrwise.\n"
-	":rtype: bool");
+	".. classmethod:: addTransition(ini, end, transition)\n\n"
+	"   Adds a new scene.\n\n"
+	"   :arg ini: the initial scene foor the transition.\n"
+	"   :type ini: int\n"
+	"   :arg end: The final scene for the transition.\n"
+	"   :type end: int\n"
+	"   :arg transition: The transition sound.\n"
+	"   :type transition: :class:`Sound`\n"
+	"   :return: false if the ini or end scenes don't exist, true othrwise.\n"
+	"   :rtype: bool");
 
 static PyObject *
 DynamicMusic_addTransition(DynamicMusicP* self, PyObject* args)
@@ -125,10 +125,10 @@ DynamicMusic_addTransition(DynamicMusicP* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_DynamicMusic_resume_doc,
-	"resume()\n\n"
-	"Resumes playback of the scene.\n\n"
-	":return: Whether the action succeeded.\n"
-	":rtype: bool");
+	".. classmethod:: resume()\n\n"
+	"   Resumes playback of the scene.\n\n"
+	"   :return: Whether the action succeeded.\n"
+	"   :rtype: bool");
 
 static PyObject *
 DynamicMusic_resume(DynamicMusicP* self)
@@ -145,10 +145,10 @@ DynamicMusic_resume(DynamicMusicP* self)
 }
 
 PyDoc_STRVAR(M_aud_DynamicMusic_pause_doc,
-	"pause()\n\n"
-	"Pauses playback of the scene.\n\n"
-	":return: Whether the action succeeded.\n"
-	":rtype: bool");
+	".. classmethod:: pause()\n\n"
+	"   Pauses playback of the scene.\n\n"
+	"   :return: Whether the action succeeded.\n"
+	"   :rtype: bool");
 
 static PyObject *
 DynamicMusic_pause(DynamicMusicP* self)
@@ -165,10 +165,10 @@ DynamicMusic_pause(DynamicMusicP* self)
 }
 
 PyDoc_STRVAR(M_aud_DynamicMusic_stop_doc,
-	"stop()\n\n"
-	"Stops playback of the scene.\n\n"
-	":return: Whether the action succeeded.\n"
-	":rtype: bool\n\n");
+	".. classmethod:: stop()\n\n"
+	"   Stops playback of the scene.\n\n"
+	"   :return: Whether the action succeeded.\n"
+	"   :rtype: bool\n\n");
 
 static PyObject *
 DynamicMusic_stop(DynamicMusicP* self)
@@ -464,4 +464,4 @@ void addDynamicMusicToModule(PyObject* module)
 {
 	Py_INCREF(&DynamicMusicType);
 	PyModule_AddObject(module, "DynamicMusic", (PyObject *)&DynamicMusicType);
-}
\ No newline at end of file
+}
diff --git a/bindings/python/PyHRTF.cpp b/bindings/python/PyHRTF.cpp
index 2a5b6be..c209a88 100644
--- a/bindings/python/PyHRTF.cpp
+++ b/bindings/python/PyHRTF.cpp
@@ -54,16 +54,16 @@ HRTF_dealloc(HRTFP* self)
 }
 
 PyDoc_STRVAR(M_aud_HRTF_addImpulseResponse_doc,
-	"addImpulseResponseFromSound(sound, azimuth, elevation)\n\n"
-	"Adds a new hrtf to the HRTF object\n\n"
-	":arg sound: The sound that contains the hrtf.\n"
-	":type sound: :class:`Sound`\n"
-	":arg azimuth: The azimuth angle of the hrtf.\n"
-	":type azimuth: float\n"
-	":arg elevation: The elevation angle of the hrtf.\n"
-	":type elevation: float\n"
-	":return: Whether the action succeeded.\n"
-	":rtype: bool");
+	".. classmethod:: addImpulseResponseFromSound(sound, azimuth, elevation)\n\n"
+	"   Adds a new hrtf to the HRTF object\n\n"
+	"   :arg sound: The sound that contains the hrtf.\n"
+	"   :type sound: :class:`Sound`\n"
+	"   :arg azimuth: The azimuth angle of the hrtf.\n"
+	"   :type azimuth: float\n"
+	"   :arg elevation: The elevation angle of the hrtf.\n"
+	"   :type elevation: float\n"
+	"   :return: Whether the action succeeded.\n"
+	"   :rtype: bool");
 
 static PyObject *
 HRTF_addImpulseResponseFromSound(HRTFP* self, PyObject* args)
@@ -90,14 +90,14 @@ HRTF_addImpulseResponseFromSound(HRTFP* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_HRTF_loadLeftHrtfSet_doc,
-	"loadLeftHrtfSet(extension, directory)\n\n"
-	"Loads all HRTFs from a directory.\n\n"
-	":arg extension: The file extension of the hrtfs.\n"
-	":type extension: string\n"
-	":arg directory: The path to where the HRTF files are located.\n"
-	":type extension: string\n"
-	":return: The loaded :class:`HRTF` object.\n"
-	":rtype: :class:`HRTF`\n\n");
+	".. classmethod:: loadLeftHrtfSet(extension, directory)\n\n"
+	"   Loads all HRTFs from a directory.\n\n"
+	"   :arg extension: The file extension of the hrtfs.\n"
+	"   :type extension: string\n"
+	"   :arg directory: The path to where the HRTF files are located.\n"
+	"   :type extension: string\n"
+	"   :return: The loaded :class:`HRTF` object.\n"
+	"   :rtype: :class:`HRTF`\n\n");
 
 static PyObject *
 HRTF_loadLeftHrtfSet(PyTypeObject* type, PyObject* args)
@@ -125,14 +125,14 @@ HRTF_loadLeftHrtfSet(PyTypeObject* type, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_HRTF_loadRightHrtfSet_doc,
-	"loadLeftHrtfSet(extension, directory)\n\n"
-	"Loads all HRTFs from a directory.\n\n"
-	":arg extension: The file extension of the hrtfs.\n"
-	":type extension: string\n"
-	":arg directory: The path to where the HRTF files are located.\n"
-	":type extension: string\n"
-	":return: The loaded :class:`HRTF` object.\n"
-	":rtype: :class:`HRTF`\n\n");
+	".. classmethod:: loadLeftHrtfSet(extension, directory)\n\n"
+	"   Loads all HRTFs from a directory.\n\n"
+	"   :arg extension: The file extension of the hrtfs.\n"
+	"   :type extension: string\n"
+	"   :arg directory: The path to where the HRTF files are located.\n"
+	"   :type extension: string\n"
+	"   :return: The loaded :class:`HRTF` object.\n"
+	"   :rtype: :class:`HRTF`\n\n");
 
 static PyObject *
 HRTF_loadRightHrtfSet(PyTypeObject* type, PyObject* args)
diff --git a/bindings/python/PyHandle.cpp b/bindings/python/PyHandle.cpp
index 7f7a766..828c1b1 100644
--- a/bindings/python/PyHandle.cpp
+++ b/bindings/python/PyHandle.cpp
@@ -38,10 +38,10 @@ Handle_dealloc(Handle* self)
 }
 
 PyDoc_STRVAR(M_aud_Handle_pause_doc,
-			 "pause()\n\n"
-			 "Pauses playback.\n\n"
-			 ":return: Whether the action succeeded.\n"
-			 ":rtype: bool");
+			 ".. classmethod:: pause()\n\n"
+			 "   Pauses playback.\n\n"
+			 "   :return: Whether the action succeeded.\n"
+			 "   :rtype: bool");
 
 static PyObject *
 Handle_pause(Handle* self)
@@ -58,10 +58,10 @@ Handle_pause(Handle* self)
 }
 
 PyDoc_STRVAR(M_aud_Handle_resume_doc,
-			 "resume()\n\n"
-			 "Resumes playback.\n\n"
-			 ":return: Whether the action succeeded.\n"
-			 ":rtype: bool");
+			 ".. classmethod:: resume()\n\n"
+			 "   Resumes playback.\n\n"
+			 "   :return: Whether the action succeeded.\n"
+			 "   :rtype: bool");
 
 static PyObject *
 Handle_resume(Handle* self)
@@ -78,11 +78,11 @@ Handle_resume(Handle* self)
 }
 
 PyDoc_STRVAR(M_aud_Handle_stop_doc,
-			 "stop()\n\n"
-			 "Stops playback.\n\n"
-			 ":return: Whether the action succeeded.\n"
-			 ":rtype: bool\n\n"
-			 ".. note:: This makes the handle invalid.");
+			 ".. classmethod:: stop()\n\n"
+			 "   Stops playback.\n\n"
+			 "   :return: Whether the action succeeded.\n"
+			 "   :rtype: bool\n\n"
+			 "   .. note:: This makes the handle invalid.");
 
 static PyObject *
 Handle_stop(Handle* self)
@@ -1122,5 +1122,3 @@ void addHandleToModule(PyObject* module)
 	Py_INCREF(&HandleType);
 	PyModule_AddObject(module, "Handle", (PyObject *)&HandleType);
 }
-
-
diff --git a/bindings/python/PyPlaybackManager.cpp b/bindings/python/PyPlaybackManager.cpp
index 9b6614c..3987ac5 100644
--- a/bindings/python/PyPlaybackManager.cpp
+++ b/bindings/python/PyPlaybackManager.cpp
@@ -60,14 +60,15 @@ PlaybackManager_dealloc(PlaybackManagerP* self)
 }
 
 PyDoc_STRVAR(M_aud_PlaybackManager_play_doc,
-	"setVolume(sound, catKey)\n\n"
-	"Plays a sound through the playback manager and assigns it to a category.\n\n"
-	":arg sound: The sound to play.\n"
-	":type sound: :class:`Sound`\n"
-	":arg catKey: the key of the category in which the sound will be added, if it doesn't exist, a new one will be created.\n"
-	":type catKey: int\n"
-	":return: The playback handle with which playback can be controlled with.\n"
-	":rtype: :class:`Handle`");
+	".. classmethod:: setVolume(sound, catKey)\n\n"
+	"   Plays a sound through the playback manager and assigns it to a category.\n\n"
+	"   :arg sound: The sound to play.\n"
+	"   :type sound: :class:`Sound`\n"
+	"   :arg catKey: the key of the category in which the sound will be added,\n"
+	"      if it doesn't exist, a new one will be created.\n"
+	"   :type catKey: int\n"
+	"   :return: The playback handle with which playback can be controlled with.\n"
+	"   :rtype: :class:`Handle`");
 
 static PyObject *
 PlaybackManager_play(PlaybackManagerP* self, PyObject* args)
@@ -103,12 +104,12 @@ PlaybackManager_play(PlaybackManagerP* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_PlaybackManager_resume_doc,
-	"resume(catKey)\n\n"
-	"Resumes playback of the catgory.\n\n"
-	":arg catKey: the key of the category.\n"
-	":type catKey: int\n"
-	":return: Whether the action succeeded.\n"
-	":rtype: bool");
+	".. classmethod:: resume(catKey)\n\n"
+	"   Resumes playback of the catgory.\n\n"
+	"   :arg catKey: the key of the category.\n"
+	"   :type catKey: int\n"
+	"   :return: Whether the action succeeded.\n"
+	"   :rtype: bool");
 
 static PyObject *
 PlaybackManager_resume(PlaybackManagerP* self, PyObject* args)
@@ -130,12 +131,12 @@ PlaybackManager_resume(PlaybackManagerP* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_PlaybackManager_pause_doc,
-	"pause(catKey)\n\n"
-	"Pauses playback of the category.\n\n"
-	":arg catKey: the key of the category.\n"
-	":type catKey: int\n"
-	":return: Whether the action succeeded.\n"
-	":rtype: bool");
+	".. classmethod:: pause(catKey)\n\n"
+	"   Pauses playback of the category.\n\n"
+	"   :arg catKey: the key of the category.\n"
+	"   :type catKey: int\n"
+	"   :return: Whether the action succeeded.\n"
+	"   :rtype: bool");
 
 static PyObject *
 PlaybackManager_pause(PlaybackManagerP* self, PyObject* args)
@@ -157,12 +158,12 @@ PlaybackManager_pause(PlaybackManagerP* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_PlaybackManager_add_category_doc,
-	"addCategory(volume)\n\n"
-	"Adds a category with a custom volume.\n\n"
-	":arg volume: The volume for ther new category.\n"
-	":type volume: float\n"
-	":return: The key of the new category.\n"
-	":rtype: int\n\n");
+	".. classmethod:: addCategory(volume)\n\n"
+	"   Adds a category with a custom volume.\n\n"
+	"   :arg volume: The volume for ther new category.\n"
+	"   :type volume: float\n"
+	"   :return: The key of the new category.\n"
+	"   :rtype: int\n\n");
 
 static PyObject *
 PlaybackManager_add_category(PlaybackManagerP* self, PyObject* args)
@@ -184,12 +185,12 @@ PlaybackManager_add_category(PlaybackManagerP* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_PlaybackManager_get_volume_doc,
-	"getVolume(catKey)\n\n"
-	"Retrieves the volume of a category.\n\n"
-	":arg catKey: the key of the category.\n"
-	":type catKey: int\n"
-	":return: The volume of the cateogry.\n"
-	":rtype: float\n\n");
+	".. classmethod:: getVolume(catKey)\n\n"
+	"   Retrieves the volume of a category.\n\n"
+	"   :arg catKey: the key of the category.\n"
+	"   :type catKey: int\n"
+	"   :return: The volume of the cateogry.\n"
+	"   :rtype: float\n\n");
 
 static PyObject *
 PlaybackManager_get_volume(PlaybackManagerP* self, PyObject* args)
@@ -211,14 +212,14 @@ PlaybackManager_get_volume(PlaybackManagerP* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_PlaybackManager_set_volume_doc,
-	"setVolume(volume, catKey)\n\n"
-	"Changes the volume of a category.\n\n"
-	":arg volume: the new volume value.\n"
-	":type volume: float\n"
-	":arg catKey: the key of the category.\n"
-	":type catKey: int\n"
-	":return: Whether the action succeeded.\n"
-	":rtype: int\n\n");
+	".. classmethod:: setVolume(volume, catKey)\n\n"
+	"   Changes the volume of a category.\n\n"
+	"   :arg volume: the new volume value.\n"
+	"   :type volume: float\n"
+	"   :arg catKey: the key of the category.\n"
+	"   :type catKey: int\n"
+	"   :return: Whether the action succeeded.\n"
+	"   :rtype: int\n\n");
 
 static PyObject *
 PlaybackManager_set_volume(PlaybackManagerP* self, PyObject* args)
@@ -241,12 +242,12 @@ PlaybackManager_set_volume(PlaybackManagerP* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_PlaybackManager_stop_doc,
-	"stop(catKey)\n\n"
-	"Stops playback of the category.\n\n"
-	":arg catKey: the key of the category.\n"
-	":type catKey: int\n"
-	":return: Whether the action succeeded.\n"
-	":rtype: bool\n\n");
+	".. classmethod:: stop(catKey)\n\n"
+	"   Stops playback of the category.\n\n"
+	"   :arg catKey: the key of the category.\n"
+	"   :type catKey: int\n"
+	"   :return: Whether the action succeeded.\n"
+	"   :rtype: bool\n\n");
 
 static PyObject *
 PlaybackManager_stop(PlaybackManagerP* self, PyObject* args)
@@ -268,8 +269,8 @@ PlaybackManager_stop(PlaybackManagerP* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_PlaybackManager_clean_doc,
-	"clean()\n\n"
-	"Cleans all the invalid and finished sound from the playback manager.\n\n");
+	".. classmethod:: clean()\n\n"
+	"   Cleans all the invalid and finished sound from the playback manager.\n\n");
 
 static PyObject *
 PlaybackManager_clean(PlaybackManagerP* self)
diff --git a/bindings/python/PySequence.cpp b/bindings/python/PySequence.cpp
index e574d76..2e08059 100644
--- a/bindings/python/PySequence.cpp
+++ b/bindings/python/PySequence.cpp
@@ -99,18 +99,18 @@ Sequence_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
 }
 
 PyDoc_STRVAR(M_aud_Sequence_add_doc,
-			 "add()\n\n"
-			 "Adds a new entry to the sequence.\n\n"
-			 ":arg sound: The sound this entry should play.\n"
-			 ":type sound: :class:`Sound`\n"
-			 ":arg begin: The start time.\n"
-			 ":type begin: float\n"
-			 ":arg end: The end time or a negative value if determined by the sound.\n"
-			 ":type end: float\n"
-			 ":arg skip: How much seconds should be skipped at the beginning.\n"
-			 ":type skip: float\n"
-			 ":return: The entry added.\n"
-			 ":rtype: :class:`SequenceEntry`");
+			 ".. classmethod:: add()\n\n"
+			 "   Adds a new entry to the sequence.\n\n"
+			 "   :arg sound: The sound this entry should play.\n"
+			 "   :type sound: :class:`Sound`\n"
+			 "   :arg begin: The start time.\n"
+			 "   :type begin: float\n"
+			 "   :arg end: The end time or a negative value if determined by the sound.\n"
+			 "   :type end: float\n"
+			 "   :arg skip: How much seconds should be skipped at the beginning.\n"
+			 "   :type skip: float\n"
+			 "   :return: The entry added.\n"
+			 "   :rtype: :class:`SequenceEntry`");
 
 static PyObject *
 Sequence_add(Sequence* self, PyObject* args, PyObject* kwds)
@@ -151,10 +151,10 @@ Sequence_add(Sequence* self, PyObject* args, PyObject* kwds)
 }
 
 PyDoc_STRVAR(M_aud_Sequence_remove_doc,
-			 "remove()\n\n"
-			 "Removes an entry from the sequence.\n\n"
-			 ":arg entry: The entry to remove.\n"
-			 ":type entry: :class:`SequenceEntry`\n");
+			 ".. classmethod:: remove()\n\n"
+			 "   Removes an entry from the sequence.\n\n"
+			 "   :arg entry: The entry to remove.\n"
+			 "   :type entry: :class:`SequenceEntry`\n");
 
 static PyObject *
 Sequence_remove(Sequence* self, PyObject* args)
@@ -183,16 +183,16 @@ Sequence_remove(Sequence* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sequence_setAnimationData_doc,
-			 "setAnimationData()\n\n"
-			 "Writes animation data to a sequence.\n\n"
-			 ":arg type: The type of animation data.\n"
-			 ":type type: int\n"
-			 ":arg frame: The frame this data is for.\n"
-			 ":type frame: int\n"
-			 ":arg data: The data to write.\n"
-			 ":type data: sequence of float\n"
-			 ":arg animated: Whether the attribute is animated.\n"
-			 ":type animated: bool");
+			 ".. classmethod:: setAnimationData()\n\n"
+			 "   Writes animation data to a sequence.\n\n"
+			 "   :arg type: The type of animation data.\n"
+			 "   :type type: int\n"
+			 "   :arg frame: The frame this data is for.\n"
+			 "   :type frame: int\n"
+			 "   :arg data: The data to write.\n"
+			 "   :type data: sequence of float\n"
+			 "   :arg animated: Whether the attribute is animated.\n"
+			 "   :type animated: bool");
 
 static PyObject *
 Sequence_setAnimationData(Sequence* self, PyObject* args)
@@ -325,7 +325,7 @@ Sequence_set_channels(Sequence* self, PyObject* args, void* nothing)
 
 PyDoc_STRVAR(M_aud_Sequence_distance_model_doc,
 			 "The distance model of the sequence.\n\n"
-			 ".. seealso:: http://connect.creativelabs.com/openal/Documentation/OpenAL%201.1%20Specification.htm#_Toc199835864");
+			  ".. seealso:: `OpenAL Documentation <https://www.openal.org/documentation/>`__");
 
 static PyObject *
 Sequence_get_distance_model(Sequence* self, void* nothing)
diff --git a/bindings/python/PySequenceEntry.cpp b/bindings/python/PySequenceEntry.cpp
index e6a034e..a1bf3db 100644
--- a/bindings/python/PySequenceEntry.cpp
+++ b/bindings/python/PySequenceEntry.cpp
@@ -43,14 +43,14 @@ SequenceEntry_dealloc(SequenceEntry* self)
 }
 
 PyDoc_STRVAR(M_aud_SequenceEntry_move_doc,
-			 "move()\n\n"
-			 "Moves the entry.\n\n"
-			 ":arg begin: The new start time.\n"
-			 ":type begin: float\n"
-			 ":arg end: The new end time or a negative value if unknown.\n"
-			 ":type end: float\n"
-			 ":arg skip: How many seconds to skip at the beginning.\n"
-			 ":type skip: float\n");
+			 ".. classmethod:: move()\n\n"
+			 "   Moves the entry.\n\n"
+			 "   :arg begin: The new start time.\n"
+			 "   :type begin: float\n"
+			 "   :arg end: The new end time or a negative value if unknown.\n"
+			 "   :type end: float\n"
+			 "   :arg skip: How many seconds to skip at the beginning.\n"
+			 "   :type skip: float\n");
 
 static PyObject *
 SequenceEntry_move(SequenceEntry* self, PyObject* args)
@@ -73,16 +73,16 @@ SequenceEntry_move(SequenceEntry* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_SequenceEntry_setAnimationData_doc,
-			 "setAnimationData()\n\n"
-			 "Writes animation data to a sequenced entry.\n\n"
-			 ":arg type: The type of animation data.\n"
-			 ":type type: int\n"
-			 ":arg frame: The frame this data is for.\n"
-			 ":type frame: int\n"
-			 ":arg data: The data to write.\n"
-			 ":type data: sequence of float\n"
-			 ":arg animated: Whether the attribute is animated.\n"
-			 ":type animated: bool");
+			 ".. classmethod:: setAnimationData()\n\n"
+			 "   Writes animation data to a sequenced entry.\n\n"
+			 "   :arg type: The type of animation data.\n"
+			 "   :type type: int\n"
+			 "   :arg frame: The frame this data is for.\n"
+			 "   :type frame: int\n"
+			 "   :arg data: The data to write.\n"
+			 "   :type data: sequence of float\n"
+			 "   :arg animated: Whether the attribute is animated.\n"
+			 "   :type animated: bool");
 
 static PyObject *
 SequenceEntry_setAnimationData(SequenceEntry* self, PyObject* args)
diff --git a/bindings/python/PySound.cpp b/bindings/python/PySound.cpp
index c589e71..c37e3f7 100644
--- a/bindings/python/PySound.cpp
+++ b/bindings/python/PySound.cpp
@@ -114,11 +114,11 @@ Sound_new(PyTypeObject* type, PyObject* args, PyObject* kwds)
 }
 
 PyDoc_STRVAR(M_aud_Sound_data_doc,
-			 "data()\n\n"
-			 "Retrieves the data of the sound as numpy array.\n\n"
-			 ":return: A two dimensional numpy float array.\n"
-			 ":rtype: :class:`numpy.ndarray`\n\n"
-			 ".. note:: Best efficiency with cached sounds.");
+			 ".. classmethod:: data()\n\n"
+			 "   Retrieves the data of the sound as numpy array.\n\n"
+			 "   :return: A two dimensional numpy float array.\n"
+			 "   :rtype: :class:`numpy.ndarray`\n\n"
+			 "   .. note:: Best efficiency with cached sounds.");
 
 static PyObject *
 Sound_data(Sound* self)
@@ -145,24 +145,24 @@ Sound_data(Sound* self)
 }
 
 PyDoc_STRVAR(M_aud_Sound_write_doc,
-			 "write(filename, rate, channels, format, container, codec, bitrate, buffersize)\n\n"
-			 "Writes the sound to a file.\n\n"
-			 ":arg filename: The path to write to.\n"
-			 ":type filename: string\n"
-			 ":arg rate: The sample rate to write with.\n"
-			 ":type rate: int\n"
-			 ":arg channels: The number of channels to write with.\n"
-			 ":type channels: int\n"
-			 ":arg format: The sample format to write with.\n"
-			 ":type format: int\n"
-			 ":arg container: The container format for the file.\n"
-			 ":type container: int\n"
-			 ":arg codec: The codec to use in the file.\n"
-			 ":type codec: int\n"
-			 ":arg bitrate: The bitrate to write with.\n"
-			 ":type bitrate: int\n"
-			 ":arg buffersize: The size of the writing buffer.\n"
-			 ":type buffersize: int\n");
+			 ".. classmethod:: write(filename, rate, channels, format, container, codec, bitrate, buffersize)\n\n"
+			 "   Writes the sound to a file.\n\n"
+			 "   :arg filename: The path to write to.\n"
+			 "   :type filename: string\n"
+			 "   :arg rate: The sample rate to write with.\n"
+			 "   :type rate: int\n"
+			 "   :arg channels: The number of channels to write with.\n"
+			 "   :type channels: int\n"
+			 "   :arg format: The sample format to write with.\n"
+			 "   :type format: int\n"
+			 "   :arg container: The container format for the file.\n"
+			 "   :type container: int\n"
+			 "   :arg codec: The codec to use in the file.\n"
+			 "   :type codec: int\n"
+			 "   :arg bitrate: The bitrate to write with.\n"
+			 "   :type bitrate: int\n"
+			 "   :arg buffersize: The size of the writing buffer.\n"
+			 "   :type buffersize: int");
 
 static PyObject *
 Sound_write(Sound* self, PyObject* args, PyObject* kwds)
@@ -286,14 +286,14 @@ Sound_write(Sound* self, PyObject* args, PyObject* kwds)
 }
 
 PyDoc_STRVAR(M_aud_Sound_buffer_doc,
-			 "buffer(data, rate)\n\n"
-			 "Creates a sound from a data buffer.\n\n"
-			 ":arg data: The data as two dimensional numpy array.\n"
-			 ":type data: numpy.ndarray\n"
-			 ":arg rate: The sample rate.\n"
-			 ":type rate: double\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: buffer(data, rate)\n\n"
+			 "   Creates a sound from a data buffer.\n\n"
+			 "   :arg data: The data as two dimensional numpy array.\n"
+			 "   :type data: numpy.ndarray\n"
+			 "   :arg rate: The sample rate.\n"
+			 "   :type rate: double\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_buffer(PyTypeObject* type, PyObject* args)
@@ -356,16 +356,17 @@ Sound_buffer(PyTypeObject* type, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_cache_doc,
-			 "cache()\n\n"
-			 "Caches a sound into RAM.\n"
-			 "This saves CPU usage needed for decoding and file access if the "
-			 "underlying sound reads from a file on the harddisk, but it "
-			 "consumes a lot of memory.\n\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`\n\n"
-			 ".. note:: Only known-length factories can be buffered.\n\n"
-			 ".. warning:: Raw PCM data needs a lot of space, only buffer "
-			 "short factories.");
+			 ".. classmethod:: cache()\n\n"
+			 "   Caches a sound into RAM.\n\n"
+			 "   This saves CPU usage needed for decoding and file access if the\n"
+			 "   underlying sound reads from a file on the harddisk,\n"
+			 "   but it consumes a lot of memory.\n\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`\n\n"
+			 "   .. note:: Only known-length factories can be buffered.\n\n"
+			 "   .. warning::\n\n"
+			 "      Raw PCM data needs a lot of space, only buffer\n"
+			 "      short factories.");
 
 static PyObject *
 Sound_cache(Sound* self)
@@ -391,15 +392,16 @@ Sound_cache(Sound* self)
 }
 
 PyDoc_STRVAR(M_aud_Sound_file_doc,
-			 "file(filename)\n\n"
-			 "Creates a sound object of a sound file.\n\n"
-			 ":arg filename: Path of the file.\n"
-			 ":type filename: string\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`\n\n"
-			 ".. warning:: If the file doesn't exist or can't be read you will "
-			 "not get an exception immediately, but when you try to start "
-			 "playback of that sound.");
+			 ".. classmethod:: file(filename)\n\n"
+			 "   Creates a sound object of a sound file.\n\n"
+			 "   :arg filename: Path of the file.\n"
+			 "   :type filename: string\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`\n\n"
+			 "   .. warning::\n\n"
+			 "      If the file doesn't exist or can't be read you will\n"
+			 "      not get an exception immediately, but when you try to start\n"
+			 "      playback of that sound.\n");
 
 static PyObject *
 Sound_file(PyTypeObject* type, PyObject* args)
@@ -430,15 +432,15 @@ Sound_file(PyTypeObject* type, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_sawtooth_doc,
-			 "sawtooth(frequency, rate=48000)\n\n"
-			 "Creates a sawtooth sound which plays a sawtooth wave.\n\n"
-			 ":arg frequency: The frequency of the sawtooth wave in Hz.\n"
-			 ":type frequency: float\n"
-			 ":arg rate: The sampling rate in Hz. It's recommended to set this "
-			 "value to the playback device's samling rate to avoid resamping.\n"
-			 ":type rate: int\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: sawtooth(frequency, rate=48000)\n\n"
+			 "   Creates a sawtooth sound which plays a sawtooth wave.\n\n"
+			 "   :arg frequency: The frequency of the sawtooth wave in Hz.\n"
+			 "   :type frequency: float\n"
+			 "   :arg rate: The sampling rate in Hz. It's recommended to set this\n"
+			 "      value to the playback device's samling rate to avoid resamping.\n"
+			 "   :type rate: int\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_sawtooth(PyTypeObject* type, PyObject* args)
@@ -470,13 +472,13 @@ Sound_sawtooth(PyTypeObject* type, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_silence_doc,
-			 "silence(rate=48000)\n\n"
-			 "Creates a silence sound which plays simple silence.\n\n"
-			 ":arg rate: The sampling rate in Hz. It's recommended to set this "
-			 "value to the playback device's samling rate to avoid resamping.\n"
-			 ":type rate: int\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: silence(rate=48000)\n\n"
+			 "   Creates a silence sound which plays simple silence.\n\n"
+			 "   :arg rate: The sampling rate in Hz. It's recommended to set this\n"
+			 "      value to the playback device's samling rate to avoid resamping.\n"
+			 "   :type rate: int\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_silence(PyTypeObject* type, PyObject* args)
@@ -507,15 +509,15 @@ Sound_silence(PyTypeObject* type, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_sine_doc,
-			 "sine(frequency, rate=48000)\n\n"
-			 "Creates a sine sound which plays a sine wave.\n\n"
-			 ":arg frequency: The frequency of the sine wave in Hz.\n"
-			 ":type frequency: float\n"
-			 ":arg rate: The sampling rate in Hz. It's recommended to set this "
-			 "value to the playback device's samling rate to avoid resamping.\n"
-			 ":type rate: int\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: sine(frequency, rate=48000)\n\n"
+			 "   Creates a sine sound which plays a sine wave.\n\n"
+			 "   :arg frequency: The frequency of the sine wave in Hz.\n"
+			 "   :type frequency: float\n"
+			 "   :arg rate: The sampling rate in Hz. It's recommended to set this\n"
+			 "      value to the playback device's samling rate to avoid resamping.\n"
+			 "   :type rate: int\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_sine(PyTypeObject* type, PyObject* args)
@@ -547,15 +549,15 @@ Sound_sine(PyTypeObject* type, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_square_doc,
-			 "square(frequency, rate=48000)\n\n"
-			 "Creates a square sound which plays a square wave.\n\n"
-			 ":arg frequency: The frequency of the square wave in Hz.\n"
-			 ":type frequency: float\n"
-			 ":arg rate: The sampling rate in Hz. It's recommended to set this "
-			 "value to the playback device's samling rate to avoid resamping.\n"
-			 ":type rate: int\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: square(frequency, rate=48000)\n\n"
+			 "   Creates a square sound which plays a square wave.\n\n"
+			 "   :arg frequency: The frequency of the square wave in Hz.\n"
+			 "   :type frequency: float\n"
+			 "   :arg rate: The sampling rate in Hz. It's recommended to set this\n"
+			 "      value to the playback device's samling rate to avoid resamping.\n"
+			 "   :type rate: int\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_square(PyTypeObject* type, PyObject* args)
@@ -587,15 +589,15 @@ Sound_square(PyTypeObject* type, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_triangle_doc,
-			 "triangle(frequency, rate=48000)\n\n"
-			 "Creates a triangle sound which plays a triangle wave.\n\n"
-			 ":arg frequency: The frequency of the triangle wave in Hz.\n"
-			 ":type frequency: float\n"
-			 ":arg rate: The sampling rate in Hz. It's recommended to set this "
-			 "value to the playback device's samling rate to avoid resamping.\n"
-			 ":type rate: int\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: triangle(frequency, rate=48000)\n\n"
+			 "   Creates a triangle sound which plays a triangle wave.\n\n"
+			 "   :arg frequency: The frequency of the triangle wave in Hz.\n"
+			 "   :type frequency: float\n"
+			 "   :arg rate: The sampling rate in Hz. It's recommended to set this\n"
+			 "      value to the playback device's samling rate to avoid resamping.\n"
+			 "   :type rate: int\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_triangle(PyTypeObject* type, PyObject* args)
@@ -627,14 +629,16 @@ Sound_triangle(PyTypeObject* type, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_accumulate_doc,
-			 "accumulate(additive=False)\n\n"
-			 "Accumulates a sound by summing over positive input differences thus generating a monotonic sigal. "
-			 "If additivity is set to true negative input differences get added too, but positive ones with a factor of two. "
-			 "Note that with additivity the signal is not monotonic anymore.\n\n"
-			 ":arg additive: Whether the accumulation should be additive or not.\n"
-			 ":type time: bool\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: accumulate(additive=False)\n\n"
+			 "   Accumulates a sound by summing over positive input\n"
+			 "   differences thus generating a monotonic sigal.\n"
+			 "   If additivity is set to true negative input differences get added too,\n"
+			 "   but positive ones with a factor of two.\n\n"
+			 "   Note that with additivity the signal is not monotonic anymore.\n\n"
+			 "   :arg additive: Whether the accumulation should be additive or not.\n"
+			 "   :type time: bool\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_accumulate(Sound* self, PyObject* args)
@@ -677,19 +681,19 @@ Sound_accumulate(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_ADSR_doc,
-			 "ADSR(attack,decay,sustain,release)\n\n"
-			 "Attack-Decay-Sustain-Release envelopes the volume of a sound. "
-			 "Note: there is currently no way to trigger the release with this API.\n\n"
-			 ":arg attack: The attack time in seconds.\n"
-			 ":type attack: float\n"
-			 ":arg decay: The decay time in seconds.\n"
-			 ":type decay: float\n"
-			 ":arg sustain: The sustain level.\n"
-			 ":type sustain: float\n"
-			 ":arg release: The release level.\n"
-			 ":type release: float\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: ADSR(attack, decay, sustain, release)\n\n"
+			 "   Attack-Decay-Sustain-Release envelopes the volume of a sound.\n"
+			 "   Note: there is currently no way to trigger the release with this API.\n\n"
+			 "   :arg attack: The attack time in seconds.\n"
+			 "   :type attack: float\n"
+			 "   :arg decay: The decay time in seconds.\n"
+			 "   :type decay: float\n"
+			 "   :arg sustain: The sustain level.\n"
+			 "   :type sustain: float\n"
+			 "   :arg release: The release level.\n"
+			 "   :type release: float\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_ADSR(Sound* self, PyObject* args)
@@ -720,14 +724,12 @@ Sound_ADSR(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_delay_doc,
-			 "delay(time)\n\n"
-			 "Delays by playing adding silence in front of the other sound's "
-			 "data.\n\n"
-			 ":arg time: How many seconds of silence should be added before "
-			 "the sound.\n"
-			 ":type time: float\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: delay(time)\n\n"
+			 "   Delays by playing adding silence in front of the other sound's data.\n\n"
+			 "   :arg time: How many seconds of silence should be added before the sound.\n"
+			 "   :type time: float\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_delay(Sound* self, PyObject* args)
@@ -758,19 +760,18 @@ Sound_delay(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_envelope_doc,
-			 "envelope(attack, release, threshold, arthreshold)\n\n"
-			 "Delays by playing adding silence in front of the other sound's "
-			 "data.\n\n"
-			 ":arg attack: The attack factor.\n"
-			 ":type attack: float\n"
-			 ":arg release: The release factor.\n"
-			 ":type release: float\n"
-			 ":arg threshold: The general threshold value.\n"
-			 ":type threshold: float\n"
-			 ":arg arthreshold: The attack/release threshold value.\n"
-			 ":type arthreshold: float\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: envelope(attack, release, threshold, arthreshold)\n\n"
+			 "   Delays by playing adding silence in front of the other sound's data.\n\n"
+			 "   :arg attack: The attack factor.\n"
+			 "   :type attack: float\n"
+			 "   :arg release: The release factor.\n"
+			 "   :type release: float\n"
+			 "   :arg threshold: The general threshold value.\n"
+			 "   :type threshold: float\n"
+			 "   :arg arthreshold: The attack/release threshold value.\n"
+			 "   :type arthreshold: float\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_envelope(Sound* self, PyObject* args)
@@ -801,16 +802,16 @@ Sound_envelope(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_fadein_doc,
-			 "fadein(start, length)\n\n"
-			 "Fades a sound in by raising the volume linearly in the given "
-			 "time interval.\n\n"
-			 ":arg start: Time in seconds when the fading should start.\n"
-			 ":type start: float\n"
-			 ":arg length: Time in seconds how long the fading should last.\n"
-			 ":type length: float\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`\n\n"
-			 ".. note:: Before the fade starts it plays silence.");
+			 ".. classmethod:: fadein(start, length)\n\n"
+			 "   Fades a sound in by raising the volume linearly in the given\n"
+			 "   time interval.\n\n"
+			 "   :arg start: Time in seconds when the fading should start.\n"
+			 "   :type start: float\n"
+			 "   :arg length: Time in seconds how long the fading should last.\n"
+			 "   :type length: float\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`\n\n"
+			 "   .. note:: Before the fade starts it plays silence.");
 
 static PyObject *
 Sound_fadein(Sound* self, PyObject* args)
@@ -841,17 +842,18 @@ Sound_fadein(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_fadeout_doc,
-			 "fadeout(start, length)\n\n"
-			 "Fades a sound in by lowering the volume linearly in the given "
-			 "time interval.\n\n"
-			 ":arg start: Time in seconds when the fading should start.\n"
-			 ":type start: float\n"
-			 ":arg length: Time in seconds how long the fading should last.\n"
-			 ":type length: float\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`\n\n"
-			 ".. note:: After the fade this sound plays silence, so that "
-			 "the length of the sound is not altered.");
+			 ".. classmethod:: fadeout(start, length)\n\n"
+			 "   Fades a sound in by lowering the volume linearly in the given\n"
+			 "   time interval.\n\n"
+			 "   :arg start: Time in seconds when the fading should start.\n"
+			 "   :type start: float\n"
+			 "   :arg length: Time in seconds how long the fading should last.\n"
+			 "   :type length: float\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`\n\n"
+			 "   .. note::\n\n"
+			 "      After the fade this sound plays silence, so that\n"
+			 "      the length of the sound is not altered.");
 
 static PyObject *
 Sound_fadeout(Sound* self, PyObject* args)
@@ -882,20 +884,20 @@ Sound_fadeout(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_filter_doc,
-			 "filter(b, a = (1))\n\n"
-			 "Filters a sound with the supplied IIR filter coefficients.\n"
-			 "Without the second parameter you'll get a FIR filter.\n"
-			 "If the first value of the a sequence is 0 it will be set to 1 "
-			 "automatically.\n"
-			 "If the first value of the a sequence is neither 0 nor 1, all "
-			 "filter coefficients will be scaled by this value so that it is 1 "
-			 "in the end, you don't have to scale yourself.\n\n"
-			 ":arg b: The nominator filter coefficients.\n"
-			 ":type b: sequence of float\n"
-			 ":arg a: The denominator filter coefficients.\n"
-			 ":type a: sequence of float\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: filter(b, a = (1))\n\n"
+			 "   Filters a sound with the supplied IIR filter coefficients.\n"
+			 "   Without the second parameter you'll get a FIR filter.\n\n"
+			 "   If the first value of the a sequence is 0,\n"
+			 "   it will be set to 1 automatically.\n"
+			 "   If the first value of the a sequence is neither 0 nor 1, all\n"
+			 "   filter coefficients will be scaled by this value so that it is 1\n"
+			 "   in the end, you don't have to scale yourself.\n\n"
+			 "   :arg b: The nominator filter coefficients.\n"
+			 "   :type b: sequence of float\n"
+			 "   :arg a: The denominator filter coefficients.\n"
+			 "   :type a: sequence of float\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_filter(Sound* self, PyObject* args)
@@ -982,15 +984,15 @@ Sound_filter(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_highpass_doc,
-			 "highpass(frequency, Q=0.5)\n\n"
-			 "Creates a second order highpass filter based on the transfer "
-			 "function H(s) = s^2 / (s^2 + s/Q + 1)\n\n"
-			 ":arg frequency: The cut off trequency of the highpass.\n"
-			 ":type frequency: float\n"
-			 ":arg Q: Q factor of the lowpass.\n"
-			 ":type Q: float\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: highpass(frequency, Q=0.5)\n\n"
+			 "   Creates a second order highpass filter based on the transfer\n"
+			 "   function :math:`H(s) = s^2 / (s^2 + s/Q + 1)`\n\n"
+			 "   :arg frequency: The cut off trequency of the highpass.\n"
+			 "   :type frequency: float\n"
+			 "   :arg Q: Q factor of the lowpass.\n"
+			 "   :type Q: float\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_highpass(Sound* self, PyObject* args)
@@ -1022,14 +1024,14 @@ Sound_highpass(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_limit_doc,
-			 "limit(start, end)\n\n"
-			 "Limits a sound within a specific start and end time.\n\n"
-			 ":arg start: Start time in seconds.\n"
-			 ":type start: float\n"
-			 ":arg end: End time in seconds.\n"
-			 ":type end: float\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: limit(start, end)\n\n"
+			 "   Limits a sound within a specific start and end time.\n\n"
+			 "   :arg start: Start time in seconds.\n"
+			 "   :type start: float\n"
+			 "   :arg end: End time in seconds.\n"
+			 "   :type end: float\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_limit(Sound* self, PyObject* args)
@@ -1060,15 +1062,16 @@ Sound_limit(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_loop_doc,
-			 "loop(count)\n\n"
-			 "Loops a sound.\n\n"
-			 ":arg count: How often the sound should be looped. "
-			 "Negative values mean endlessly.\n"
-			 ":type count: integer\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`\n\n"
-			 ".. note:: This is a filter function, you might consider using "
-			 ":attr:`Handle.loop_count` instead.");
+			 ".. classmethod:: loop(count)\n\n"
+			 "   Loops a sound.\n\n"
+			 "   :arg count: How often the sound should be looped.\n"
+			 "      Negative values mean endlessly.\n"
+			 "   :type count: integer\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`\n\n"
+			 "   .. note::\n\n"
+			 "      This is a filter function, you might consider using\n"
+			 "      :attr:`Handle.loop_count` instead.");
 
 static PyObject *
 Sound_loop(Sound* self, PyObject* args)
@@ -1099,15 +1102,15 @@ Sound_loop(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_lowpass_doc,
-			 "lowpass(frequency, Q=0.5)\n\n"
-			 "Creates a second order lowpass filter based on the transfer "
-			 "function H(s) = 1 / (s^2 + s/Q + 1)\n\n"
-			 ":arg frequency: The cut off trequency of the lowpass.\n"
-			 ":type frequency: float\n"
-			 ":arg Q: Q factor of the lowpass.\n"
-			 ":type Q: float\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: lowpass(frequency, Q=0.5)\n\n"
+			 "   Creates a second order lowpass filter based on the transfer "
+			 "   function :math:`H(s) = 1 / (s^2 + s/Q + 1)`\n\n"
+			 "   :arg frequency: The cut off trequency of the lowpass.\n"
+			 "   :type frequency: float\n"
+			 "   :arg Q: Q factor of the lowpass.\n"
+			 "   :type Q: float\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_lowpass(Sound* self, PyObject* args)
@@ -1139,14 +1142,15 @@ Sound_lowpass(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_modulate_doc,
-			 "modulate(sound)\n\n"
-			 "Modulates two factories.\n\n"
-			 ":arg sound: The sound to modulate over the other.\n"
-			 ":type sound: :class:`Sound`\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`\n\n"
-			 ".. note:: The two factories have to have the same specifications "
-			 "(channels and samplerate).");
+			 ".. classmethod:: modulate(sound)\n\n"
+			 "   Modulates two factories.\n\n"
+			 "   :arg sound: The sound to modulate over the other.\n"
+			 "   :type sound: :class:`Sound`\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`\n\n"
+			 "   .. note::\n\n"
+			 "      The two factories have to have the same specifications\n"
+			 "      (channels and samplerate).");
 
 static PyObject *
 Sound_modulate(Sound* self, PyObject* object)
@@ -1180,17 +1184,19 @@ Sound_modulate(Sound* self, PyObject* object)
 }
 
 PyDoc_STRVAR(M_aud_Sound_pitch_doc,
-			 "pitch(factor)\n\n"
-			 "Changes the pitch of a sound with a specific factor.\n\n"
-			 ":arg factor: The factor to change the pitch with.\n"
-			 ":type factor: float\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`\n\n"
-			 ".. note:: This is done by changing the sample rate of the "
-			 "underlying sound, which has to be an integer, so the factor "
-			 "value rounded and the factor may not be 100 % accurate.\n\n"
-			 ".. note:: This is a filter function, you might consider using "
-			 ":attr:`Handle.pitch` instead.");
+			 ".. classmethod:: pitch(factor)\n\n"
+			 "   Changes the pitch of a sound with a specific factor.\n\n"
+			 "   :arg factor: The factor to change the pitch with.\n"
+			 "   :type factor: float\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`\n\n"
+			 "   .. note::\n\n"
+			 "      This is done by changing the sample rate of the\n"
+			 "      underlying sound, which has to be an integer, so the factor\n"
+			 "      value rounded and the factor may not be 100 % accurate.\n\n"
+			 "   .. note::\n\n"
+			 "      This is a filter function, you might consider using\n"
+			 "      :attr:`Handle.pitch` instead.");
 
 static PyObject *
 Sound_pitch(Sound* self, PyObject* args)
@@ -1221,12 +1227,12 @@ Sound_pitch(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_rechannel_doc,
-			 "rechannel(channels)\n\n"
-			 "Rechannels the sound.\n\n"
-			 ":arg channels: The new channel configuration.\n"
-			 ":type channels: int\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: rechannel(channels)\n\n"
+			 "   Rechannels the sound.\n\n"
+			 "   :arg channels: The new channel configuration.\n"
+			 "   :type channels: int\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_rechannel(Sound* self, PyObject* args)
@@ -1261,14 +1267,14 @@ Sound_rechannel(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_resample_doc,
-			 "resample(rate, high_quality)\n\n"
-			 "Resamples the sound.\n\n"
-			 ":arg rate: The new sample rate.\n"
-			 ":type rate: double\n"
-			 ":arg high_quality: When true use a higher quality but slower resampler.\n"
-			 ":type high_quality: bool\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: resample(rate, high_quality)\n\n"
+			 "   Resamples the sound.\n\n"
+			 "   :arg rate: The new sample rate.\n"
+			 "   :type rate: double\n"
+			 "   :arg high_quality: When true use a higher quality but slower resampler.\n"
+			 "   :type high_quality: bool\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_resample(Sound* self, PyObject* args)
@@ -1316,17 +1322,19 @@ Sound_resample(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_reverse_doc,
-			 "reverse()\n\n"
-			 "Plays a sound reversed.\n\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`\n\n"
-			 ".. note:: The sound has to have a finite length and has to be "
-			 "seekable. It's recommended to use this only with factories	 with "
-			 "fast and accurate seeking, which is not true for encoded audio "
-			 "files, such ones should be buffered using :meth:`cache` before "
-			 "being played reversed.\n\n"
-			 ".. warning:: If seeking is not accurate in the underlying sound "
-			 "you'll likely hear skips/jumps/cracks.");
+			 ".. classmethod:: reverse()\n\n"
+			 "   Plays a sound reversed.\n\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`\n\n"
+			 "   .. note::\n\n"
+			 "      The sound has to have a finite length and has to be seekable.\n"
+			 "      It's recommended to use this only with factories with\n"
+			 "      fast and accurate seeking, which is not true for encoded audio\n"
+			 "      files, such ones should be buffered using :meth:`cache` before\n"
+			 "      being played reversed.\n\n"
+			 "   .. warning::\n\n"
+			 "      If seeking is not accurate in the underlying sound\n"
+			 "      you'll likely hear skips/jumps/cracks.");
 
 static PyObject *
 Sound_reverse(Sound* self)
@@ -1352,10 +1360,10 @@ Sound_reverse(Sound* self)
 }
 
 PyDoc_STRVAR(M_aud_Sound_sum_doc,
-			 "sum()\n\n"
-			 "Sums the samples of a sound.\n\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: sum()\n\n"
+			 "   Sums the samples of a sound.\n\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_sum(Sound* self)
@@ -1381,12 +1389,12 @@ Sound_sum(Sound* self)
 }
 
 PyDoc_STRVAR(M_aud_Sound_threshold_doc,
-			 "threshold(threshold = 0)\n\n"
-			 "Makes a threshold wave out of an audio wave by setting all samples "
-			 "with a amplitude >= threshold to 1, all <= -threshold to -1 and "
-			 "all between to 0.\n\n"
-			 ":arg threshold: Threshold value over which an amplitude counts "
-			 "non-zero.\n"
+			 ".. classmethod:: threshold(threshold = 0)\n\n"
+			 "   Makes a threshold wave out of an audio wave by setting all samples\n"
+			 "   with a amplitude >= threshold to 1, all <= -threshold to -1 and\n"
+			 "   all between to 0.\n\n"
+			 "   :arg threshold: Threshold value over which an amplitude counts\n"
+			 "      non-zero.\n"
 			 ":type threshold: float\n"
 			 ":return: The created :class:`Sound` object.\n"
 			 ":rtype: :class:`Sound`");
@@ -1420,15 +1428,16 @@ Sound_threshold(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_volume_doc,
-			 "volume(volume)\n\n"
-			 "Changes the volume of a sound.\n\n"
-			 ":arg volume: The new volume..\n"
-			 ":type volume: float\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`\n\n"
-			 ".. note:: Should be in the range [0, 1] to avoid clipping.\n\n"
-			 ".. note:: This is a filter function, you might consider using "
-			 ":attr:`Handle.volume` instead.");
+			 ".. classmethod:: volume(volume)\n\n"
+			 "   Changes the volume of a sound.\n\n"
+			 "   :arg volume: The new volume..\n"
+			 "   :type volume: float\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`\n\n"
+			 "   .. note:: Should be in the range [0, 1] to avoid clipping.\n\n"
+			 "   .. note::\n\n"
+			 "      This is a filter function, you might consider using\n"
+			 "      :attr:`Handle.volume` instead.");
 
 static PyObject *
 Sound_volume(Sound* self, PyObject* args)
@@ -1459,14 +1468,15 @@ Sound_volume(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_join_doc,
-			 "join(sound)\n\n"
-			 "Plays two factories in sequence.\n\n"
-			 ":arg sound: The sound to play second.\n"
-			 ":type sound: :class:`Sound`\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`\n\n"
-			 ".. note:: The two factories have to have the same specifications "
-			 "(channels and samplerate).");
+			 ".. classmethod:: join(sound)\n\n"
+			 "   Plays two factories in sequence.\n\n"
+			 "   :arg sound: The sound to play second.\n"
+			 "   :type sound: :class:`Sound`\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`\n\n"
+			 "   .. note::\n\n"
+			 "   The two factories have to have the same specifications\n"
+			 "   (channels and samplerate).");
 
 static PyObject *
 Sound_join(Sound* self, PyObject* object)
@@ -1501,14 +1511,15 @@ Sound_join(Sound* self, PyObject* object)
 }
 
 PyDoc_STRVAR(M_aud_Sound_mix_doc,
-			 "mix(sound)\n\n"
-			 "Mixes two factories.\n\n"
-			 ":arg sound: The sound to mix over the other.\n"
-			 ":type sound: :class:`Sound`\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`\n\n"
-			 ".. note:: The two factories have to have the same specifications "
-			 "(channels and samplerate).");
+			 ".. classmethod:: mix(sound)\n\n"
+			 "   Mixes two factories.\n\n"
+			 "   :arg sound: The sound to mix over the other.\n"
+			 "   :type sound: :class:`Sound`\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`\n\n"
+			 "   .. note::\n\n"
+			 "      The two factories have to have the same specifications\n"
+			 "      (channels and samplerate).");
 
 static PyObject *
 Sound_mix(Sound* self, PyObject* object)
@@ -1542,11 +1553,11 @@ Sound_mix(Sound* self, PyObject* object)
 }
 
 PyDoc_STRVAR(M_aud_Sound_pingpong_doc,
-			 "pingpong()\n\n"
-			 "Plays a sound forward and then backward.\n"
-			 "This is like joining a sound with its reverse.\n\n"
-			 ":return: The created :class:`Sound` object.\n"
-			 ":rtype: :class:`Sound`");
+			 ".. classmethod:: pingpong()\n\n"
+			 "   Plays a sound forward and then backward.\n"
+			 "   This is like joining a sound with its reverse.\n\n"
+			 "   :return: The created :class:`Sound` object.\n"
+			 "   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_pingpong(Sound* self)
@@ -1572,12 +1583,12 @@ Sound_pingpong(Sound* self)
 }
 
 PyDoc_STRVAR(M_aud_Sound_list_doc,
-	"list()\n\n"
-	"Creates an empty sound list that can contain several sounds.\n\n"
-	":arg random: wether the playback will be random or not.\n"
-	":type random: int\n"
-	":return: The created :class:`Sound` object.\n"
-	":rtype: :class:`Sound`");
+	".. classmethod:: list()\n\n"
+	"   Creates an empty sound list that can contain several sounds.\n\n"
+	"   :arg random: whether the playback will be random or not.\n"
+	"   :type random: int\n"
+	"   :return: The created :class:`Sound` object.\n"
+	"   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_list(PyTypeObject* type, PyObject* args)
@@ -1608,11 +1619,11 @@ Sound_list(PyTypeObject* type, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_mutable_doc,
-	"mutable()\n\n"
-	"Creates a sound that will be restarted when sought backwards.\n"
-	"If the original sound is a sound list, the playing sound can change.\n\n"
-	":return: The created :class:`Sound` object.\n"
-	":rtype: :class:`Sound`");
+	".. classmethod:: mutable()\n\n"
+	"   Creates a sound that will be restarted when sought backwards.\n"
+	"   If the original sound is a sound list, the playing sound can change.\n\n"
+	"   :return: The created :class:`Sound` object.\n"
+	"   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_mutable(Sound* self)
@@ -1638,12 +1649,12 @@ Sound_mutable(Sound* self)
 }
 
 PyDoc_STRVAR(M_aud_Sound_list_addSound_doc,
-	"addSound(sound)\n\n"
-	"Adds a new sound to a sound list.\n\n"
-	":arg sound: The sound that will be added to the list.\n"
-	":type sound: :class:`Sound`\n\n"
-	".. note:: You can only add a sound to a sound list.");
-	
+	".. classmethod:: addSound(sound)\n\n"
+	"   Adds a new sound to a sound list.\n\n"
+	"   :arg sound: The sound that will be added to the list.\n"
+	"   :type sound: :class:`Sound`\n\n"
+	"   .. note:: You can only add a sound to a sound list.");
+
 static PyObject *
 Sound_list_addSound(Sound* self, PyObject* object)
 {
@@ -1671,14 +1682,14 @@ Sound_list_addSound(Sound* self, PyObject* object)
 #ifdef WITH_CONVOLUTION
 
 PyDoc_STRVAR(M_aud_Sound_convolver_doc,
-	"convolver()\n\n"
-	"Creates a sound that will apply convolution to another sound.\n\n"
-	":arg impulseResponse: The filter with which convolve the sound.\n"
-	":type impulseResponse: :class:`ImpulseResponse`\n"
-	":arg threadPool: A thread pool used to parallelize convolution.\n"
-	":type threadPool: :class:`ThreadPool`\n"
-	":return: The created :class:`Sound` object.\n"
-	":rtype: :class:`Sound`");
+	".. classmethod:: convolver()\n\n"
+	"   Creates a sound that will apply convolution to another sound.\n\n"
+	"   :arg impulseResponse: The filter with which convolve the sound.\n"
+	"   :type impulseResponse: :class:`ImpulseResponse`\n"
+	"   :arg threadPool: A thread pool used to parallelize convolution.\n"
+	"   :type threadPool: :class:`ThreadPool`\n"
+	"   :return: The created :class:`Sound` object.\n"
+	"   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_convolver(Sound* self, PyObject* args)
@@ -1720,16 +1731,16 @@ Sound_convolver(Sound* self, PyObject* args)
 }
 
 PyDoc_STRVAR(M_aud_Sound_binaural_doc,
-	"convolver()\n\n"
-	"Creates a binaural sound using another sound as source. The original sound must be mono\n\n"
-	":arg hrtfs: An HRTF set.\n"
-	":type hrtf: :class:`HRTF`\n"
-	":arg source: An object representing the source position of the sound.\n"
-	":type source: :class:`Source`\n"
-	":arg threadPool: A thread pool used to parallelize convolution.\n"
-	":type threadPool: :class:`ThreadPool`\n"
-	":return: The created :class:`Sound` object.\n"
-	":rtype: :class:`Sound`");
+	".. classmethod:: convolver()\n\n"
+	"   Creates a binaural sound using another sound as source. The original sound must be mono\n\n"
+	"   :arg hrtfs: An HRTF set.\n"
+	"   :type hrtf: :class:`HRTF`\n"
+	"   :arg source: An object representing the source position of the sound.\n"
+	"   :type source: :class:`Source`\n"
+	"   :arg threadPool: A thread pool used to parallelize convolution.\n"
+	"   :type threadPool: :class:`ThreadPool`\n"
+	"   :return: The created :class:`Sound` object.\n"
+	"   :rtype: :class:`Sound`");
 
 static PyObject *
 Sound_binaural(Sound* self, PyObject* args)
-- 
2.29.2

