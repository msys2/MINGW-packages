diff -Naur inkscape-0.92.3/src/extension/internal/pdfinput/pdf-input.cpp inkscape-master/src/extension/internal/pdfinput/pdf-input.cpp
--- inkscape-0.92.3/src/extension/internal/pdfinput/pdf-input.cpp	2018-03-11 23:38:09.000000000 +0300
+++ inkscape-master/src/extension/internal/pdfinput/pdf-input.cpp	2018-10-22 14:51:57.000000000 +0300
@@ -12,7 +12,7 @@
  */
 
 #ifdef HAVE_CONFIG_H
-# include <config.h>
+# include "config.h"  // only include where actually required!
 #endif
 
 #include "pdf-input.h"
@@ -338,7 +356,7 @@
     _preview_height = 300;
 
     // Init preview
-    _thumb_data = NULL;
+    _thumb_data = nullptr;
     _pageNumberSpin_adj->set_value(1.0);
     _current_page = 1;
     _setPreviewPage(_current_page);
@@ -585,7 +593,7 @@
     if (!_render_thumb) {
         if (_thumb_data) {
             gfree(_thumb_data);
-            _thumb_data = NULL;
+            _thumb_data = nullptr;
         }
         if (!_previewed_page->loadThumb(&_thumb_data,
              &_thumb_width, &_thumb_height, &_thumb_rowstride)) {
@@ -701,11 +709,11 @@
 
     // PDFDoc is from poppler. PDFDoc is used for preview and for native import.
 
-#ifndef WIN32
+#ifndef _WIN32
     // poppler does not use glib g_open. So on win32 we must use unicode call. code was copied from
     // glib gstdio.c
     GooString *filename_goo = new GooString(uri);
-    PDFDoc *pdf_doc = new PDFDoc(filename_goo, NULL, NULL, NULL);   // TODO: Could ask for password
+    PDFDoc *pdf_doc = new PDFDoc(filename_goo, nullptr, nullptr, nullptr);   // TODO: Could ask for password
     //delete filename_goo;
 #else
     wchar_t *wfilename = reinterpret_cast<wchar_t*>(g_utf8_to_utf16 (uri, -1, NULL, NULL, NULL));
@@ -745,17 +753,17 @@
             g_message("Failed to load document from data (error %d)", error);
         }
 
-        return NULL;
+        return nullptr;
     }
 
-    PdfImportDialog *dlg = NULL;
+    PdfImportDialog *dlg = nullptr;
     if (INKSCAPE.use_gui()) {
         dlg = new PdfImportDialog(pdf_doc, uri);
         if (!dlg->showDialog()) {
             _cancelled = true;
             delete dlg;
             delete pdf_doc;
-            return NULL;
+            return nullptr;
         }
     }
 
@@ -768,12 +776,12 @@
 #endif
     }
 
-    SPDocument *doc = NULL;
+    SPDocument *doc = nullptr;
     bool saved = false;
     if(!is_importvia_poppler)
     {
         // native importer
-        doc = SPDocument::createNewDoc(NULL, TRUE, TRUE);
+        doc = SPDocument::createNewDoc(nullptr, TRUE, TRUE);
         saved = DocumentUndo::getUndoSensitive(doc);
         DocumentUndo::setUndoSensitive(doc, false); // No need to undo in this temporary document
 
@@ -793,7 +803,7 @@
             dlg->getImportSettings(prefs);
 
         // Apply crop settings
-        PDFRectangle *clipToBox = NULL;
+        _POPPLER_CONST PDFRectangle *clipToBox = nullptr;
         double crop_setting;
         sp_repr_get_double(prefs, "cropTo", &crop_setting);
 
@@ -936,7 +946,7 @@
 
 #include "../clear-n_.h"
 
-void PdfInput::init(void) {
+void PdfInput::init() {
     /* PDF in */
     Inkscape::Extension::build_from_mem(
         "<inkscape-extension xmlns=\"" INKSCAPE_EXTENSION_URI "\">\n"
@@ -945,8 +955,8 @@
             "<input>\n"
                 "<extension>.pdf</extension>\n"
                 "<mimetype>application/pdf</mimetype>\n"
-                "<filetypename>" N_("Adobe PDF (*.pdf)") "</filetypename>\n"
-                "<filetypetooltip>" N_("Adobe Portable Document Format") "</filetypetooltip>\n"
+                "<filetypename>" N_("Portable Document Format (*.pdf)") "</filetypename>\n"
+                "<filetypetooltip>" N_("Portable Document Format") "</filetypetooltip>\n"
             "</input>\n"
         "</inkscape-extension>", new PdfInput());
 
diff -Naur inkscape-0.92.3/src/extension/internal/pdfinput/pdf-input.h inkscape-master/src/extension/internal/pdfinput/pdf-input.h
--- inkscape-0.92.3/src/extension/internal/pdfinput/pdf-input.h	2018-03-11 23:38:09.000000000 +0300
+++ inkscape-master/src/extension/internal/pdfinput/pdf-input.h	2018-10-22 14:51:57.000000000 +0300
@@ -11,10 +11,11 @@
  */
 
 #ifdef HAVE_CONFIG_H
-# include <config.h>
+# include "config.h"  // only include where actually required!
 #endif
 
 #ifdef HAVE_POPPLER
+#include "poppler-transition-api.h"
 
 #include <gtkmm/dialog.h>
 
@@ -68,7 +64,7 @@
 {
 public:
     PdfImportDialog(PDFDoc *doc, const gchar *uri);
-    virtual ~PdfImportDialog();
+    ~PdfImportDialog() override;
 
     bool showDialog();
     int getSelectedPage();
@@ -146,12 +133,12 @@
 
     
 class PdfInput: public Inkscape::Extension::Implementation::Implementation {
-    PdfInput () { };
+    PdfInput () = default;;
 public:
     SPDocument *open( Inkscape::Extension::Input *mod,
-                                const gchar *uri );
-    static void         init( void );
-    virtual bool wasCancelled();
+                                const gchar *uri ) override;
+    static void         init( );
+    bool wasCancelled() override;
 private:
     bool _cancelled;
 };
diff -Naur inkscape-0.92.3/src/extension/internal/pdfinput/pdf-parser.cpp inkscape-master/src/extension/internal/pdfinput/pdf-parser.cpp
--- inkscape-0.92.3/src/extension/internal/pdfinput/pdf-parser.cpp	2018-03-11 23:38:09.000000000 +0300
+++ inkscape-master/src/extension/internal/pdfinput/pdf-parser.cpp	2018-10-22 14:51:57.000000000 +0300
@@ -12,7 +12,7 @@
  */
 
 #ifdef HAVE_CONFIG_H
-# include <config.h>
+# include "config.h"  // only include where actually required!
 #endif
 
 #ifdef HAVE_POPPLER
@@ -21,24 +21,20 @@
 #pragma implementation
 #endif
 
-extern "C" {
-        
-#include <stdlib.h>
-#include <stdio.h>
-#include <stddef.h>
-#include <string.h>
-#include <math.h>
-
-}
+#include <cstdlib>
+#include <cstdio>
+#include <cstddef>
+#include <cstring>
+#include <cmath>
 
 #include "svg-builder.h"
 #include "Gfx.h"
 #include "pdf-parser.h"
 #include "util/units.h"
 
+#include "glib/poppler-features.h"
 #include "goo/gmem.h"
-#include "goo/GooTimer.h"
-#include "goo/GooHash.h"
+#include "goo/GooString.h"
 #include "GlobalParams.h"
 #include "CharTypes.h"
 #include "Object.h"
@@ -265,13 +261,13 @@
 class ClipHistoryEntry {
 public:
 
-    ClipHistoryEntry(GfxPath *clipPath = NULL, GfxClipType clipType = clipNormal);
+    ClipHistoryEntry(GfxPath *clipPath = nullptr, GfxClipType clipType = clipNormal);
     virtual ~ClipHistoryEntry();
 
     // Manipulate clip path stack
     ClipHistoryEntry *save();
     ClipHistoryEntry *restore();
-    GBool hasSaves() { return saved != NULL; }
+    GBool hasSaves() { return saved != nullptr; }
     void setClip(GfxPath *newClipPath, GfxClipType newClipType = clipNormal);
     GfxPath *getClipPath() { return clipPath; }
     GfxClipType getClipType() { return clipType; }
@@ -295,30 +291,30 @@
                      int /*pageNum*/,
 		     int rotate,
 		     Dict *resDict,
-                     PDFRectangle *box,
-		     PDFRectangle *cropBox) :
+                     _POPPLER_CONST PDFRectangle *box,
+                     _POPPLER_CONST PDFRectangle *cropBox) :
     xref(xrefA),
     builder(builderA),
     subPage(gFalse),
     printCommands(false),
-    res(new GfxResources(xref, resDict, NULL)), // start the resource stack
+    res(new GfxResources(xref, resDict, nullptr)), // start the resource stack
     state(new GfxState(72.0, 72.0, box, rotate, gTrue)),
     fontChanged(gFalse),
     clip(clipNone),
     ignoreUndef(0),
     baseMatrix(),
     formDepth(0),
-    parser(NULL),
+    parser(nullptr),
     colorDeltas(),
     maxDepths(),
     clipHistory(new ClipHistoryEntry()),
-    operatorHistory(NULL)
+    operatorHistory(nullptr)
 {
   setDefaultApproximationPrecision();
   builder->setDocumentSize(Inkscape::Util::Quantity::convert(state->getPageWidth(), "pt", "px"),
                            Inkscape::Util::Quantity::convert(state->getPageHeight(), "pt", "px"));
 
-  double *ctm = state->getCTM();
+  const double *ctm = state->getCTM();
   double scaledCTM[6];
   for (int i = 0; i < 6; ++i) {
     baseMatrix[i] = ctm[i];
@@ -353,23 +349,23 @@
 PdfParser::PdfParser(XRef *xrefA,
 		     Inkscape::Extension::Internal::SvgBuilder *builderA,
                      Dict *resDict,
-		     PDFRectangle *box) :
+		     _POPPLER_CONST PDFRectangle *box) :
     xref(xrefA),
     builder(builderA),
     subPage(gTrue),
     printCommands(false),
-    res(new GfxResources(xref, resDict, NULL)), // start the resource stack
+    res(new GfxResources(xref, resDict, nullptr)), // start the resource stack
     state(new GfxState(72, 72, box, 0, gFalse)),
     fontChanged(gFalse),
     clip(clipNone),
     ignoreUndef(0),
     baseMatrix(),
     formDepth(0),
-    parser(NULL),
+    parser(nullptr),
     colorDeltas(),
     maxDepths(),
     clipHistory(new ClipHistoryEntry()),
-    operatorHistory(NULL)
+    operatorHistory(nullptr)
 {
   setDefaultApproximationPrecision();
   
@@ -400,12 +396,12 @@
 
   if (state) {
     delete state;
-    state = NULL;
+    state = nullptr;
   }
 
   if (clipHistory) {
     delete clipHistory;
-    clipHistory = NULL;
+    clipHistory = nullptr;
   }
 }
 
@@ -414,21 +410,13 @@
 
   if (obj->isArray()) {
     for (int i = 0; i < obj->arrayGetLength(); ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      obj2 = obj->arrayGet(i);
-#else
-      obj->arrayGet(i, &obj2);
-#endif
+      _POPPLER_CALL_ARGS(obj2, obj->arrayGet, i);
       if (!obj2.isStream()) {
 	error(errInternal, -1, "Weird page contents");
-#if !defined(POPPLER_NEW_OBJECT_API)
-	obj2.free();
-#endif
+	_POPPLER_FREE(obj2);
 	return;
       }
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj2.free();
-#endif
+      _POPPLER_FREE(obj2);
     }
   } else if (!obj->isStream()) {
 	error(errInternal, -1, "Weird page contents");
@@ -437,7 +425,7 @@
   parser = new Parser(xref, new Lexer(xref, obj), gFalse);
   go(topLevel);
   delete parser;
-  parser = NULL;
+  parser = nullptr;
 }
 
 void PdfParser::go(GBool /*topLevel*/)
@@ -447,11 +435,7 @@
 
   // scan a sequence of objects
   int numArgs = 0;
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj = parser->getObj();
-#else
-  parser->getObj(&obj);
-#endif
+  _POPPLER_CALL(obj, parser->getObj);
   while (!obj.isEOF()) {
 
     // got a command - execute it
@@ -470,19 +454,15 @@
       execOp(&obj, args, numArgs);
 
 #if !defined(POPPLER_NEW_OBJECT_API)
-      obj.free();
+      _POPPLER_FREE(obj);
       for (int i = 0; i < numArgs; ++i)
-	args[i].free();
+	_POPPLER_FREE(args[i]);
 #endif
       numArgs = 0;
 
     // got an argument - save it
     } else if (numArgs < maxArgs) {
-#if defined(POPPLER_NEW_OBJECT_API)
       args[numArgs++] = std::move(obj);
-#else
-      args[numArgs++] = obj;
-#endif
 
     // too many arguments - something is wrong
     } else {
@@ -493,21 +473,13 @@
 	printf("\n");
 	fflush(stdout);
       }
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj.free();
-#endif
+      _POPPLER_FREE(obj);
     }
 
     // grab the next object
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj = parser->getObj();
-#else
-    parser->getObj(&obj);
-#endif
+    _POPPLER_CALL(obj, parser->getObj);
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj.free();
-#endif
+  _POPPLER_FREE(obj);
 
   // args at end with no command
   if (numArgs > 0) {
@@ -523,7 +495,7 @@
     }
 #if !defined(POPPLER_NEW_OBJECT_API)
     for (int i = 0; i < numArgs; ++i)
-      args[i].free();
+      _POPPLER_FREE(args[i]);
 #endif
   }
 }
@@ -532,38 +504,38 @@
 {
     OpHistoryEntry *newEntry = new OpHistoryEntry;
     newEntry->name = name;
-    newEntry->state = NULL;
-    newEntry->depth = (operatorHistory != NULL ? (operatorHistory->depth+1) : 0);
+    newEntry->state = nullptr;
+    newEntry->depth = (operatorHistory != nullptr ? (operatorHistory->depth+1) : 0);
     newEntry->next = operatorHistory;
     operatorHistory = newEntry;
 
     // Truncate list if needed
     if (operatorHistory->depth > maxOperatorHistoryDepth) {
         OpHistoryEntry *curr = operatorHistory;
-        OpHistoryEntry *prev = NULL;
-        while (curr && curr->next != NULL) {
+        OpHistoryEntry *prev = nullptr;
+        while (curr && curr->next != nullptr) {
             curr->depth--;
             prev = curr;
             curr = curr->next;
         }
         if (prev) {
-            if (curr->state != NULL)
+            if (curr->state != nullptr)
                 delete curr->state;
             delete curr;
-            prev->next = NULL;
+            prev->next = nullptr;
         }
     }
 }
 
 const char *PdfParser::getPreviousOperator(unsigned int look_back) {
-    OpHistoryEntry *prev = NULL;
-    if (operatorHistory != NULL && look_back > 0) {
+    OpHistoryEntry *prev = nullptr;
+    if (operatorHistory != nullptr && look_back > 0) {
         prev = operatorHistory->next;
-        while (--look_back > 0 && prev != NULL) {
+        while (--look_back > 0 && prev != nullptr) {
             prev = prev->next;
         }
     }
-    if (prev != NULL) {
+    if (prev != nullptr) {
         return prev->name;
     } else {
         return "";
@@ -572,7 +544,7 @@
 
 void PdfParser::execOp(Object *cmd, Object args[], int numArgs) {
   PdfOperator *op;
-  char *name;
+  const char *name;
   Object *argPtr;
   int i;
 
@@ -620,7 +592,7 @@
   (this->*op->func)(argPtr, numArgs);
 }
 
-PdfOperator* PdfParser::findOp(char *name) {
+PdfOperator* PdfParser::findOp(const char *name) {
   int a = -1;
   int b = numOps;
   int cmp = -1;
@@ -636,7 +608,7 @@
       a = b = m;
   }
   if (cmp != 0)
-    return NULL;
+    return nullptr;
   return &opTab[a];
 }
 
@@ -713,20 +685,16 @@
 // TODO not good that numArgs is ignored but args[] is used:
 void PdfParser::opSetDash(Object args[], int /*numArgs*/)
 {
-  double *dash = 0;
+  double *dash = nullptr;
 
   Array *a = args[0].getArray();
   int length = a->getLength();
   if (length != 0) {
     dash = (double *)gmallocn(length, sizeof(double));
     for (int i = 0; i < length; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      dash[i] = a->get(i).getNum();
-#else
       Object obj;
-      dash[i] = a->get(i, &obj)->getNum();
-      obj.free();
-#endif
+      dash[i] = _POPPLER_CALL_ARGS_DEREF(obj, a->get, i).getNum();
+      _POPPLER_FREE(obj);
     }
   }
   state->setLineDash(dash, length, args[1].getNum());
@@ -771,23 +739,18 @@
 void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
 {
   Object obj1, obj2, obj3, obj4, obj5;
-  Function *funcs[4] = {0, 0, 0, 0};
+  Function *funcs[4] = {nullptr, nullptr, nullptr, nullptr};
   GfxColor backdropColor;
   GBool haveBackdropColor = gFalse;
   GBool alpha = gFalse;
 
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj1 = res->lookupGState(args[0].getName())).isNull()) {
-#else
-  if (!res->lookupGState(args[0].getName(), &obj1)) {
-#endif
+  _POPPLER_CALL_ARGS(obj1, res->lookupGState, args[0].getName());
+  if (obj1.isNull()) {
     return;
   }
   if (!obj1.isDict()) {
     error(errSyntaxError, getPos(), "ExtGState '{0:s}' is wrong type"), args[0].getName();
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
     return;
   }
   if (printCommands) {
@@ -797,11 +760,7 @@
   }
 
   // transparency support: blend mode, fill/stroke opacity
-#if defined(POPPLER_NEW_OBJECT_API)
-  if (!((obj2 = obj1.dictLookup(const_cast<char*>("BM"))).isNull())) {
-#else
-  if (!obj1.dictLookup(const_cast<char*>("BM"), &obj2)->isNull()) {
-#endif
+  if (!_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "BM").isNull()) {
     GfxBlendMode mode = gfxBlendNormal;
     if (state->parseBlendMode(&obj2, &mode)) {
       state->setBlendMode(mode);
@@ -809,88 +768,51 @@
       error(errSyntaxError, getPos(), "Invalid blend mode in ExtGState");
     }
   }
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj2 = obj1.dictLookup(const_cast<char*>("ca"))).isNum()) {
-#else
-  obj2.free();
-  if (obj1.dictLookup(const_cast<char*>("ca"), &obj2)->isNum()) {
-#endif
+  _POPPLER_FREE(obj2);
+  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "ca").isNum()) {
     state->setFillOpacity(obj2.getNum());
   }
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj2 = obj1.dictLookup(const_cast<char*>("CA"))).isNum()) {
-#else
-  obj2.free();
-  if (obj1.dictLookup(const_cast<char*>("CA"), &obj2)->isNum()) {
-#endif
+  _POPPLER_FREE(obj2);
+  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "CA").isNum()) {
     state->setStrokeOpacity(obj2.getNum());
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj2.free();
-#endif
+  _POPPLER_FREE(obj2);
 
   // fill/stroke overprint
   GBool haveFillOP = gFalse;
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((haveFillOP = (obj2 = obj1.dictLookup(const_cast<char*>("op"))).isBool())) {
-#else
-  if ((haveFillOP = (obj1.dictLookup(const_cast<char*>("op"), &obj2)->isBool()))) {
-#endif
+  if ((haveFillOP = _POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "op").isBool())) {
     state->setFillOverprint(obj2.getBool());
   }
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj2 = obj1.dictLookup(const_cast<char*>("OP"))).isBool()) {
-#else
-  obj2.free();
-  if (obj1.dictLookup(const_cast<char*>("OP"), &obj2)->isBool()) {
-#endif
+  _POPPLER_FREE(obj2);
+  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "OP").isBool()) {
     state->setStrokeOverprint(obj2.getBool());
     if (!haveFillOP) {
       state->setFillOverprint(obj2.getBool());
     }
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj2.free();
-#endif
+  _POPPLER_FREE(obj2);
 
   // stroke adjust
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj2 = obj1.dictLookup(const_cast<char*>("SA"))).isBool()) {
-#else
-  if (obj1.dictLookup(const_cast<char*>("SA"), &obj2)->isBool()) {
-#endif
+  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "SA").isBool()) {
     state->setStrokeAdjust(obj2.getBool());
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj2.free();
-#endif
+  _POPPLER_FREE(obj2);
 
   // transfer function
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj2 = obj1.dictLookup(const_cast<char*>("TR2"))).isNull()) {
-    obj2 = obj1.dictLookup(const_cast<char*>("TR"));
-#else
-  if (obj1.dictLookup(const_cast<char*>("TR2"), &obj2)->isNull()) {
-    obj2.free();
-    obj1.dictLookup(const_cast<char*>("TR"), &obj2);
-#endif
+  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "TR2").isNull()) {
+    _POPPLER_FREE(obj2);
+    _POPPLER_CALL_ARGS(obj2, obj1.dictLookup, "TR");
   }
   if (obj2.isName(const_cast<char*>("Default")) ||
       obj2.isName(const_cast<char*>("Identity"))) {
-    funcs[0] = funcs[1] = funcs[2] = funcs[3] = NULL;
+    funcs[0] = funcs[1] = funcs[2] = funcs[3] = nullptr;
     state->setTransfer(funcs);
   } else if (obj2.isArray() && obj2.arrayGetLength() == 4) {
     int pos = 4;
     for (int i = 0; i < 4; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      obj3 = obj2.arrayGet(i);
-#else
-      obj2.arrayGet(i, &obj3);
-#endif
+      _POPPLER_CALL_ARGS(obj3, obj2.arrayGet, i);
       funcs[i] = Function::parse(&obj3);
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj3.free();
-#endif
+      _POPPLER_FREE(obj3);
       if (!funcs[i]) {
 	pos = i;
 	break;
@@ -901,117 +823,72 @@
     }
   } else if (obj2.isName() || obj2.isDict() || obj2.isStream()) {
     if ((funcs[0] = Function::parse(&obj2))) {
-      funcs[1] = funcs[2] = funcs[3] = NULL;
+      funcs[1] = funcs[2] = funcs[3] = nullptr;
       state->setTransfer(funcs);
     }
   } else if (!obj2.isNull()) {
     error(errSyntaxError, getPos(), "Invalid transfer function in ExtGState");
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj2.free();
-#endif
+  _POPPLER_FREE(obj2);
 
   // soft mask
-#if defined(POPPLER_NEW_OBJECT_API)
-  if (!((obj2 = obj1.dictLookup(const_cast<char*>("SMask"))).isNull())) {
-#else
-  if (!obj1.dictLookup(const_cast<char*>("SMask"), &obj2)->isNull()) {
-#endif
+  if (!_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "SMask").isNull()) {
     if (obj2.isName(const_cast<char*>("None"))) {
       builder->clearSoftMask(state);
     } else if (obj2.isDict()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      if ((obj3 = obj2.dictLookup(const_cast<char*>("S"))).isName(const_cast<char*>("Alpha"))) {
-#else
-      if (obj2.dictLookup(const_cast<char*>("S"), &obj3)->isName(const_cast<char*>("Alpha"))) {
-#endif
+      if (_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "S").isName("Alpha")) {
 	alpha = gTrue;
       } else { // "Luminosity"
 	alpha = gFalse;
       }
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj3.free();
-#endif
-      funcs[0] = NULL;
-#if defined(POPPLER_NEW_OBJECT_API)
-      if (!((obj3 = obj2.dictLookup(const_cast<char*>("TR"))).isNull())) {
-#else
-      if (!obj2.dictLookup(const_cast<char*>("TR"), &obj3)->isNull()) {
-#endif
+      _POPPLER_FREE(obj3);
+      funcs[0] = nullptr;
+      if (!_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "TR").isNull()) {
 	funcs[0] = Function::parse(&obj3);
 	if (funcs[0]->getInputSize() != 1 ||
 	    funcs[0]->getOutputSize() != 1) {
 	  error(errSyntaxError, getPos(), "Invalid transfer function in soft mask in ExtGState");
 	  delete funcs[0];
-	  funcs[0] = NULL;
+	  funcs[0] = nullptr;
 	}
       }
-#if defined(POPPLER_NEW_OBJECT_API)
-      if ((haveBackdropColor = (obj3 = obj2.dictLookup(const_cast<char*>("BC"))).isArray())) {
-#else
-      obj3.free();
-      if ((haveBackdropColor = obj2.dictLookup(const_cast<char*>("BC"), &obj3)->isArray())) {
-#endif
+      _POPPLER_FREE(obj3);
+      if ((haveBackdropColor = _POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "BC").isArray())) {
 	for (int i = 0; i < gfxColorMaxComps; ++i) {
 	  backdropColor.c[i] = 0;
 	}
 	for (int i = 0; i < obj3.arrayGetLength() && i < gfxColorMaxComps; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-	  obj4 = obj3.arrayGet(i);
-#else
-	  obj3.arrayGet(i, &obj4);
-#endif
+          _POPPLER_CALL_ARGS(obj4, obj3.arrayGet, i);
 	  if (obj4.isNum()) {
 	    backdropColor.c[i] = dblToCol(obj4.getNum());
 	  }
-#if !defined(POPPLER_NEW_OBJECT_API)
-	  obj4.free();
-#endif
+	  _POPPLER_FREE(obj4);
 	}
       }
-#if defined(POPPLER_NEW_OBJECT_API)
-      if ((obj3 = obj2.dictLookup(const_cast<char*>("G"))).isStream()) {
-	if ((obj4 = obj3.streamGetDict()->lookup(const_cast<char*>("Group"))).isDict()) {
-#else
-      obj3.free();
-      if (obj2.dictLookup(const_cast<char*>("G"), &obj3)->isStream()) {
-	if (obj3.streamGetDict()->lookup(const_cast<char*>("Group"), &obj4)->isDict()) {
-#endif
-	  GfxColorSpace *blendingColorSpace = 0;
+      _POPPLER_FREE(obj3);
+      if (_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "G").isStream()) {
+	if (_POPPLER_CALL_ARGS_DEREF(obj4, obj3.streamGetDict()->lookup, "Group").isDict()) {
+	  GfxColorSpace *blendingColorSpace = nullptr;
 	  GBool isolated = gFalse;
 	  GBool knockout = gFalse;
-#if defined(POPPLER_NEW_OBJECT_API)
-	  if (!((obj5 = obj4.dictLookup(const_cast<char*>("CS"))).isNull())) {
-#else
-	  if (!obj4.dictLookup(const_cast<char*>("CS"), &obj5)->isNull()) {
-#endif
+	  if (!_POPPLER_CALL_ARGS_DEREF(obj5, obj4.dictLookup, "CS").isNull()) {
 #if defined(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API)
-	    blendingColorSpace = GfxColorSpace::parse(NULL, &obj5, NULL, NULL);
+	    blendingColorSpace = GfxColorSpace::parse(nullptr, &obj5, nullptr, nullptr);
 #elif defined(POPPLER_EVEN_NEWER_COLOR_SPACE_API)
 	    blendingColorSpace = GfxColorSpace::parse(&obj5, NULL, NULL);
 #else
 	    blendingColorSpace = GfxColorSpace::parse(&obj5, NULL);
 #endif
 	  }
-#if defined(POPPLER_NEW_OBJECT_API)
-	  if ((obj5 = obj4.dictLookup(const_cast<char*>("I"))).isBool()) {
-#else
-	  obj5.free();
-	  if (obj4.dictLookup(const_cast<char*>("I"), &obj5)->isBool()) {
-#endif
+          _POPPLER_FREE(obj5);
+	  if (_POPPLER_CALL_ARGS_DEREF(obj5, obj4.dictLookup, "I").isBool()) {
 	    isolated = obj5.getBool();
 	  }
-#if defined(POPPLER_NEW_OBJECT_API)
-	  if ((obj5 = obj4.dictLookup(const_cast<char*>("K"))).isBool()) {
-#else
-	  obj5.free();
-	  if (obj4.dictLookup(const_cast<char*>("K"), &obj5)->isBool()) {
-#endif
+          _POPPLER_FREE(obj5);
+	  if (_POPPLER_CALL_ARGS_DEREF(obj5, obj4.dictLookup, "K").isBool()) {
 	    knockout = obj5.getBool();
 	  }
-#if !defined(POPPLER_NEW_OBJECT_API)
-	  obj5.free();
-#endif
+	  _POPPLER_FREE(obj5);
 	  if (!haveBackdropColor) {
 	    if (blendingColorSpace) {
 	      blendingColorSpace->getDefaultColor(&backdropColor);
@@ -1030,24 +907,18 @@
 	} else {
 	  error(errSyntaxError, getPos(), "Invalid soft mask in ExtGState - missing group");
 	}
-#if !defined(POPPLER_NEW_OBJECT_API)
-	obj4.free();
-#endif
+	_POPPLER_FREE(obj4);
       } else {
 	error(errSyntaxError, getPos(), "Invalid soft mask in ExtGState - missing group");
       }
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj3.free();
-#endif
+      _POPPLER_FREE(obj3);
     } else if (!obj2.isNull()) {
       error(errSyntaxError, getPos(), "Invalid soft mask in ExtGState");
     }
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj2.free();
+  _POPPLER_FREE(obj2);
 
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 }
 
 void PdfParser::doSoftMask(Object *str, GBool alpha,
@@ -1068,80 +939,44 @@
   dict = str->streamGetDict();
 
   // check form type
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj1 = dict->lookup(const_cast<char*>("FormType"));
-#else
-  dict->lookup(const_cast<char*>("FormType"), &obj1);
-#endif
+  _POPPLER_CALL_ARGS(obj1, dict->lookup, "FormType");
   if (!(obj1.isNull() || (obj1.isInt() && obj1.getInt() == 1))) {
     error(errSyntaxError, getPos(), "Unknown form type");
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 
   // get bounding box
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj1 = dict->lookup(const_cast<char*>("BBox"));
-#else
-  dict->lookup(const_cast<char*>("BBox"), &obj1);
-#endif
+  _POPPLER_CALL_ARGS(obj1, dict->lookup, "BBox");
   if (!obj1.isArray()) {
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
     error(errSyntaxError, getPos(), "Bad form bounding box");
     return;
   }
   for (i = 0; i < 4; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj2 = obj1.arrayGet(i);
-#else
-    obj1.arrayGet(i, &obj2);
-#endif
+    _POPPLER_CALL_ARGS(obj2, obj1.arrayGet, i);
     bbox[i] = obj2.getNum();
-#if defined(POPPLER_NEW_OBJECT_API)
-  }
-#else
-    obj2.free();
+    _POPPLER_FREE(obj2);
   }
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 
   // get matrix
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj1 = dict->lookup(const_cast<char*>("Matrix"));
-#else
-  dict->lookup(const_cast<char*>("Matrix"), &obj1);
-#endif
+  _POPPLER_CALL_ARGS(obj1, dict->lookup, "Matrix");
   if (obj1.isArray()) {
     for (i = 0; i < 6; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      obj2 = obj1.arrayGet(i);
-#else
-      obj1.arrayGet(i, &obj2);
-#endif
+      _POPPLER_CALL_ARGS(obj2, obj1.arrayGet, i);
       m[i] = obj2.getNum();
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj2.free();
-#endif
+      _POPPLER_FREE(obj2);
     }
   } else {
     m[0] = 1; m[1] = 0;
     m[2] = 0; m[3] = 1;
     m[4] = 0; m[5] = 0;
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 
   // get resources
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj1 = dict->lookup(const_cast<char*>("Resources"));
-#else
-  dict->lookup(const_cast<char*>("Resources"), &obj1);
-#endif
-  resDict = obj1.isDict() ? obj1.getDict() : (Dict *)NULL;
+  _POPPLER_CALL_ARGS(obj1, dict->lookup, "Resources");
+  resDict = obj1.isDict() ? obj1.getDict() : (Dict *)nullptr;
 
   // draw it
   ++formDepth;
@@ -1153,9 +988,7 @@
   if (blendingColorSpace) {
     delete blendingColorSpace;
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 }
 
 void PdfParser::opSetRenderingIntent(Object /*args*/[], int /*numArgs*/)
@@ -1171,7 +1004,7 @@
 {
   GfxColor color;
 
-  state->setFillPattern(NULL);
+  state->setFillPattern(nullptr);
   state->setFillColorSpace(new GfxDeviceGrayColorSpace());
   color.c[0] = dblToCol(args[0].getNum());
   state->setFillColor(&color);
@@ -1183,7 +1016,7 @@
 {
   GfxColor color;
 
-  state->setStrokePattern(NULL);
+  state->setStrokePattern(nullptr);
   state->setStrokeColorSpace(new GfxDeviceGrayColorSpace());
   color.c[0] = dblToCol(args[0].getNum());
   state->setStrokeColor(&color);
@@ -1196,7 +1029,7 @@
   GfxColor color;
   int i;
 
-  state->setFillPattern(NULL);
+  state->setFillPattern(nullptr);
   state->setFillColorSpace(new GfxDeviceCMYKColorSpace());
   for (i = 0; i < 4; ++i) {
     color.c[i] = dblToCol(args[i].getNum());
@@ -1210,7 +1043,7 @@
 {
   GfxColor color;
 
-  state->setStrokePattern(NULL);
+  state->setStrokePattern(nullptr);
   state->setStrokeColorSpace(new GfxDeviceCMYKColorSpace());
   for (int i = 0; i < 4; ++i) {
     color.c[i] = dblToCol(args[i].getNum());
@@ -1224,7 +1057,7 @@
 {
   GfxColor color;
 
-  state->setFillPattern(NULL);
+  state->setFillPattern(nullptr);
   state->setFillColorSpace(new GfxDeviceRGBColorSpace());
   for (int i = 0; i < 3; ++i) {
     color.c[i] = dblToCol(args[i].getNum());
@@ -1237,7 +1070,7 @@
 void PdfParser::opSetStrokeRGBColor(Object args[], int /*numArgs*/) {
   GfxColor color;
 
-  state->setStrokePattern(NULL);
+  state->setStrokePattern(nullptr);
   state->setStrokeColorSpace(new GfxDeviceRGBColorSpace());
   for (int i = 0; i < 3; ++i) {
     color.c[i] = dblToCol(args[i].getNum());
@@ -1251,19 +1084,15 @@
 {
   Object obj;
 
-  state->setFillPattern(NULL);
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj = res->lookupColorSpace(args[0].getName());
-#else
-  res->lookupColorSpace(args[0].getName(), &obj);
-#endif
+  state->setFillPattern(nullptr);
+  _POPPLER_CALL_ARGS(obj, res->lookupColorSpace, args[0].getName());
 
-  GfxColorSpace *colorSpace = 0;
+  GfxColorSpace *colorSpace = nullptr;
 #if defined(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API)
   if (obj.isNull()) {
-    colorSpace = GfxColorSpace::parse(NULL, &args[0], NULL, NULL);
+    colorSpace = GfxColorSpace::parse(nullptr, &args[0], nullptr, nullptr);
   } else {
-    colorSpace = GfxColorSpace::parse(NULL, &obj, NULL, NULL);
+    colorSpace = GfxColorSpace::parse(nullptr, &obj, nullptr, nullptr);
   }
 #elif defined(POPPLER_EVEN_NEWER_COLOR_SPACE_API)
   if (obj.isNull()) {
@@ -1278,9 +1107,7 @@
     colorSpace = GfxColorSpace::parse(&obj, NULL);
   }
 #endif
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj.free();
-#endif
+  _POPPLER_FREE(obj);
   if (colorSpace) {
   GfxColor color;
     state->setFillColorSpace(colorSpace);
@@ -1296,19 +1123,15 @@
 void PdfParser::opSetStrokeColorSpace(Object args[], int /*numArgs*/)
 {
   Object obj;
-  GfxColorSpace *colorSpace = 0;
+  GfxColorSpace *colorSpace = nullptr;
 
-  state->setStrokePattern(NULL);
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj = res->lookupColorSpace(args[0].getName());
-#else
-  res->lookupColorSpace(args[0].getName(), &obj);
-#endif
+  state->setStrokePattern(nullptr);
+  _POPPLER_CALL_ARGS(obj, res->lookupColorSpace, args[0].getName());
 #if defined(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API)
   if (obj.isNull()) {
-    colorSpace = GfxColorSpace::parse(NULL, &args[0], NULL, NULL);
+    colorSpace = GfxColorSpace::parse(nullptr, &args[0], nullptr, nullptr);
   } else {
-    colorSpace = GfxColorSpace::parse(NULL, &obj, NULL, NULL);
+    colorSpace = GfxColorSpace::parse(nullptr, &obj, nullptr, nullptr);
   }
 #elif defined(POPPLER_EVEN_NEWER_COLOR_SPACE_API)
   if (obj.isNull()) {
@@ -1323,9 +1146,7 @@
     colorSpace = GfxColorSpace::parse(&obj, NULL);
   }
 #endif
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj.free();
-#endif
+  _POPPLER_FREE(obj);
   if (colorSpace) {
     GfxColor color;
     state->setStrokeColorSpace(colorSpace);
@@ -1345,7 +1166,7 @@
     error(errSyntaxError, getPos(), "Incorrect number of arguments in 'sc' command");
     return;
   }
-  state->setFillPattern(NULL);
+  state->setFillPattern(nullptr);
   for (i = 0; i < numArgs; ++i) {
     color.c[i] = dblToCol(args[i].getNum());
   }
@@ -1361,7 +1182,7 @@
     error(errSyntaxError, getPos(), "Incorrect number of arguments in 'SC' command");
     return;
   }
-  state->setStrokePattern(NULL);
+  state->setStrokePattern(nullptr);
   for (i = 0; i < numArgs; ++i) {
     color.c[i] = dblToCol(args[i].getNum());
   }
@@ -1392,7 +1213,7 @@
     GfxPattern *pattern;
 #if defined(POPPLER_EVEN_NEWER_COLOR_SPACE_API)
     if (args[numArgs-1].isName() &&
-	(pattern = res->lookupPattern(args[numArgs-1].getName(), NULL, NULL))) {
+	(pattern = res->lookupPattern(args[numArgs-1].getName(), nullptr, nullptr))) {
       state->setFillPattern(pattern);
       builder->updateStyle(state);
     }
@@ -1409,7 +1230,7 @@
       error(errSyntaxError, getPos(), "Incorrect number of arguments in 'scn' command");
       return;
     }
-    state->setFillPattern(NULL);
+    state->setFillPattern(nullptr);
     for (i = 0; i < numArgs && i < gfxColorMaxComps; ++i) {
       if (args[i].isNum()) {
 	color.c[i] = dblToCol(args[i].getNum());
@@ -1444,7 +1265,7 @@
     GfxPattern *pattern;
 #if defined(POPPLER_EVEN_NEWER_COLOR_SPACE_API)
     if (args[numArgs-1].isName() &&
-	(pattern = res->lookupPattern(args[numArgs-1].getName(), NULL, NULL))) {
+	(pattern = res->lookupPattern(args[numArgs-1].getName(), nullptr, nullptr))) {
       state->setStrokePattern(pattern);
       builder->updateStyle(state);
     }
@@ -1461,7 +1282,7 @@
       error(errSyntaxError, getPos(), "Incorrect number of arguments in 'SCN' command");
       return;
     }
-    state->setStrokePattern(NULL);
+    state->setStrokePattern(nullptr);
     for (i = 0; i < numArgs && i < gfxColorMaxComps; ++i) {
       if (args[i].isNum()) {
 	color.c[i] = dblToCol(args[i].getNum());
@@ -1752,7 +1573,7 @@
                                              GBool stroke, GBool eoFill) {
   GfxShading *shading;
   GfxPath *savedPath;
-  double *ctm, *btm, *ptm;
+  const double *ctm, *btm, *ptm;
   double m[6], ictm[6], m1[6];
   double xMin, yMin, xMax, yMax;
   double det;
@@ -1764,7 +1585,7 @@
   saveState();
 
   // clip to bbox
-  if (0 ){//shading->getHasBBox()) {
+  if (false ){//shading->getHasBBox()) {
     shading->getBBox(&xMin, &yMin, &xMax, &yMax);
     state->moveTo(xMin, yMin);
     state->lineTo(xMax, yMin);
@@ -1857,16 +1678,16 @@
 // TODO not good that numArgs is ignored but args[] is used:
 void PdfParser::opShFill(Object args[], int /*numArgs*/)
 {
-  GfxShading *shading = 0;
-  GfxPath *savedPath = NULL;
+  GfxShading *shading = nullptr;
+  GfxPath *savedPath = nullptr;
   double xMin, yMin, xMax, yMax;
   double xTemp, yTemp;
   double gradientTransform[6];
-  double *matrix = NULL;
+  double *matrix = nullptr;
   GBool savedState = gFalse;
 
 #if defined(POPPLER_EVEN_NEWER_COLOR_SPACE_API)
-  if (!(shading = res->lookupShading(args[0].getName(), NULL, NULL))) {
+  if (!(shading = res->lookupShading(args[0].getName(), nullptr, nullptr))) {
     return;
   }
 #else
@@ -1884,7 +1705,7 @@
       // check proper operator sequence
       // first there should be one W(*) and then one 'cm' somewhere before 'sh'
       GBool seenClip, seenConcat;
-      seenClip = (clipHistory->getClipPath() != NULL);
+      seenClip = (clipHistory->getClipPath() != nullptr);
       seenConcat = gFalse;
       int i = 1;
       while (i <= maxOperatorHistoryDepth) {
@@ -1910,7 +1731,7 @@
   // clip to bbox
   if (shading->getHasBBox()) {
     shading->getBBox(&xMin, &yMin, &xMax, &yMax);
-    if (matrix != NULL) {
+    if (matrix != nullptr) {
         xTemp = matrix[0]*xMin + matrix[2]*yMin + matrix[4];
         yTemp = matrix[1]*xMin + matrix[3]*yMin + matrix[5];
         state->moveTo(xTemp, yTemp);
@@ -1994,7 +1815,7 @@
   GfxColor color0M, color1M, colorM0, colorM1, colorMM;
   GfxColor colors2[4];
   double functionColorDelta = colorDeltas[pdfFunctionShading-1];
-  double *matrix;
+  const double *matrix;
   double xM, yM;
   int nComps, i, j;
 
@@ -2174,7 +1995,7 @@
   }
 }
 
-void PdfParser::fillPatch(GfxPatch *patch, int nComps, int depth) {
+void PdfParser::fillPatch(_POPPLER_CONST GfxPatch *patch, int nComps, int depth) {
   GfxPatch patch00 = blankPatch();
   GfxPatch patch01 = blankPatch();
   GfxPatch patch10 = blankPatch();
@@ -2189,13 +2010,13 @@
   int i;
 
   for (i = 0; i < nComps; ++i) {
-    if (abs(patch->color[0][0].c[i] - patch->color[0][1].c[i])
+    if (std::abs(patch->color[0][0].c[i] - patch->color[0][1].c[i])
 	  > patchColorDelta ||
-	abs(patch->color[0][1].c[i] - patch->color[1][1].c[i])
+	std::abs(patch->color[0][1].c[i] - patch->color[1][1].c[i])
 	  > patchColorDelta ||
-	abs(patch->color[1][1].c[i] - patch->color[1][0].c[i])
+	std::abs(patch->color[1][1].c[i] - patch->color[1][0].c[i])
 	  > patchColorDelta ||
-	abs(patch->color[1][0].c[i] - patch->color[0][0].c[i])
+	std::abs(patch->color[1][0].c[i] - patch->color[0][0].c[i])
 	  > patchColorDelta) {
       break;
     }
@@ -2375,7 +2196,7 @@
   if (!font) {
     // unsetting the font (drawing no text) is better than using the
     // previous one and drawing random glyphs from it
-    state->setFont(NULL, args[1].getNum());
+    state->setFont(nullptr, args[1].getNum());
     fontChanged = gTrue;
     return;
   }
@@ -2540,7 +2361,7 @@
 // TODO not good that numArgs is ignored but args[] is used:
 void PdfParser::opShowSpaceText(Object args[], int /*numArgs*/)
 {
-  Array *a = 0;
+  Array *a = nullptr;
   Object obj;
   int wMode = 0;
 
@@ -2555,11 +2376,7 @@
   wMode = state->getFont()->getWMode();
   a = args[0].getArray();
   for (int i = 0; i < a->getLength(); ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj = a->get(i);
-#else
-    a->get(i, &obj);
-#endif
+    _POPPLER_CALL_ARGS(obj, a->get, i);
     if (obj.isNum()) {
       // this uses the absolute value of the font size to match
       // Acrobat's behavior
@@ -2576,35 +2393,41 @@
     } else {
       error(errSyntaxError, getPos(), "Element of show/space array must be number or string");
     }
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj.free();
-#endif
+    _POPPLER_FREE(obj);
   }
 }
 
+#if POPPLER_CHECK_VERSION(0,64,0)
+void PdfParser::doShowText(const GooString *s) {
+#else
 void PdfParser::doShowText(GooString *s) {
+#endif
   GfxFont *font;
   int wMode;
   double riseX, riseY;
   CharCode code;
-  Unicode *u = NULL;
+  Unicode *u = nullptr;
   double x, y, dx, dy, tdx, tdy;
   double originX, originY, tOriginX, tOriginY;
   double oldCTM[6], newCTM[6];
-  double *mat;
+  const double *mat;
   Object charProc;
   Dict *resDict;
   Parser *oldParser;
+#if POPPLER_CHECK_VERSION(0,64,0)
+  const char *p;
+#else
   char *p;
+#endif
   int len, n, uLen;
 
   font = state->getFont();
   wMode = font->getWMode();
 
-  builder->beginString(state, s);
+  builder->beginString(state);
 
   // handle a Type 3 char
-  if (font->getType() == fontType3 && 0) {//out->interpretType3Chars()) {
+  if (font->getType() == fontType3 && false) {//out->interpretType3Chars()) {
     mat = state->getCTM();
     for (int i = 0; i < 6; ++i) {
       oldCTM[i] = mat[i];
@@ -2649,13 +2472,9 @@
       state->setCTM(newCTM[0], newCTM[1], newCTM[2], newCTM[3], x, y);
       //~ the CTM concat values here are wrong (but never used)
       //out->updateCTM(state, 1, 0, 0, 1, 0, 0);
-      if (0){ /*!out->beginType3Char(state, curX + riseX, curY + riseY, tdx, tdy,
+      if (false){ /*!out->beginType3Char(state, curX + riseX, curY + riseY, tdx, tdy,
 			       code, u, uLen)) {*/
-#if defined(POPPLER_NEW_OBJECT_API)
-	charProc = ((Gfx8BitFont *)font)->getCharProc(code);
-#else
-	((Gfx8BitFont *)font)->getCharProc(code, &charProc);
-#endif
+        _POPPLER_CALL_ARGS(charProc, ((Gfx8BitFont *)font)->getCharProc, code);
 	if ((resDict = ((Gfx8BitFont *)font)->getResources())) {
 	  pushResources(resDict);
 	}
@@ -2668,9 +2487,7 @@
 	if (resDict) {
 	  popResources();
 	}
-#if !defined(POPPLER_NEW_OBJECT_API)
-	charProc.free();
-#endif
+	_POPPLER_FREE(charProc);
       }
       restoreState();
       // GfxState::restore() does *not* restore the current position,
@@ -2732,44 +2549,29 @@
 {
   Object obj1, obj2, obj3, refObj;
 
-  char *name = args[0].getName();
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj1 = res->lookupXObject(name)).isNull()) {
+#if POPPLER_CHECK_VERSION(0,64,0)
+  const char *name = args[0].getName();
 #else
-  if (!res->lookupXObject(name, &obj1)) {
+  char *name = args[0].getName();
 #endif
+  _POPPLER_CALL_ARGS(obj1, res->lookupXObject, name);
+  if (obj1.isNull()) {
     return;
   }
   if (!obj1.isStream()) {
     error(errSyntaxError, getPos(), "XObject '{0:s}' is wrong type", name);
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
     return;
   }
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj2 = obj1.streamGetDict()->lookup(const_cast<char*>("Subtype"));
-#else
-  obj1.streamGetDict()->lookup(const_cast<char*>("Subtype"), &obj2);
-#endif
+  _POPPLER_CALL_ARGS(obj2, obj1.streamGetDict()->lookup, "Subtype");
   if (obj2.isName(const_cast<char*>("Image"))) {
-#if defined(POPPLER_NEW_OBJECT_API)
-    refObj = res->lookupXObjectNF(name);
-#else
-    res->lookupXObjectNF(name, &refObj);
-#endif
+    _POPPLER_CALL_ARGS(refObj, res->lookupXObjectNF, name);
     doImage(&refObj, obj1.getStream(), gFalse);
-#if !defined(POPPLER_NEW_OBJECT_API)
-    refObj.free();
-#endif
+    _POPPLER_FREE(refObj);
   } else if (obj2.isName(const_cast<char*>("Form"))) {
     doForm(&obj1);
   } else if (obj2.isName(const_cast<char*>("PS"))) {
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj3 = obj1.streamGetDict()->lookup(const_cast<char*>("Level1"));
-#else
-    obj1.streamGetDict()->lookup(const_cast<char*>("Level1"), &obj3);
-#endif
+    _POPPLER_CALL_ARGS(obj3, obj1.streamGetDict()->lookup, "Level1");
 /*    out->psXObject(obj1.getStream(),
     		   obj3.isStream() ? obj3.getStream() : (Stream *)NULL);*/
   } else if (obj2.isName()) {
@@ -2777,10 +2579,8 @@
   } else {
     error(errSyntaxError, getPos(), "XObject subtype is missing or wrong type");
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj2.free();
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj2);
+  _POPPLER_FREE(obj1);
 }
 
 void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
@@ -2807,18 +2607,10 @@
     dict = str->getDict();
     
     // get size
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj1 = dict->lookup(const_cast<char*>("Width"));
-#else
-    dict->lookup(const_cast<char*>("Width"), &obj1);
-#endif
+    _POPPLER_CALL_ARGS(obj1, dict->lookup, "Width");
     if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("W"));
-#else
-        obj1.free();
-        dict->lookup(const_cast<char*>("W"), &obj1);
-#endif
+        _POPPLER_FREE(obj1);
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "W");
     }
     if (obj1.isInt()){
         width = obj1.getInt();
@@ -2829,19 +2621,11 @@
     else {
         goto err2;
     }
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj1 = dict->lookup(const_cast<char*>("Height"));
-#else
-    obj1.free();
-    dict->lookup(const_cast<char*>("Height"), &obj1);
-#endif
+    _POPPLER_FREE(obj1);
+    _POPPLER_CALL_ARGS(obj1, dict->lookup, "Height");
     if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("H"));
-#else
-        obj1.free();
-        dict->lookup(const_cast<char*>("H"), &obj1);
-#endif
+        _POPPLER_FREE(obj1);
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "H");
     }
     if (obj1.isInt()) {
         height = obj1.getInt();
@@ -2852,46 +2636,26 @@
     else {
         goto err2;
     }
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
     
     // image interpolation
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj1 = dict->lookup("Interpolate");
-#else
-    dict->lookup("Interpolate", &obj1);
-#endif
+    _POPPLER_CALL_ARGS(obj1, dict->lookup, "Interpolate");
     if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      obj1 = dict->lookup("I");
-#else
-      obj1.free();
-      dict->lookup("I", &obj1);
-#endif
+      _POPPLER_FREE(obj1);
+      _POPPLER_CALL_ARGS(obj1, dict->lookup, "I");
     }
     if (obj1.isBool())
       interpolate = obj1.getBool();
     else
       interpolate = gFalse;
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
     maskInterpolate = gFalse;
 
     // image or mask?
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj1 = dict->lookup(const_cast<char*>("ImageMask"));
-#else
-    dict->lookup(const_cast<char*>("ImageMask"), &obj1);
-#endif
+    _POPPLER_CALL_ARGS(obj1, dict->lookup, "ImageMask");
     if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("IM"));
-#else
-        obj1.free();
-        dict->lookup(const_cast<char*>("IM"), &obj1);
-#endif
+        _POPPLER_FREE(obj1);
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "IM");
     }
     mask = gFalse;
     if (obj1.isBool()) {
@@ -2900,24 +2664,14 @@
     else if (!obj1.isNull()) {
         goto err2;
     }
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
     
     // bit depth
     if (bits == 0) {
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("BitsPerComponent"));
-#else
-        dict->lookup(const_cast<char*>("BitsPerComponent"), &obj1);
-#endif
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "BitsPerComponent");
         if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = dict->lookup(const_cast<char*>("BPC"));
-#else
-            obj1.free();
-            dict->lookup(const_cast<char*>("BPC"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, dict->lookup, "BPC");
         }
         if (obj1.isInt()) {
             bits = obj1.getInt();
@@ -2926,9 +2680,7 @@
         } else {
             goto err2;
         }
-#if !defined(POPPLER_NEW_OBJECT_API)
-        obj1.free();
-#endif
+        _POPPLER_FREE(obj1);
     }
     
     // display a mask
@@ -2938,37 +2690,21 @@
             goto err1;
         }
         invert = gFalse;
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("Decode"));
-#else
-        dict->lookup(const_cast<char*>("Decode"), &obj1);
-#endif
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "Decode");
         if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = dict->lookup(const_cast<char*>("D"));
-#else
-            obj1.free();
-            dict->lookup(const_cast<char*>("D"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, dict->lookup, "D");
         }
         if (obj1.isArray()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj2 = obj1.arrayGet(0);
-#else
-            obj1.arrayGet(0, &obj2);
-#endif
+            _POPPLER_CALL_ARGS(obj2, obj1.arrayGet, 0);
             if (obj2.isInt() && obj2.getInt() == 1) {
                 invert = gTrue;
             }
-#if !defined(POPPLER_NEW_OBJECT_API)
-            obj2.free();
-#endif
+            _POPPLER_FREE(obj2);
         } else if (!obj1.isNull()) {
             goto err2;
         }
-#if !defined(POPPLER_NEW_OBJECT_API)
-        obj1.free();
-#endif
+        _POPPLER_FREE(obj1);
         
         // draw it
         builder->addImageMask(state, str, width, height, invert, interpolate);
@@ -2976,41 +2712,23 @@
     } else {
         // get color space and color map
         GfxColorSpace *colorSpace;
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("ColorSpace"));
-#else
-        dict->lookup(const_cast<char*>("ColorSpace"), &obj1);
-#endif
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "ColorSpace");
         if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = dict->lookup(const_cast<char*>("CS"));
-#else
-            obj1.free();
-            dict->lookup(const_cast<char*>("CS"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, dict->lookup, "CS");
         }
         if (obj1.isName()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj2 = res->lookupColorSpace(obj1.getName());
-#else
-            res->lookupColorSpace(obj1.getName(), &obj2);
-#endif
+            _POPPLER_CALL_ARGS(obj2, res->lookupColorSpace, obj1.getName());
             if (!obj2.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
+	            _POPPLER_FREE(obj1);
                     obj1 = std::move(obj2);
-#else
-	            obj1.free();
-	            obj1 = obj2;
-#endif
             } else {
-#if !defined(POPPLER_NEW_OBJECT_API)
-	            obj2.free();
-#endif
+	            _POPPLER_FREE(obj2);
             }
         }
         if (!obj1.isNull()) {
 #if defined(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API)
-            colorSpace = GfxColorSpace::parse(NULL, &obj1, NULL, NULL);
+            colorSpace = GfxColorSpace::parse(nullptr, &obj1, nullptr, nullptr);
 #elif defined(POPPLER_EVEN_NEWER_COLOR_SPACE_API)
             colorSpace = GfxColorSpace::parse(&obj1, NULL, NULL);
 #else
@@ -3023,31 +2741,19 @@
         } else if (csMode == streamCSDeviceCMYK) {
             colorSpace = new GfxDeviceCMYKColorSpace();
         } else {
-            colorSpace = NULL;
+            colorSpace = nullptr;
         }
-#if !defined(POPPLER_NEW_OBJECT_API)
-        obj1.free();
-#endif
+        _POPPLER_FREE(obj1);
         if (!colorSpace) {
             goto err1;
         }
-#if defined(POPPLER_NEW_OBJECT_API)
-        obj1 = dict->lookup(const_cast<char*>("Decode"));
-#else
-        dict->lookup(const_cast<char*>("Decode"), &obj1);
-#endif
+        _POPPLER_CALL_ARGS(obj1, dict->lookup, "Decode");
         if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = dict->lookup(const_cast<char*>("D"));
-#else
-            obj1.free();
-            dict->lookup(const_cast<char*>("D"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, dict->lookup, "D");
         }
         GfxImageColorMap *colorMap = new GfxImageColorMap(bits, &obj1, colorSpace);
-#if !defined(POPPLER_NEW_OBJECT_API)
-        obj1.free();
-#endif
+        _POPPLER_FREE(obj1);
         if (!colorMap->isOk()) {
             delete colorMap;
             goto err1;
@@ -3056,18 +2762,13 @@
         // get the mask
         int maskColors[2*gfxColorMaxComps];
         haveColorKeyMask = haveExplicitMask = haveSoftMask = gFalse;
-        Stream *maskStr = NULL;
+        Stream *maskStr = nullptr;
         int maskWidth = 0;
         int maskHeight = 0;
         maskInvert = gFalse;
-        GfxImageColorMap *maskColorMap = NULL;
-#if defined(POPPLER_NEW_OBJECT_API)
-        maskObj = dict->lookup(const_cast<char*>("Mask"));
-        smaskObj = dict->lookup(const_cast<char*>("SMask"));
-#else
-        dict->lookup(const_cast<char*>("Mask"), &maskObj);
-        dict->lookup(const_cast<char*>("SMask"), &smaskObj);
-#endif
+        GfxImageColorMap *maskColorMap = nullptr;
+        _POPPLER_CALL_ARGS(maskObj, dict->lookup, "Mask");
+        _POPPLER_CALL_ARGS(smaskObj, dict->lookup, "SMask");
         Dict* maskDict;
         if (smaskObj.isStream()) {
             // soft mask
@@ -3076,140 +2777,78 @@
             }
             maskStr = smaskObj.getStream();
             maskDict = smaskObj.streamGetDict();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Width"));
-#else
-            maskDict->lookup(const_cast<char*>("Width"), &obj1);
-#endif
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Width");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-	            obj1 = maskDict->lookup(const_cast<char*>("W"));
-#else
-        	    obj1.free();
-	            maskDict->lookup(const_cast<char*>("W"), &obj1);
-#endif
+                    _POPPLER_FREE(obj1);
+	            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "W");
             }
             if (!obj1.isInt()) {
 	            goto err2;
             }
             maskWidth = obj1.getInt();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Height"));
-#else
-            obj1.free();
-            maskDict->lookup(const_cast<char*>("Height"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Height");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                    obj1 = maskDict->lookup(const_cast<char*>("H"));
-#else
-	            obj1.free();
-	            maskDict->lookup(const_cast<char*>("H"), &obj1);
-#endif
+	            _POPPLER_FREE(obj1);
+                    _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "H");
             }
             if (!obj1.isInt()) {
 	            goto err2;
             }
             maskHeight = obj1.getInt();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("BitsPerComponent"));
-#else
-            obj1.free();
-            maskDict->lookup(const_cast<char*>("BitsPerComponent"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "BitsPerComponent");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                    obj1 = maskDict->lookup(const_cast<char*>("BPC"));
-#else
-        	    obj1.free();
-	            maskDict->lookup(const_cast<char*>("BPC"), &obj1);
-#endif
+                    _POPPLER_FREE(obj1);
+                    _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "BPC");
             }
             if (!obj1.isInt()) {
 	            goto err2;
             }
             int maskBits = obj1.getInt();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Interpolate"));
-#else
-            obj1.free();
-	    maskDict->lookup("Interpolate", &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Interpolate");
 	    if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-              obj1 = maskDict->lookup(const_cast<char*>("I"));
-#else
-	      obj1.free();
-	      maskDict->lookup("I", &obj1);
-#endif
+	      _POPPLER_FREE(obj1);
+              _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "I");
 	    }
 	    if (obj1.isBool())
 	      maskInterpolate = obj1.getBool();
 	    else
 	      maskInterpolate = gFalse;
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("ColorSpace"));
-#else
-	    obj1.free();
-            maskDict->lookup(const_cast<char*>("ColorSpace"), &obj1);
-#endif
+	    _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "ColorSpace");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                    obj1 = maskDict->lookup(const_cast<char*>("CS"));
-#else
-	            obj1.free();
-	            maskDict->lookup(const_cast<char*>("CS"), &obj1);
-#endif
+	            _POPPLER_FREE(obj1);
+                    _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "CS");
             }
             if (obj1.isName()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-	            obj2 = res->lookupColorSpace(obj1.getName());
-#else
-	            res->lookupColorSpace(obj1.getName(), &obj2);
-#endif
+	            _POPPLER_CALL_ARGS(obj2, res->lookupColorSpace, obj1.getName());
 	            if (!obj2.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
+	                _POPPLER_FREE(obj1);
                         obj1 = std::move(obj2);
-#else
-	                obj1.free();
-    	            obj1 = obj2;
-#endif
 	            } else {
-#if !defined(POPPLER_NEW_OBJECT_API)
-	                obj2.free();
-#endif
+	                _POPPLER_FREE(obj2);
 	            }
             }
 #if defined(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API)
-            GfxColorSpace *maskColorSpace = GfxColorSpace::parse(NULL, &obj1, NULL, NULL);
+            GfxColorSpace *maskColorSpace = GfxColorSpace::parse(nullptr, &obj1, nullptr, nullptr);
 #elif defined(POPPLER_EVEN_NEWER_COLOR_SPACE_API)
             GfxColorSpace *maskColorSpace = GfxColorSpace::parse(&obj1, NULL, NULL);
 #else
             GfxColorSpace *maskColorSpace = GfxColorSpace::parse(&obj1, NULL);
 #endif
-#if !defined(POPPLER_NEW_OBJECT_API)
-            obj1.free();
-#endif
+            _POPPLER_FREE(obj1);
             if (!maskColorSpace || maskColorSpace->getMode() != csDeviceGray) {
                 goto err1;
             }
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Decode"));
-#else
-            maskDict->lookup(const_cast<char*>("Decode"), &obj1);
-#endif
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Decode");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj1 = maskDict->lookup(const_cast<char*>("D"));
-#else
-	            obj1.free();
-    	        maskDict->lookup(const_cast<char*>("D"), &obj1);
-#endif
+                _POPPLER_FREE(obj1);
+                _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "D");
             }
             maskColorMap = new GfxImageColorMap(maskBits, &obj1, maskColorSpace);
-#if !defined(POPPLER_NEW_OBJECT_API)
-            obj1.free();
-#endif
+            _POPPLER_FREE(obj1);
             if (!maskColorMap->isOk()) {
                 delete maskColorMap;
                 goto err1;
@@ -3220,15 +2859,9 @@
             // color key mask
             int i;
             for (i = 0; i < maskObj.arrayGetLength() && i < 2*gfxColorMaxComps; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj1 = maskObj.arrayGet(i);
-#else
-                maskObj.arrayGet(i, &obj1);
-#endif
+                _POPPLER_CALL_ARGS(obj1, maskObj.arrayGet, i);
                 maskColors[i] = obj1.getInt();
-#if !defined(POPPLER_NEW_OBJECT_API)
-                obj1.free();
-#endif
+                _POPPLER_FREE(obj1);
             }
               haveColorKeyMask = gTrue;
         } else if (maskObj.isStream()) {
@@ -3238,111 +2871,61 @@
             }
             maskStr = maskObj.getStream();
             maskDict = maskObj.streamGetDict();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Width"));
-#else
-            maskDict->lookup(const_cast<char*>("Width"), &obj1);
-#endif
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Width");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj1 = maskDict->lookup(const_cast<char*>("W"));
-#else
-                obj1.free();
-                maskDict->lookup(const_cast<char*>("W"), &obj1);
-#endif
+                _POPPLER_FREE(obj1);
+                _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "W");
             }
             if (!obj1.isInt()) {
                 goto err2;
             }
             maskWidth = obj1.getInt();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Height"));
-#else
-            obj1.free();
-            maskDict->lookup(const_cast<char*>("Height"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Height");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj1 = maskDict->lookup(const_cast<char*>("H"));
-#else
-                obj1.free();
-                maskDict->lookup(const_cast<char*>("H"), &obj1);
-#endif
+                _POPPLER_FREE(obj1);
+                _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "H");
             }
             if (!obj1.isInt()) {
                 goto err2;
             }
             maskHeight = obj1.getInt();
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("ImageMask"));
-#else
-            obj1.free();
-            maskDict->lookup(const_cast<char*>("ImageMask"), &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "ImageMask");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj1 = maskDict->lookup(const_cast<char*>("IM"));
-#else
-                obj1.free();
-                maskDict->lookup(const_cast<char*>("IM"), &obj1);
-#endif
+                _POPPLER_FREE(obj1);
+                _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "IM");
             }
             if (!obj1.isBool() || !obj1.getBool()) {
                 goto err2;
             }
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup("Interpolate");
-#else
-            obj1.free();
-	    maskDict->lookup("Interpolate", &obj1);
-#endif
+            _POPPLER_FREE(obj1);
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Interpolate");
 	    if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-	      obj1 = maskDict->lookup("I");
-#else
-	      obj1.free();
-	      maskDict->lookup("I", &obj1);
-#endif
+	      _POPPLER_FREE(obj1);
+	      _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "I");
 	    }
 	    if (obj1.isBool())
 	      maskInterpolate = obj1.getBool();
 	    else
 	      maskInterpolate = gFalse;
-#if !defined(POPPLER_NEW_OBJECT_API)
-	    obj1.free();
-#endif
+	    _POPPLER_FREE(obj1);
             maskInvert = gFalse;
-#if defined(POPPLER_NEW_OBJECT_API)
-            obj1 = maskDict->lookup(const_cast<char*>("Decode"));
-#else
-            maskDict->lookup(const_cast<char*>("Decode"), &obj1);
-#endif
+            _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "Decode");
             if (obj1.isNull()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj1 = maskDict->lookup(const_cast<char*>("D"));
-#else
-                obj1.free();
-                maskDict->lookup(const_cast<char*>("D"), &obj1);
-#endif
+                _POPPLER_FREE(obj1);
+                _POPPLER_CALL_ARGS(obj1, maskDict->lookup, "D");
             }
             if (obj1.isArray()) {
-#if defined(POPPLER_NEW_OBJECT_API)
-                obj2 = obj1.arrayGet(0);
-#else
-                obj1.arrayGet(0, &obj2);
-#endif
+                _POPPLER_CALL_ARGS(obj2, obj1.arrayGet, 0);
                 if (obj2.isInt() && obj2.getInt() == 1) {
                     maskInvert = gTrue;
                 }
-#if !defined(POPPLER_NEW_OBJECT_API)
-                obj2.free();
-#endif
+                _POPPLER_FREE(obj2);
             } else if (!obj1.isNull()) {
                 goto err2;
             }
-#if !defined(POPPLER_NEW_OBJECT_API)
-            obj1.free();
-#endif
+            _POPPLER_FREE(obj1);
             haveExplicitMask = gTrue;
         }
         
@@ -3356,22 +2939,18 @@
 				maskStr, maskWidth, maskHeight, maskInvert, maskInterpolate);
         } else {
 	    builder->addImage(state, str, width, height, colorMap, interpolate,
-		        haveColorKeyMask ? maskColors : static_cast<int *>(NULL));
+		        haveColorKeyMask ? maskColors : static_cast<int *>(nullptr));
         }
         delete colorMap;
         
-#if !defined(POPPLER_NEW_OBJECT_API)
-        maskObj.free();
-        smaskObj.free();
-#endif
+        _POPPLER_FREE(maskObj);
+        _POPPLER_FREE(smaskObj);
     }
 
     return;
 
  err2:
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj1.free();
-#endif
+    _POPPLER_FREE(obj1);
  err1:
     error(errSyntaxError, getPos(), "Bad image parameters");
 }
@@ -3396,131 +2975,73 @@
   dict = str->streamGetDict();
 
   // check form type
-#if defined(POPPLER_NEW_OBJECT_API)
-  obj1 = dict->lookup(const_cast<char*>("FormType"));
-#else
-  dict->lookup(const_cast<char*>("FormType"), &obj1);
-#endif
+  _POPPLER_CALL_ARGS(obj1, dict->lookup, "FormType");
   if (!(obj1.isNull() || (obj1.isInt() && obj1.getInt() == 1))) {
     error(errSyntaxError, getPos(), "Unknown form type");
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 
   // get bounding box
-#if defined(POPPLER_NEW_OBJECT_API)
-  bboxObj = dict->lookup(const_cast<char*>("BBox"));
-#else
-  dict->lookup(const_cast<char*>("BBox"), &bboxObj);
-#endif
+  _POPPLER_CALL_ARGS(bboxObj, dict->lookup, "BBox");
   if (!bboxObj.isArray()) {
-#if !defined(POPPLER_NEW_OBJECT_API)
-    bboxObj.free();
-#endif
+    _POPPLER_FREE(bboxObj);
     error(errSyntaxError, getPos(), "Bad form bounding box");
     return;
   }
   for (i = 0; i < 4; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-    obj1 = bboxObj.arrayGet(i);
-#else
-    bboxObj.arrayGet(i, &obj1);
-#endif
+    _POPPLER_CALL_ARGS(obj1, bboxObj.arrayGet, i);
     bbox[i] = obj1.getNum();
-#if defined(POPPLER_NEW_OBJECT_API)
+    _POPPLER_FREE(obj1);
   }
-#else
-    obj1.free();
-  }
-  bboxObj.free();
-#endif
+  _POPPLER_FREE(bboxObj);
 
   // get matrix
-#if defined(POPPLER_NEW_OBJECT_API)
-  matrixObj = dict->lookup(const_cast<char*>("Matrix"));
-#else
-  dict->lookup(const_cast<char*>("Matrix"), &matrixObj);
-#endif
+  _POPPLER_CALL_ARGS(matrixObj, dict->lookup, "Matrix");
   if (matrixObj.isArray()) {
     for (i = 0; i < 6; ++i) {
-#if defined(POPPLER_NEW_OBJECT_API)
-      obj1 = matrixObj.arrayGet(i);
-#else
-      matrixObj.arrayGet(i, &obj1);
-#endif
+      _POPPLER_CALL_ARGS(obj1, matrixObj.arrayGet, i);
       m[i] = obj1.getNum();
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj1.free();
-#endif
+      _POPPLER_FREE(obj1);
     }
   } else {
     m[0] = 1; m[1] = 0;
     m[2] = 0; m[3] = 1;
     m[4] = 0; m[5] = 0;
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  matrixObj.free();
-#endif
+  _POPPLER_FREE(matrixObj);
 
   // get resources
-#if defined(POPPLER_NEW_OBJECT_API)
-  resObj = dict->lookup(const_cast<char*>("Resources"));
-#else
-  dict->lookup(const_cast<char*>("Resources"), &resObj);
-#endif
-  resDict = resObj.isDict() ? resObj.getDict() : (Dict *)NULL;
+  _POPPLER_CALL_ARGS(resObj, dict->lookup, "Resources");
+  resDict = resObj.isDict() ? resObj.getDict() : (Dict *)nullptr;
 
   // check for a transparency group
   transpGroup = isolated = knockout = gFalse;
-  blendingColorSpace = NULL;
-#if defined(POPPLER_NEW_OBJECT_API)
-  if ((obj1 = dict->lookup(const_cast<char*>("Group"))).isDict()) {
-    if ((obj2 = obj1.dictLookup(const_cast<char*>("S"))).isName(const_cast<char*>("Transparency"))) {
-#else
-  if (dict->lookup(const_cast<char*>("Group"), &obj1)->isDict()) {
-    if (obj1.dictLookup(const_cast<char*>("S"), &obj2)->isName(const_cast<char*>("Transparency"))) {
-#endif
+  blendingColorSpace = nullptr;
+  if (_POPPLER_CALL_ARGS_DEREF(obj1, dict->lookup, "Group").isDict()) {
+    if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "S").isName("Transparency")) {
       transpGroup = gTrue;
-#if defined(POPPLER_NEW_OBJECT_API)
-      if (!((obj3 = obj1.dictLookup(const_cast<char*>("CS"))).isNull())) {
-#else
-      if (!obj1.dictLookup(const_cast<char*>("CS"), &obj3)->isNull()) {
-#endif
+      if (!_POPPLER_CALL_ARGS_DEREF(obj3, obj1.dictLookup, "CS").isNull()) {
 #if defined(POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API)
-	blendingColorSpace = GfxColorSpace::parse(NULL, &obj3, NULL, NULL);
+	blendingColorSpace = GfxColorSpace::parse(nullptr, &obj3, nullptr, nullptr);
 #elif defined(POPPLER_EVEN_NEWER_COLOR_SPACE_API)
 	blendingColorSpace = GfxColorSpace::parse(&obj3, NULL, NULL);
 #else
 	blendingColorSpace = GfxColorSpace::parse(&obj3, NULL);
 #endif
       }
-#if defined(POPPLER_NEW_OBJECT_API)
-      if ((obj3 = obj1.dictLookup(const_cast<char*>("I"))).isBool()) {
-#else
-      obj3.free();
-      if (obj1.dictLookup(const_cast<char*>("I"), &obj3)->isBool()) {
-#endif
+      _POPPLER_FREE(obj3);
+      if (_POPPLER_CALL_ARGS_DEREF(obj3, obj1.dictLookup, "I").isBool()) {
 	isolated = obj3.getBool();
       }
-#if defined(POPPLER_NEW_OBJECT_API)
-      if ((obj3 = obj1.dictLookup(const_cast<char*>("K"))).isBool()) {
-#else
-      obj3.free();
-      if (obj1.dictLookup(const_cast<char*>("K"), &obj3)->isBool()) {
-#endif
+      _POPPLER_FREE(obj3);
+      if (_POPPLER_CALL_ARGS_DEREF(obj3, obj1.dictLookup, "K").isBool()) {
 	knockout = obj3.getBool();
       }
-#if defined(POPPLER_NEW_OBJECT_API)
+      _POPPLER_FREE(obj3);
     }
+    _POPPLER_FREE(obj2);
   }
-#else
-      obj3.free();
-    }
-    obj2.free();
-  }
-  obj1.free();
-#endif
+  _POPPLER_FREE(obj1);
 
   // draw it
   ++formDepth;
@@ -3531,9 +3052,7 @@
   if (blendingColorSpace) {
     delete blendingColorSpace;
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  resObj.free();
-#endif
+  _POPPLER_FREE(resObj);
 }
 
 void PdfParser::doForm1(Object *str, Dict *resDict, double *matrix, double *bbox,
@@ -3641,7 +3160,7 @@
 
   // display the image
   if (str) {
-    doImage(NULL, str, gTrue);
+    doImage(nullptr, str, gTrue);
   
     // skip 'EI' tag
     int c1 = str->getUndecodedStream()->getChar();
@@ -3657,56 +3176,39 @@
 Stream *PdfParser::buildImageStream() {
   Object dict;
   Object obj;
-  char *key;
   Stream *str;
 
   // build dictionary
 #if defined(POPPLER_NEW_OBJECT_API)
   dict = Object(new Dict(xref));
-  obj = parser->getObj();
 #else
   dict.initDict(xref);
-  parser->getObj(&obj);
 #endif
+  _POPPLER_CALL(obj, parser->getObj);
   while (!obj.isCmd(const_cast<char*>("ID")) && !obj.isEOF()) {
     if (!obj.isName()) {
       error(errSyntaxError, getPos(), "Inline image dictionary key must be a name object");
-#if !defined(POPPLER_NEW_OBJECT_API)
-      obj.free();
-#endif
+      _POPPLER_FREE(obj);
     } else {
-      key = copyString(obj.getName());
-#if defined(POPPLER_NEW_OBJECT_API)
-      obj = parser->getObj();
-#else
-      obj.free();
-      parser->getObj(&obj);
-#endif
-      if (obj.isEOF() || obj.isError()) {
-	gfree(key);
+      Object obj2;
+      _POPPLER_CALL(obj2, parser->getObj);
+      if (obj2.isEOF() || obj2.isError()) {
+        _POPPLER_FREE(obj);
 	break;
       }
-#if defined(POPPLER_NEW_OBJECT_API)
-      dict.dictAdd(key, std::move(obj));
-    }
-    obj = parser->getObj();
-#else
-      dict.dictAdd(key, &obj);
+      _POPPLER_DICTADD(dict, obj.getName(), obj2);
+      _POPPLER_FREE(obj);
+      _POPPLER_FREE(obj2);
     }
-    parser->getObj(&obj);
-#endif
+    _POPPLER_CALL(obj, parser->getObj);
   }
   if (obj.isEOF()) {
     error(errSyntaxError, getPos(), "End of file in inline image");
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj.free();
-    dict.free();
-#endif
-    return NULL;
+    _POPPLER_FREE(obj);
+    _POPPLER_FREE(dict);
+    return nullptr;
   }
-#if !defined(POPPLER_NEW_OBJECT_API)
-  obj.free();
-#endif
+  _POPPLER_FREE(obj);
 
   // make stream
 #if defined(POPPLER_NEW_OBJECT_API)
@@ -3807,7 +3309,7 @@
   bool is_radial = false;
 
   GfxPattern *pattern = state->getFillPattern();
-  if (pattern != NULL)
+  if (pattern != nullptr)
     if (pattern->getType() == 2 ) {
         GfxShadingPattern *shading_pattern = static_cast<GfxShadingPattern *>(pattern);
         GfxShading *shading = shading_pattern->getShading();
@@ -3862,8 +3364,8 @@
 //------------------------------------------------------------------------
 
 ClipHistoryEntry::ClipHistoryEntry(GfxPath *clipPathA, GfxClipType clipTypeA) :
-  saved(NULL),
-  clipPath((clipPathA) ? clipPathA->copy() : NULL),
+  saved(nullptr),
+  clipPath((clipPathA) ? clipPathA->copy() : nullptr),
   clipType(clipTypeA)
 {
 }
@@ -3872,7 +3374,7 @@
 {
     if (clipPath) {
         delete clipPath;
-	clipPath = NULL;
+	clipPath = nullptr;
     }
 }
 
@@ -3885,7 +3387,7 @@
         clipPath = clipPathA->copy();
         clipType = clipTypeA;
     } else {
-        clipPath = NULL;
+        clipPath = nullptr;
 	clipType = clipNormal;
     }
 }
@@ -3902,7 +3404,7 @@
 
     if (saved) {
         oldEntry = saved;
-        saved = NULL;
+        saved = nullptr;
         delete this; // TODO really should avoid deleting from inside.
     } else {
         oldEntry = this;
@@ -3916,10 +3418,10 @@
         this->clipPath = other->clipPath->copy();
         this->clipType = other->clipType;
     } else {
-        this->clipPath = NULL;
+        this->clipPath = nullptr;
 	this->clipType = clipNormal;
     }
-    saved = NULL;
+    saved = nullptr;
 }
 
 #endif /* HAVE_POPPLER */
diff -Naur inkscape-0.92.3/src/extension/internal/pdfinput/pdf-parser.h inkscape-master/src/extension/internal/pdfinput/pdf-parser.h
--- inkscape-0.92.3/src/extension/internal/pdfinput/pdf-parser.h	2018-03-11 23:38:09.000000000 +0300
+++ inkscape-master/src/extension/internal/pdfinput/pdf-parser.h	2018-10-22 14:51:57.000000000 +0300
@@ -8,7 +8,12 @@
 #ifndef PDF_PARSER_H
 #define PDF_PARSER_H
 
+#ifdef HAVE_CONFIG_H
+# include "config.h"  // only include where actually required!
+#endif
+
 #ifdef HAVE_POPPLER
+#include "poppler-transition-api.h"
 
 #ifdef USE_GCC_PRAGMAS
 #pragma interface
@@ -25,6 +30,7 @@
 // TODO clean up and remove using:
 using Inkscape::Extension::Internal::SvgBuilder;
 
+#include "glib/poppler-features.h"
 #include "goo/gtypes.h"
 #include "Object.h"
 
@@ -127,11 +133,14 @@
 
   // Constructor for regular output.
   PdfParser(XRef *xrefA, SvgBuilder *builderA, int pageNum, int rotate,
-            Dict *resDict, PDFRectangle *box, PDFRectangle *cropBox);
+            Dict *resDict,
+            _POPPLER_CONST PDFRectangle *box,
+            _POPPLER_CONST PDFRectangle *cropBox);
 
   // Constructor for a sub-page object.
   PdfParser(XRef *xrefA, Inkscape::Extension::Internal::SvgBuilder *builderA,
-            Dict *resDict, PDFRectangle *box);
+            Dict *resDict,
+            _POPPLER_CONST PDFRectangle *box);
 
   virtual ~PdfParser();
 
@@ -185,7 +194,7 @@
 
   void go(GBool topLevel);
   void execOp(Object *cmd, Object args[], int numArgs);
-  PdfOperator *findOp(char *name);
+  PdfOperator *findOp(const char *name);
   GBool checkArg(Object *arg, TchkType type);
   int getPos();
 
@@ -256,7 +265,7 @@
 			   double x2, double y2, GfxColor *color2,
 			   int nComps, int depth);
   void doPatchMeshShFill(GfxPatchMeshShading *shading);
-  void fillPatch(GfxPatch *patch, int nComps, int depth);
+  void fillPatch(_POPPLER_CONST GfxPatch *patch, int nComps, int depth);
   void doEndPath();
 
   // path clipping operators
@@ -287,7 +296,12 @@
   void opMoveShowText(Object args[], int numArgs);
   void opMoveSetShowText(Object args[], int numArgs);
   void opShowSpaceText(Object args[], int numArgs);
+#if POPPLER_CHECK_VERSION(0,64,0)
+  void doShowText(const GooString *s);
+#else
   void doShowText(GooString *s);
+#endif
+  
 
   // XObject operators
   void opXObject(Object args[], int numArgs);
@@ -295,10 +309,10 @@
   void doForm(Object *str);
   void doForm1(Object *str, Dict *resDict, double *matrix, double *bbox,
 	       GBool transpGroup = gFalse, GBool softMask = gFalse,
-	       GfxColorSpace *blendingColorSpace = NULL,
+	       GfxColorSpace *blendingColorSpace = nullptr,
 	       GBool isolated = gFalse, GBool knockout = gFalse,
-	       GBool alpha = gFalse, Function *transferFunc = NULL,
-	       GfxColor *backdropColor = NULL);
+	       GBool alpha = gFalse, Function *transferFunc = nullptr,
+	       GfxColor *backdropColor = nullptr);
 
   // in-line image operators
   void opBeginImage(Object args[], int numArgs);
diff -Naur inkscape-0.92.3/src/extension/internal/pdfinput/poppler-transition-api.h inkscape-master/src/extension/internal/pdfinput/poppler-transition-api.h
--- inkscape-0.92.3/src/extension/internal/pdfinput/poppler-transition-api.h	1970-01-01 03:00:00.000000000 +0300
+++ inkscape-master/src/extension/internal/pdfinput/poppler-transition-api.h	2018-10-22 14:51:57.000000000 +0300
@@ -0,0 +1,41 @@
+#ifndef SEEN_POPPLER_TRANSITION_API_H
+#define SEEN_POPPLER_TRANSITION_API_H
+
+#include <glib/poppler-features.h>
+
+#if POPPLER_CHECK_VERSION(0,70,0)
+#define _POPPLER_CONST const
+#else
+#define _POPPLER_CONST
+#endif
+
+#if POPPLER_CHECK_VERSION(0,69,0)
+#define _POPPLER_DICTADD(dict, key, obj) (dict).dictAdd(key, std::move(obj))
+#elif POPPLER_CHECK_VERSION(0,58,0)
+#define _POPPLER_DICTADD(dict, key, obj) (dict).dictAdd(copyString(key), std::move(obj))
+#else
+#define _POPPLER_DICTADD(dict, key, obj) (dict).dictAdd(copyString(key), &obj)
+#endif
+
+#if POPPLER_CHECK_VERSION(0,58,0)
+#define POPPLER_NEW_OBJECT_API
+#define _POPPLER_FREE(obj)
+#define _POPPLER_CALL(ret, func) (ret = func())
+#define _POPPLER_CALL_ARGS(ret, func, ...) (ret = func(__VA_ARGS__))
+#define _POPPLER_CALL_ARGS_DEREF _POPPLER_CALL_ARGS
+#else
+#define _POPPLER_FREE(obj) (obj).free()
+#define _POPPLER_CALL(ret, func) (*func(&ret))
+#define _POPPLER_CALL_ARGS(ret, func, ...) (func(__VA_ARGS__, &ret))
+#define _POPPLER_CALL_ARGS_DEREF(...) (*_POPPLER_CALL_ARGS(__VA_ARGS__))
+#endif
+
+#if POPPLER_CHECK_VERSION(0, 29, 0)
+#define POPPLER_EVEN_NEWER_NEW_COLOR_SPACE_API
+#endif
+
+#if POPPLER_CHECK_VERSION(0, 25, 0)
+#define POPPLER_EVEN_NEWER_COLOR_SPACE_API
+#endif
+
+#endif
diff -Naur inkscape-0.92.3/src/extension/internal/pdfinput/svg-builder.cpp inkscape-master/src/extension/internal/pdfinput/svg-builder.cpp
--- inkscape-0.92.3/src/extension/internal/pdfinput/svg-builder.cpp	2018-03-11 23:38:09.000000000 +0300
+++ inkscape-master/src/extension/internal/pdfinput/svg-builder.cpp	2018-10-22 14:51:57.000000000 +0300
@@ -12,7 +12,7 @@
  */
 
 #ifdef HAVE_CONFIG_H
-# include <config.h>
+# include "config.h"  // only include where actually required!
 #endif
 
 #include <string> 
@@ -104,18 +105,17 @@
     _init();
 }
 
-SvgBuilder::~SvgBuilder() {
-}
+SvgBuilder::~SvgBuilder() = default;
 
 void SvgBuilder::_init() {
-    _font_style = NULL;
-    _current_font = NULL;
-    _font_specification = NULL;
+    _font_style = nullptr;
+    _current_font = nullptr;
+    _font_specification = nullptr;
     _font_scaling = 1;
     _need_font_update = true;
     _in_text_object = false;
     _invalidated_style = true;
-    _current_state = NULL;
+    _current_state = nullptr;
     _width = 0;
     _height = 0;
 
@@ -124,12 +124,12 @@
     font_factory::Default()->GetUIFamilies(families);
     for ( std::vector<PangoFontFamily *>::iterator iter = families.begin();
           iter != families.end(); ++iter ) {
-        _availableFontNames.push_back(pango_font_family_get_name(*iter));
+        _availableFontNames.emplace_back(pango_font_family_get_name(*iter));
     }
 
-    _transp_group_stack = NULL;
+    _transp_group_stack = nullptr;
     SvgGraphicsState initial_state;
-    initial_state.softmask = NULL;
+    initial_state.softmask = nullptr;
     initial_state.group_depth = 0;
     _state_stack.push_back(initial_state);
     _node_stack.push_back(_container);
@@ -185,7 +185,7 @@
 }
 
 Inkscape::XML::Node *SvgBuilder::popNode() {
-    Inkscape::XML::Node *node = NULL;
+    Inkscape::XML::Node *node = nullptr;
     if ( _node_stack.size() > 1 ) {
         node = _node_stack.back();
         _node_stack.pop_back();
@@ -214,7 +214,7 @@
             setAsLayer(_docname);
         }
     }
-    if (_container->parent()->attribute("inkscape:groupmode") != NULL) {
+    if (_container->parent()->attribute("inkscape:groupmode") != nullptr) {
         _ttm[0] = _ttm[3] = 1.0;    // clear ttm if parent is a layer
         _ttm[1] = _ttm[2] = _ttm[4] = _ttm[5] = 0.0;
         _ttm_is_set = false;
@@ -378,7 +378,7 @@
         sp_repr_css_set_property(css, "stroke-dashoffset", os_offset.str().c_str());
     } else {
         sp_repr_css_set_property(css, "stroke-dasharray", "none");
-        sp_repr_css_set_property(css, "stroke-dashoffset", NULL);
+        sp_repr_css_set_property(css, "stroke-dashoffset", nullptr);
     }
 }
 
@@ -502,7 +502,7 @@
             SPObject *clip_obj = _doc->getObjectById(clip_path_id);
             if (clip_obj) {
                 clip_obj->deleteObject();
-                node->setAttribute("clip-path", NULL);
+                node->setAttribute("clip-path", nullptr);
                 TRACE(("removed clipping path: %s\n", clip_path_id));
             }
             break;
@@ -569,7 +569,7 @@
 void SvgBuilder::setTransform(double c0, double c1, double c2, double c3,
                               double c4, double c5) {
     // do not remember the group which is a layer
-    if ((_container->attribute("inkscape:groupmode") == NULL) && !_ttm_is_set) {
+    if ((_container->attribute("inkscape:groupmode") == nullptr) && !_ttm_is_set) {
         _ttm[0] = c0;
         _ttm[1] = c1;
         _ttm[2] = c2;
@@ -580,7 +580,7 @@
     }
 
     // Avoid transforming a group with an already set clip-path
-    if ( _container->attribute("clip-path") != NULL ) {
+    if ( _container->attribute("clip-path") != nullptr ) {
         pushGroup();
     }
     TRACE(("setTransform: %f %f %f %f %f %f\n", c0, c1, c2, c3, c4, c5));
@@ -597,7 +597,7 @@
  * Used by PdfParser to decide when to do fallback operations.
  */
 bool SvgBuilder::isPatternTypeSupported(GfxPattern *pattern) {
-    if ( pattern != NULL ) {
+    if ( pattern != nullptr ) {
         if ( pattern->getType() == 2 ) {    // shading pattern
             GfxShading *shading = (static_cast<GfxShadingPattern *>(pattern))->getShading();
             int shadingType = shading->getType();
@@ -618,14 +618,14 @@
  * \brief Creates a pattern from poppler's data structure
  * Handles linear and radial gradients. Creates a new PdfParser and uses it to
  * build a tiling pattern.
- * \return an url pointing to the created pattern
+ * \return a url pointing to the created pattern
  */
 gchar *SvgBuilder::_createPattern(GfxPattern *pattern, GfxState *state, bool is_stroke) {
-    gchar *id = NULL;
-    if ( pattern != NULL ) {
+    gchar *id = nullptr;
+    if ( pattern != nullptr ) {
         if ( pattern->getType() == 2 ) {  // Shading pattern
             GfxShadingPattern *shading_pattern = static_cast<GfxShadingPattern *>(pattern);
-            double *ptm;
+            const double *ptm;
             double m[6] = {1, 0, 0, 1, 0, 0};
             double det;
 
@@ -655,7 +655,7 @@
             id = _createTilingPattern(static_cast<GfxTilingPattern*>(pattern), state, is_stroke);
         }
     } else {
-        return NULL;
+        return nullptr;
     }
     gchar *urltext = g_strdup_printf ("url(#%s)", id);
     g_free(id);
@@ -672,7 +672,7 @@
 
     Inkscape::XML::Node *pattern_node = _xml_doc->createElement("svg:pattern");
     // Set pattern transform matrix
-    double *p2u = tiling_pattern->getMatrix();
+    const double *p2u = tiling_pattern->getMatrix();
     double m[6] = {1, 0, 0, 1, 0, 0};
     double det;
     det = _ttm[0] * _ttm[3] - _ttm[1] * _ttm[2];    // see LP Bug 1168908
@@ -698,7 +698,7 @@
     pattern_node->setAttribute("patternUnits", "userSpaceOnUse");
     // Set pattern tiling
     // FIXME: don't ignore XStep and YStep
-    double *bbox = tiling_pattern->getBBox();
+    const double *bbox = tiling_pattern->getBBox();
     sp_repr_set_svg_double(pattern_node, "x", 0.0);
     sp_repr_set_svg_double(pattern_node, "y", 0.0);
     sp_repr_set_svg_double(pattern_node, "width", bbox[2] - bbox[0]);
@@ -718,7 +718,7 @@
     GfxPatternColorSpace *pat_cs = (GfxPatternColorSpace *)( is_stroke ? state->getStrokeColorSpace()
                                                             : state->getFillColorSpace() );
     // Set fill/stroke colors if this is an uncolored tiling pattern
-    GfxColorSpace *cs = NULL;
+    GfxColorSpace *cs = nullptr;
     if ( tiling_pattern->getPaintType() == 2 && ( cs = pat_cs->getUnder() ) ) {
         GfxState *pattern_state = pdf_parser->getState();
         pattern_state->setFillColorSpace(cs->copy());
@@ -751,7 +751,7 @@
  */
 gchar *SvgBuilder::_createGradient(GfxShading *shading, double *matrix, bool for_shading) {
     Inkscape::XML::Node *gradient;
-    Function *func;
+    _POPPLER_CONST Function *func;
     int num_funcs;
     bool extend0, extend1;
 
@@ -784,7 +784,7 @@
         num_funcs = radial_shading->getNFuncs();
         func = radial_shading->getFunc(0);
     } else {    // Unsupported shading type
-        return NULL;
+        return nullptr;
     }
     gradient->setAttribute("gradientUnits", "userSpaceOnUse");
     // If needed, flip the gradient transform around the y axis
@@ -806,7 +806,7 @@
 
     if ( num_funcs > 1 || !_addGradientStops(gradient, shading, func) ) {
         Inkscape::GC::release(gradient);
-        return NULL;
+        return nullptr;
     }
 
     Inkscape::XML::Node *defs = _doc->getDefs()->getRepr();
@@ -826,8 +826,8 @@
     Inkscape::XML::Node *stop = _xml_doc->createElement("svg:stop");
     SPCSSAttr *css = sp_repr_css_attr_new();
     Inkscape::CSSOStringStream os_opacity;
-    gchar *color_text = NULL;
-    if ( _transp_group_stack != NULL && _transp_group_stack->for_softmask ) {
+    gchar *color_text = nullptr;
+    if ( _transp_group_stack != nullptr && _transp_group_stack->for_softmask ) {
         double gray = (double)color->r / 65535.0;
         gray = CLAMP(gray, 0.0, 1.0);
         os_opacity << gray;
@@ -865,7 +865,7 @@
 
 #define INT_EPSILON 8
 bool SvgBuilder::_addGradientStops(Inkscape::XML::Node *gradient, GfxShading *shading,
-                                   Function *func) {
+                                   _POPPLER_CONST Function *func) {
     int type = func->getType();
     if ( type == 0 || type == 2 ) {  // Sampled or exponential function
         GfxRGB stop1, stop2;
@@ -877,9 +877,9 @@
             _addStopToGradient(gradient, 1.0, &stop2, 1.0);
         }
     } else if ( type == 3 ) { // Stitching
-        StitchingFunction *stitchingFunc = static_cast<StitchingFunction*>(func);
-        double *bounds = stitchingFunc->getBounds();
-        double *encode = stitchingFunc->getEncode();
+        auto stitchingFunc = static_cast<_POPPLER_CONST StitchingFunction*>(func);
+        const double *bounds = stitchingFunc->getBounds();
+        const double *encode = stitchingFunc->getEncode();
         int num_funcs = stitchingFunc->getNumFuncs();
 
         // Add stops from all the stitched functions
@@ -890,7 +890,7 @@
             svgGetShadingColorRGB(shading, bounds[i + 1], &color);
             // Add stops
             if (stitchingFunc->getFunc(i)->getType() == 2) {    // process exponential fxn
-                double expE = (static_cast<ExponentialFunction*>(stitchingFunc->getFunc(i)))->getE();
+                double expE = (static_cast<_POPPLER_CONST ExponentialFunction*>(stitchingFunc->getFunc(i)))->getE();
                 if (expE > 1.0) {
                     expE = (bounds[i + 1] - bounds[i])/expE;    // approximate exponential as a single straight line at x=1
                     if (encode[2*i] == 0) {    // normal sequence
@@ -1022,22 +1022,22 @@
     if (font->getName()) {
         _font_specification = font->getName()->getCString();
     } else {
-        _font_specification = (char*) "Arial";
+        _font_specification = "Arial";
     }
 
     // Prune the font name to get the correct font family name
     // In a PDF font names can look like this: IONIPB+MetaPlusBold-Italic
-    char *font_family = NULL;
-    char *font_style = NULL;
-    char *font_style_lowercase = NULL;
-    char *plus_sign = strstr(_font_specification, "+");
+    char *font_family = nullptr;
+    char *font_style = nullptr;
+    char *font_style_lowercase = nullptr;
+    const char *plus_sign = strstr(_font_specification, "+");
     if (plus_sign) {
         font_family = g_strdup(plus_sign + 1);
         _font_specification = plus_sign + 1;
     } else {
         font_family = g_strdup(_font_specification);
     }
-    char *style_delim = NULL;
+    char *style_delim = nullptr;
     if ( ( style_delim = g_strrstr(font_family, "-") ) ||
          ( style_delim = g_strrstr(font_family, ",") ) ) {
         font_style = style_delim + 1;
@@ -1076,7 +1076,7 @@
 
     // Font weight
     GfxFont::Weight font_weight = font->getWeight();
-    char *css_font_weight = NULL;
+    char *css_font_weight = nullptr;
     if ( font_weight != GfxFont::WeightNotDefined ) {
         if ( font_weight == GfxFont::W400 ) {
             css_font_weight = (char*) "normal";
@@ -1108,7 +1108,7 @@
 
     // Font stretch
     GfxFont::Stretch font_stretch = font->getStretch();
-    gchar *stretch_value = NULL;
+    gchar *stretch_value = nullptr;
     switch (font_stretch) {
         case GfxFont::UltraCondensed:
             stretch_value = (char*) "ultra-condensed";
@@ -1140,7 +1140,7 @@
         default:
             break;
     }
-    if ( stretch_value != NULL ) {
+    if ( stretch_value != nullptr ) {
         sp_repr_css_set_property(_font_style, "font-stretch", stretch_value);
     }
 
@@ -1148,7 +1148,7 @@
     Inkscape::CSSOStringStream os_font_size;
     double css_font_size = _font_scaling * state->getFontSize();
     if ( font->getType() == fontType3 ) {
-        double *font_matrix = font->getFontMatrix();
+        const double *font_matrix = font->getFontMatrix();
         if ( font_matrix[0] != 0.0 ) {
             css_font_size *= font_matrix[3] / font_matrix[0];
         }
@@ -1193,7 +1193,7 @@
 void SvgBuilder::updateTextMatrix(GfxState *state) {
     _flushText();
     // Update text matrix
-    double *text_matrix = state->getTextMat();
+    const double *text_matrix = state->getTextMat();
     double w_scale = sqrt( text_matrix[0] * text_matrix[0] + text_matrix[2] * text_matrix[2] );
     double h_scale = sqrt( text_matrix[1] * text_matrix[1] + text_matrix[3] * text_matrix[3] );
     double max_scale;
@@ -1249,13 +1249,13 @@
     bool same_coords[2] = {true, true};
     Geom::Point last_delta_pos;
     unsigned int glyphs_in_a_row = 0;
-    Inkscape::XML::Node *tspan_node = NULL;
+    Inkscape::XML::Node *tspan_node = nullptr;
     Glib::ustring x_coords;
     Glib::ustring y_coords;
     Glib::ustring text_buffer;
 
     // Output all buffered glyphs
-    while (1) {
+    while (true) {
         const SvgGlyph& glyph = (*i);
         std::vector<SvgGlyph>::iterator prev_iterator = i - 1;
         // Check if we need to make a new tspan
@@ -1361,7 +1361,7 @@
     _glyphs.clear();
 }
 
-void SvgBuilder::beginString(GfxState *state, GooString * /*s*/) {
+void SvgBuilder::beginString(GfxState *state) {
     if (_need_font_update) {
         updateFont(state);
     }
@@ -1414,7 +1414,7 @@
             uu[i] = u[i];
         }
 
-        gchar *tmp = g_utf16_to_utf8(uu, uLen, NULL, NULL, NULL);
+        gchar *tmp = g_utf16_to_utf8(uu, uLen, nullptr, nullptr, nullptr);
         if ( tmp && *tmp ) {
             new_glyph.code = tmp;
         } else {
@@ -1491,20 +1491,20 @@
                                               bool invert_alpha) {
 
     // Create PNG write struct
-    png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
-    if ( png_ptr == NULL ) {
-        return NULL;
+    png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, nullptr, nullptr, nullptr);
+    if ( png_ptr == nullptr ) {
+        return nullptr;
     }
     // Create PNG info struct
     png_infop info_ptr = png_create_info_struct(png_ptr);
-    if ( info_ptr == NULL ) {
-        png_destroy_write_struct(&png_ptr, NULL);
-        return NULL;
+    if ( info_ptr == nullptr ) {
+        png_destroy_write_struct(&png_ptr, nullptr);
+        return nullptr;
     }
     // Set error handler
     if (setjmp(png_jmpbuf(png_ptr))) {
         png_destroy_write_struct(&png_ptr, &info_ptr);
-        return NULL;
+        return nullptr;
     }
     // Decide whether we should embed this image
     int attr_value = 1;
@@ -1513,8 +1513,8 @@
     // Set read/write functions
     Inkscape::IO::StringOutputStream base64_string;
     Inkscape::IO::Base64OutputStream base64_stream(base64_string);
-    FILE *fp = NULL;
-    gchar *file_name = NULL;
+    FILE *fp = nullptr;
+    gchar *file_name = nullptr;
     if (embed_image) {
         base64_stream.setColumnWidth(0);   // Disable line breaks
         png_set_write_fn(png_ptr, &base64_stream, png_write_base64stream, png_flush_base64stream);
@@ -1522,10 +1522,10 @@
         static int counter = 0;
         file_name = g_strdup_printf("%s_img%d.png", _docname, counter++);
         fp = fopen(file_name, "wb");
-        if ( fp == NULL ) {
+        if ( fp == nullptr ) {
             png_destroy_write_struct(&png_ptr, &info_ptr);
             g_free(file_name);
-            return NULL;
+            return nullptr;
         }
         png_init_io(png_ptr, fp);
     }
@@ -1645,7 +1645,7 @@
             fclose(fp);
             g_free(file_name);
         }
-        return NULL;
+        return nullptr;
     }
     delete image_stream;
     str->close();
@@ -1711,7 +1711,7 @@
         if ( !( defs && !strcmp(defs->name(), "svg:defs") ) ) {
             // Create <defs> node
             defs = _xml_doc->createElement("svg:defs");
-            _root->addChild(defs, NULL);
+            _root->addChild(defs, nullptr);
             Inkscape::GC::release(defs);
             defs = _root->firstChild();
         }
@@ -1753,12 +1753,12 @@
     // Scaling 1x1 surfaces might not work so skip setting a mask with this size
     if ( width > 1 || height > 1 ) {
         Inkscape::XML::Node *mask_image_node =
-            _createImage(str, width, height, NULL, interpolate, NULL, true, invert);
+            _createImage(str, width, height, nullptr, interpolate, nullptr, true, invert);
         if (mask_image_node) {
             // Create the mask
             Inkscape::XML::Node *mask_node = _createMask(1.0, 1.0);
             // Remove unnecessary transformation from the mask image
-            mask_image_node->setAttribute("transform", NULL);
+            mask_image_node->setAttribute("transform", nullptr);
             mask_node->appendChild(mask_image_node);
             Inkscape::GC::release(mask_image_node);
             gchar *mask_url = g_strdup_printf("url(#%s)", mask_node->attribute("id"));
@@ -1778,13 +1778,13 @@
                                 bool invert_mask, bool mask_interpolate) {
 
     Inkscape::XML::Node *mask_image_node = _createImage(mask_str, mask_width, mask_height,
-                                          NULL, mask_interpolate, NULL, true, invert_mask);
-    Inkscape::XML::Node *image_node = _createImage(str, width, height, color_map, interpolate, NULL);
+                                          nullptr, mask_interpolate, nullptr, true, invert_mask);
+    Inkscape::XML::Node *image_node = _createImage(str, width, height, color_map, interpolate, nullptr);
     if ( mask_image_node && image_node ) {
         // Create mask for the image
         Inkscape::XML::Node *mask_node = _createMask(1.0, 1.0);
         // Remove unnecessary transformation from the mask image
-        mask_image_node->setAttribute("transform", NULL);
+        mask_image_node->setAttribute("transform", nullptr);
         mask_node->appendChild(mask_image_node);
         // Scale the mask to the size of the image
         Geom::Affine mask_transform((double)width, 0.0, 0.0, (double)height, 0.0, 0.0);
@@ -1811,13 +1811,13 @@
                                     GfxImageColorMap *mask_color_map, bool mask_interpolate) {
 
     Inkscape::XML::Node *mask_image_node = _createImage(mask_str, mask_width, mask_height,
-                                                        mask_color_map, mask_interpolate, NULL, true);
-    Inkscape::XML::Node *image_node = _createImage(str, width, height, color_map, interpolate, NULL);
+                                                        mask_color_map, mask_interpolate, nullptr, true);
+    Inkscape::XML::Node *image_node = _createImage(str, width, height, color_map, interpolate, nullptr);
     if ( mask_image_node && image_node ) {
         // Create mask for the image
         Inkscape::XML::Node *mask_node = _createMask(1.0, 1.0);
         // Remove unnecessary transformation from the mask image
-        mask_image_node->setAttribute("transform", NULL);
+        mask_image_node->setAttribute("transform", nullptr);
         mask_node->appendChild(mask_image_node);
         // Set mask and add image
         gchar *mask_url = g_strdup_printf("url(#%s)", mask_node->attribute("id"));
@@ -1901,7 +1901,7 @@
 
 void SvgBuilder::clearSoftMask(GfxState * /*state*/) {
     if (_state_stack.back().softmask) {
-        _state_stack.back().softmask = NULL;
+        _state_stack.back().softmask = nullptr;
         popGroup();
     }
 }
diff -Naur inkscape-0.92.3/src/extension/internal/pdfinput/svg-builder.h inkscape-master/src/extension/internal/pdfinput/svg-builder.h
--- inkscape-0.92.3/src/extension/internal/pdfinput/svg-builder.h	2018-03-11 23:38:09.000000000 +0300
+++ inkscape-master/src/extension/internal/pdfinput/svg-builder.h	2018-10-22 14:51:57.000000000 +0300
@@ -11,10 +11,11 @@
  */
 
 #ifdef HAVE_CONFIG_H
-# include <config.h>
+# include "config.h"  // only include where actually required!
 #endif
 
 #ifdef HAVE_POPPLER
+#include "poppler-transition-api.h"
 
 class SPDocument;
 namespace Inkscape {
@@ -29,7 +30,6 @@
 #include <glibmm/ustring.h>
 
 #include "CharTypes.h"
-class GooString;
 class Function;
 class GfxState;
 struct GfxColor;
@@ -81,7 +81,7 @@
     bool style_changed;  // Set to true if style has to be reset
     SPCSSAttr *style;
     int render_mode;    // Text render mode
-    char *font_specification;   // Pointer to current font specification
+    const char *font_specification;   // Pointer to current font specification
 };
 
 /**
@@ -95,7 +95,7 @@
 
     // Property setting
     void setDocumentSize(double width, double height);  // Document size in px
-    void setAsLayer(char *layer_name=NULL);
+    void setAsLayer(char *layer_name=nullptr);
     void setGroupOpacity(double opacity);
     Inkscape::XML::Node *getPreferences() {
         return _preferences;
@@ -136,7 +136,7 @@
     void clearSoftMask(GfxState *state);
 
     // Text handling
-    void beginString(GfxState *state, GooString *s);
+    void beginString(GfxState *state);
     void endString(GfxState *state);
     void addChar(GfxState *state, double x, double y,
                  double dx, double dy,
@@ -175,7 +175,7 @@
     void _addStopToGradient(Inkscape::XML::Node *gradient, double offset,
                             GfxRGB *color, double opacity);
     bool _addGradientStops(Inkscape::XML::Node *gradient, GfxShading *shading,
-                           Function *func);
+                           _POPPLER_CONST Function *func);
     gchar *_createTilingPattern(GfxTilingPattern *tiling_pattern, GfxState *state,
                                 bool is_stroke=false);
     // Image/mask creation
@@ -203,7 +203,7 @@
 
     SPCSSAttr *_font_style;          // Current font style
     GfxFont *_current_font;
-    char *_font_specification;
+    const char *_font_specification;
     double _font_scaling;
     bool _need_font_update;
     Geom::Affine _text_matrix;
