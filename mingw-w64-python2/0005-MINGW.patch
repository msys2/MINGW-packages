diff -urN a/configure.ac b/configure.ac
--- a/configure.ac	2013-05-12 04:32:54.000000000 +0100
+++ b/configure.ac	2013-05-17 23:57:26.928332564 +0100
@@ -318,6 +318,9 @@
 	*-*-cygwin*)
 		ac_sys_system=Cygwin
 		;;
+	*-*-mingw*)
+		ac_sys_system=MinGW
+		;;
 	*)
 		# for now, limit cross builds to known configurations
 		MACHDEP="unknown"
@@ -345,6 +348,7 @@
 	darwin*) MACHDEP="darwin";;
 	atheos*) MACHDEP="atheos";;
         irix646) MACHDEP="irix6";;
+	mingw*) MACHDEP="win32";;
 	'')	MACHDEP="unknown";;
     esac
 fi
@@ -361,7 +365,7 @@
 			_host_cpu=$host_cpu
 		esac
 		;;
-	*-*-cygwin*)
+	*-*-cygwin*|*-*-mingw*)
 		_host_cpu=
 		;;
 	*)
@@ -489,6 +493,16 @@
 fi
 AC_MSG_RESULT($MACHDEP)
 
+AC_MSG_CHECKING([for init system calls])
+AC_SUBST(INITSYS)
+case $host in
+  # FIXME: May configure lack detection for os2 host system ?
+  #?#*-*-os2*)	INITSYS=os2;;
+  *-*-mingw*)	INITSYS=nt;;
+  *)		INITSYS=posix;;
+esac
+AC_MSG_RESULT([$INITSYS])
+
 # And add extra plat-mac for darwin
 AC_SUBST(EXTRAPLATDIR)
 AC_SUBST(EXTRAMACHDEPPATH)
@@ -825,6 +839,10 @@
   *)
     enable_shared="no";;
   esac
+  case $host in
+  *-*-mingw*)
+    enable_shared="yes";;
+  esac
 fi
 AC_MSG_RESULT($enable_shared)
 
@@ -926,6 +944,14 @@
 	;;
 
   esac
+  case $host in
+    *-*-mingw*)
+          LDLIBRARY='libpython$(VERSION).dll.a'
+          DLLLIBRARY='libpython$(VERSION).dll'
+          dnl setup.py add it for mingw host
+          dnl BLDLIBRARY='-L. -lpython$(VERSION)'
+          ;;
+  esac
 else # shared is disabled
   case $ac_sys_system in
     CYGWIN*)
@@ -933,6 +959,10 @@
           LDLIBRARY='libpython$(VERSION).dll.a'
           ;;
   esac
+  case $host in
+    *-*-mingw*)
+          LDLIBRARY='libpython$(VERSION).a';;
+  esac
 fi
 
 if test "$cross_compiling" = yes; then
@@ -1012,6 +1042,8 @@
 	esac
 fi
 
+dnl TODO: to move --with-pydebug earlier in script and to group
+dnl debug related statements togeder (if posible)
 # Check for --with-pydebug
 AC_MSG_CHECKING(for --with-pydebug)
 AC_ARG_WITH(pydebug, 
@@ -1026,6 +1058,29 @@
 else AC_MSG_RESULT(no); Py_DEBUG='false'
 fi],
 [AC_MSG_RESULT(no)])
+# FIXME: We define BUILDEXEEXT and LDLIBRARY above but:
+#  For debug versions MSVC build prepend suffix by '_d'.
+#  If we support this convention we may modify distutils(TODO).
+#  To support different build directories is good "--with-pydebug"
+#  to be earlier in the script(why i wrote this?).
+if test "x$Py_DEBUG" = xtrue; then
+  case $host in
+    dnl TODO: This is good to be where we define LDLIBRARY
+    dnl but --with-pydebug is defined too late in the script.
+    # Since Makefile.pre.in may isn't suitable for now we will not
+    # change LDLIBRARY.
+    *-*-mingw*)
+      BUILDEXEEXT=_d$BUILDEXEEXT
+      if test x$enable_shared = xyes; then
+        #LDLIBRARY='libpython$(VERSION)_d.dll.a'
+        DLLLIBRARY='libpython$(VERSION)_d.dll'
+      else # shared is disabled
+        #LDLIBRARY='libpython$(VERSION)_d.dll.a';;
+        :
+      fi
+      ;;
+  esac
+fi
 
 # XXX Shouldn't the code above that fiddles with BASECFLAGS and OPT be
 # merged with this chunk of code?
@@ -1042,6 +1097,8 @@
 
 # tweak OPT based on compiler and platform, only if the user didn't set
 # it on the command line
+# NOTE: If user set OPT at this point script ignore all previously set
+# options (not important - BeOS is depricated for python 2.6+).
 AC_SUBST(OPT)
 if test "${OPT-unset}" = "unset"
 then
@@ -1253,8 +1310,15 @@
     ;;
 esac
 
+dnl NOTE: although Py_DEBUG is set earlier in the script we can't move
+dnl before "# tweak OPT based on compiler" - if user specify environment
+dnl variable OPT we will lost our settings!!!
+dnl FIXME: why script add debug definition to OPT instead to BASECFLAGS?
 if test "$Py_DEBUG" = 'true'; then
-  :
+  case $host in
+    dnl Same as in PC/pyconfig.h but order in opposite(Py_DEBUG=>-D_DEBUG).
+    *-*-mingw*) OPT="-D_DEBUG $OPT";;
+  esac
 else
   OPT="-DNDEBUG $OPT"
 fi
@@ -1457,6 +1521,20 @@
 AC_MSG_RESULT($ac_cv_pthread)
 fi
 
+if test "x$ac_cv_kpthread" = xno && \
+   test "x$ac_cv_kthread" = xno && \
+   test "x$ac_cv_pthread" = xno && \
+   test "x$ac_cv_pthread_is_default" = xno
+then
+	AC_MSG_CHECKING(for NT threads)
+	AC_CACHE_VAL(ac_cv_ntthread,
+	[AC_LINK_IFELSE([
+		AC_LANG_PROGRAM([], [_beginthread(0, 0, 0);])],
+	ac_cv_ntthread=yes,
+	ac_cv_ntthread=no)])
+	AC_MSG_RESULT([$ac_cv_ntthread])
+fi
+
 # If we have set a CC compiler flag for thread support then
 # check if it works for CXX, too.
 ac_cv_cxx_thread=no
@@ -1477,6 +1555,9 @@
 then 
   CXX="$CXX -pthread"
   ac_cv_cxx_thread=yes
+elif test "x$ac_cv_ntthread" = xyes
+then
+  ac_cv_cxx_thread=always
 fi
 
 if test $ac_cv_cxx_thread = yes
@@ -1518,7 +1599,7 @@
 sys/termio.h sys/time.h \
 sys/times.h sys/types.h sys/un.h sys/utsname.h sys/wait.h pty.h libutil.h \
 sys/resource.h netpacket/packet.h sysexits.h bluetooth.h \
-bluetooth/bluetooth.h linux/tipc.h spawn.h util.h alloca.h)
+bluetooth/bluetooth.h linux/tipc.h spawn.h util.h alloca.h winsock2.h)
 AC_HEADER_DIRENT
 AC_HEADER_MAJOR
 
@@ -1747,19 +1828,20 @@
 elif test "$ac_cv_pthread" = "yes"
 then CC="$CC -pthread"
 fi
-AC_MSG_CHECKING(for pthread_t)
-have_pthread_t=no
-AC_COMPILE_IFELSE([
-  AC_LANG_PROGRAM([[#include <pthread.h>]], [[pthread_t x; x = *(pthread_t*)0;]])
-],[have_pthread_t=yes],[])
-AC_MSG_RESULT($have_pthread_t)
-if test "$have_pthread_t" = yes ; then
+dnl NOTE: avoid duplicate check for pthread_t(it is done in AC_CHECK_SIZEOF(pthread_t...) )
+dnl AC_MSG_CHECKING(for pthread_t)
+dnl have_pthread_t=no
+dnl AC_COMPILE_IFELSE([
+dnl   AC_LANG_PROGRAM([[#include <pthread.h>]], [[pthread_t x; x = *(pthread_t*)0;]])
+dnl ],[have_pthread_t=yes],[])
+dnl AC_MSG_RESULT($have_pthread_t)
+dnl if test "$have_pthread_t" = yes ; then
   AC_CHECK_SIZEOF(pthread_t, [], [
 #ifdef HAVE_PTHREAD_H
 #include <pthread.h>
 #endif
   ])
-fi
+dnl fi
 CC="$ac_save_cc"
 
 AC_MSG_CHECKING(for --enable-toolbox-glue)
@@ -1920,6 +2002,16 @@
 	CYGWIN*)   SO=.dll;;
 	*)	   SO=.so;;
 	esac
+	case $host in
+	*-*-mingw*)
+	#NOTE: see _PyImport_DynLoadFiletab in dynload_win.c
+	if test "x$Py_DEBUG" = xtrue; then
+		SO=_d.pyd
+	else
+		SO=.pyd
+	fi
+	;;
+	esac
 else
 	# this might also be a termcap variable, see #610332
         echo
@@ -2076,6 +2168,12 @@
 		LDCXXSHARED="g++ -shared";;
 	*)	LDSHARED="ld";;
 	esac
+	case $host in
+	*-*-mingw*)
+		LDSHARED='$(CC) -shared -Wl,--enable-auto-image-base'
+		LDCXXSHARED='$(CXX) -shared -Wl,--enable-auto-image-base'
+		;;
+	esac
 fi
 AC_MSG_RESULT($LDSHARED)
 LDCXXSHARED=${LDCXXSHARED-$LDSHARED}
@@ -2173,6 +2271,12 @@
 		# when running test_compile.py.
 		LINKFORSHARED='-Wl,-E -N 2048K';;
 	esac
+	case $host in
+	*-*-mingw*)
+		if test x$enable_shared = xyes; then
+			LINKFORSHARED='-Wl,--out-implib=$(LDLIBRARY)'
+		fi;;
+	esac
 fi
 AC_MSG_RESULT($LINKFORSHARED)
 
@@ -2189,6 +2293,12 @@
 	*)
 		CFLAGSFORSHARED='$(CCSHARED)'
 	esac
+	case $host in
+	*-*-mingw*)
+		# TODO mingw may needs CCSHARED when building extension DLLs
+		# but not when building the interpreter DLL.
+		CFLAGSFORSHARED='';;
+	esac
 fi
 AC_MSG_RESULT($CFLAGSFORSHARED)
 
@@ -2221,9 +2331,18 @@
 fi
 
 # check if we need libintl for locale functions
+case $host in
+  *-*-mingw*)
+  dnl Native windows build don't use libintl (see _localemodule.c).
+  dnl Also we don't like setup.py to add "intl" library to the list
+  dnl when build _locale module.
+  ;;
+  *)
 AC_CHECK_LIB(intl, textdomain,
 	AC_DEFINE(WITH_LIBINTL, 1,
 	[Define to 1 if libintl is needed for locale functions.]))
+  ;;
+esac
 
 # checks for system dependent C++ extensions support
 case "$ac_sys_system" in
@@ -2405,6 +2524,13 @@
     AC_DEFINE(WITH_THREAD)
     posix_threads=yes
     THREADOBJ="Python/thread.o"
+elif test "x$ac_cv_ntthread" = xyes
+then
+    AC_DEFINE(WITH_THREAD)
+    posix_threads=no
+    THREADOBJ="Python/thread.o"
+    AC_DEFINE(NT_THREADS, 1,
+	[Define to 1 if you want to use native NT threads])
 else
     if test ! -z "$with_threads" -a -d "$with_threads"
     then LDFLAGS="$LDFLAGS -L$with_threads"
@@ -2572,6 +2698,18 @@
 fi
 
 
+AC_SUBST(BUILDIN_WIN32_MODULE)
+BUILDIN_WIN32_MODULE='#'
+case $host in
+  *-*-mingw*)
+    # On win32 host(mingw build MSYS environment) site.py fail to load
+    # if _functools is not build-in by reason of dependency:
+    #   setup->site->locale->functools&operator
+    BUILDIN_WIN32_MODULE=
+  ;;
+esac
+
+
 # Check for enable-ipv6
 AH_TEMPLATE(ENABLE_IPV6, [Define if --enable-ipv6 is specified])
 AC_MSG_CHECKING([if --enable-ipv6 is specified])
@@ -2851,6 +2989,14 @@
 	fi
 	;;
 	esac
+	case $host in
+	*-*-mingw*)
+	# FIXME: it is good to use portable "$OBJEXT" instead "o" but
+	# python build isn't yet ready to use it (see Makefile.pre.in)
+	#DYNLOADFILE="dynload_win.$OBJEXT"
+	DYNLOADFILE="dynload_win.o"
+	;;
+	esac
 fi
 AC_MSG_RESULT($DYNLOADFILE)
 if test "$DYNLOADFILE" != "dynload_stub.o"
@@ -2863,6 +3009,11 @@
 
 AC_SUBST(MACHDEP_OBJS)
 AC_MSG_CHECKING(MACHDEP_OBJS)
+case $host in
+  *-*-mingw*)
+    extra_machdep_objs="PC/dl_nt.o PC/getpathp.o PC/import_nt.o"
+    ;;
+esac
 if test -z "$MACHDEP_OBJS"
 then
 	MACHDEP_OBJS=$extra_machdep_objs
@@ -2888,6 +3039,17 @@
  sysconf tcgetpgrp tcsetpgrp tempnam timegm times tmpfile tmpnam tmpnam_r \
  truncate uname unsetenv utimes waitpid wait3 wait4 wcscoll _getpty)
 
+dnl NOTE: On windows platform some functions aren't C functions and require
+dnl additional non-standard decoration and may be libraries.
+dnl As example winsock2 functions, although are based on berkeley sockets
+dnl use stdcall convention. Also they require an additional library ws2_32.
+dnl One of those functions is "getpeername" (see list above)
+dnl and can't be detected by script. Now this impact mingw host platforms.
+dnl Since this function is used only by socketmodule, module include
+dnl necessary headers and is linked with requred libs (see setup.py)
+dnl windows exception will be handled in module code.
+dnl FIXME: If you don't like this, write appropriate check here.
+
 # For some functions, having a definition is not sufficient, since
 # we want to take their address.
 AC_MSG_CHECKING(for chroot)
@@ -3294,6 +3456,15 @@
   ac_cv_buggy_getaddrinfo=yes
 fi]))
 fi
+case $host in
+  *-*-mingw*)
+  #FIXME: mingw "w32api" define getaddinfo if WINVER >= 0x501, i.e. XP or greater.
+  #TODO: mingw require additional check.
+  #NOTE: above check is not correct for windows platforms.
+  #  ac_cv_buggy_getaddrinfo=no
+    :
+    ;;
+esac
 
 AC_MSG_RESULT($ac_cv_buggy_getaddrinfo)
 
@@ -3349,19 +3520,33 @@
 
 AC_MSG_CHECKING(for addrinfo)
 AC_CACHE_VAL(ac_cv_struct_addrinfo,
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <netdb.h>]], [[struct addrinfo a]])],
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#ifdef HAVE_WINSOCK2_H
+#  include <ws2tcpip.h>
+#else
+#  include <netdb.h>
+#endif]],
+    [[struct addrinfo a]])],
   [ac_cv_struct_addrinfo=yes],
   [ac_cv_struct_addrinfo=no]))
 AC_MSG_RESULT($ac_cv_struct_addrinfo)
 if test $ac_cv_struct_addrinfo = yes; then
-	AC_DEFINE(HAVE_ADDRINFO, 1, [struct addrinfo (netdb.h)])
+	AC_DEFINE(HAVE_ADDRINFO, 1, [struct addrinfo])
 fi
 
 AC_MSG_CHECKING(for sockaddr_storage)
 AC_CACHE_VAL(ac_cv_struct_sockaddr_storage,
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#		include <sys/types.h>
-#		include <sys/socket.h>]], [[struct sockaddr_storage s]])],
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#ifdef HAVE_WINSOCK2_H
+#include <winsock2.h>
+#endif]],
+    [[struct sockaddr_storage s]])],
   [ac_cv_struct_sockaddr_storage=yes],
   [ac_cv_struct_sockaddr_storage=no]))
 AC_MSG_RESULT($ac_cv_struct_sockaddr_storage)
@@ -3555,11 +3740,16 @@
 
 # check for --with-libm=...
 AC_SUBST(LIBM)
+dnl obsolete style to set libraries for a system
 case $ac_sys_system in
 Darwin) ;;
 BeOS) ;;
 *) LIBM=-lm
 esac
+dnl new style to set libraries for host system
+case $host in
+  *-*-mingw*) LIBM=;;
+esac
 AC_MSG_CHECKING(for --with-libm=STRING)
 AC_ARG_WITH(libm,
             AS_HELP_STRING([--with-libm=STRING], [math library]),
@@ -3593,6 +3783,13 @@
 # **************************************************
 # * Check for various properties of floating point *
 # **************************************************
+case $host in
+  *-*-mingw*)
+    ac_cv_little_endian_double=yes
+    ac_cv_big_endian_double=no
+    ac_cv_mixed_endian_double=no
+  ;;
+esac
 
 AC_MSG_CHECKING(whether C doubles are little-endian IEEE 754 binary64)
 AC_CACHE_VAL(ac_cv_little_endian_double, [
@@ -3676,6 +3873,8 @@
 
 # This inline assembler syntax may also work for suncc and icc,
 # so we try it on all platforms.
+# Note MSVC build use Python/dtoa.c, but I could not find any reason
+# to use this file for GCC(mingw*) builds, so mingw* will use gcc asm :)
 
 AC_MSG_CHECKING(whether we can use gcc inline assembler to get and set x87 control word)
 AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[
@@ -3723,6 +3922,11 @@
 [ac_cv_x87_double_rounding=yes],
 [ac_cv_x87_double_rounding=no])
 CC="$ac_save_cc"
+if test "x$cross_compiling" = xyes; then
+  case $host in
+    *-*-mingw*) ac_cv_x87_double_rounding=yes;;
+  esac
+fi
 AC_MSG_RESULT($ac_cv_x87_double_rounding)
 if test "$ac_cv_x87_double_rounding" = yes
 then
@@ -3740,6 +3944,12 @@
 # On FreeBSD 6.2, it appears that tanh(-0.) returns 0. instead of
 # -0. on some architectures.
 AC_MSG_CHECKING(whether tanh preserves the sign of zero)
+case $host in
+  *-*-mingw*)
+    # Some MSVC runtimes don't preserve zero sign.
+    # On mingw host we will use always replacement function.
+    ac_cv_tanh_preserves_zero_sign=no;;
+esac
 AC_CACHE_VAL(ac_cv_tanh_preserves_zero_sign, [
 AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <math.h>
@@ -3765,6 +3975,12 @@
 
 AC_CHECK_FUNCS([acosh asinh atanh copysign erf erfc expm1 finite gamma])
 AC_CHECK_FUNCS([hypot lgamma log1p round tgamma])
+dnl NOTE:
+dnl MSVC build PC/pyconfig.h define HAVE_DECL_ISINF but it is useless
+dnl since header define Py_IS_INFINITY as (!_finite(X) && !_isnan(X)).
+dnl Also in pymath.h is commented too how PC/pyconfig.h define isinf.
+dnl For mingw to keep compatibility with MSVC build we will define
+dnl Py_IS_INFINITY in pyport.h.
 AC_CHECK_DECLS([isinf, isnan, isfinite], [], [], [[#include <math.h>]])
 
 LIBS=$LIBS_SAVE
@@ -3774,6 +3990,13 @@
 # the kernel module that provides POSIX semaphores
 # isn't loaded by default, so an attempt to call
 # sem_open results in a 'Signal 12' error.
+if test $ac_cv_func_sem_open = yes; then
+case $host in
+  *-*-mingw*)
+    # GCC 4.4+ (mingw) support posix threads(!)
+    # bug we won't use them on windows platform.
+    ac_cv_posix_semaphores_enabled=no;;
+esac
 AC_MSG_CHECKING(whether POSIX semaphores are enabled)
 AC_CACHE_VAL(ac_cv_posix_semaphores_enabled,
 AC_RUN_IFELSE([AC_LANG_SOURCE([[
@@ -3799,6 +4022,9 @@
 [ac_cv_posix_semaphores_enabled=yes])
 )
 AC_MSG_RESULT($ac_cv_posix_semaphores_enabled)
+else
+   ac_cv_posix_semaphores_enabled=no
+fi
 if test $ac_cv_posix_semaphores_enabled = no
 then
   AC_DEFINE(POSIX_SEMAPHORES_NOT_ENABLED, 1,
@@ -3807,6 +4033,16 @@
 
 # Multiprocessing check for broken sem_getvalue
 AC_MSG_CHECKING(for broken sem_getvalue)
+case $host in
+  *-*-mingw*)
+    # GCC(mingw) 4.4+ require and use posix threads(pthreads-w32)
+    # Also system may contain installed pthreads-w32.
+    # NOTE the test case below don't work for pthreads-w32:
+    # - SEM_FAILED is not defined;
+    # - sem_open is stub;
+    # - sem_getvalue work(!).
+    ac_cv_broken_sem_getvalue=no;;
+esac
 AC_CACHE_VAL(ac_cv_broken_sem_getvalue,
 AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <unistd.h>
@@ -3892,6 +4128,9 @@
 then
   # check whether wchar_t is signed or not
   AC_MSG_CHECKING(whether wchar_t is signed)
+  case $host in
+    *-*-mingw*) ac_cv_wchar_t_signed=no;;
+  esac
   AC_CACHE_VAL(ac_cv_wchar_t_signed, [
   AC_RUN_IFELSE([AC_LANG_SOURCE([[
   #include <wchar.h>
@@ -4323,6 +4562,12 @@
 )
 
 AC_MSG_NOTICE([checking for device files])
+case $host in
+  *-*-mingw*)
+    ac_cv_file__dev_ptmx=ignore #NOTE: under MSYS environment device exist
+    ac_cv_file__dev_ptc=no
+    ;;
+esac
 
 dnl NOTE: Inform user how to proceed with files when cross compiling.
 if test "x$cross_compiling" = xyes; then
@@ -4351,6 +4596,9 @@
 
 if test "$have_long_long" = yes
 then
+  case $host in
+    *-*-mingw*) ac_cv_have_long_long_format=yes;;
+  esac
   AC_MSG_CHECKING(for %lld and %llu printf() format support)
   AC_CACHE_VAL(ac_cv_have_long_long_format,
   AC_RUN_IFELSE([AC_LANG_SOURCE([[[
@@ -4419,6 +4667,9 @@
 fi
 
 
+case $host in
+  *-*-mingw*) ac_cv_have_size_t_format=no;;
+esac
 AC_CACHE_CHECK([for %zd printf() format support], ac_cv_have_size_t_format, [dnl
 AC_RUN_IFELSE([AC_LANG_SOURCE([[
 #include <stdio.h>
@@ -4465,6 +4716,8 @@
   [Define to printf format modifier for Py_ssize_t])
 fi
 
+dnl NOTE: check is incorrect for win host systems, i.e. mingw and etc.,
+dnl but on those systems socklen_t is defined in ws2tcpip.h as int ;)
 AC_CHECK_TYPE(socklen_t,,
   AC_DEFINE(socklen_t,int,
             [Define to `int' if <sys/socket.h> does not define.]),[
@@ -4489,8 +4742,39 @@
   THREADHEADERS="$THREADHEADERS \$(srcdir)/$h"
 done
 
+# FIXME: in cross-compilation env. (mingw on linux) how to select correct compiler ?
+# The current py-code will created modules with .so suffix and environment
+# variable setting SO=$(SO) don't help
+# see output of: python setup.py build --help-compiler
+AC_SUBST(PYMOD_BUILDOPT)
+case $host in
+  *-*-mingw*) PYMOD_BUILDOPT="--compiler mingw32";;
+esac
+
+dnl Objects for python and modules
+# Python interpreter main program for frozen scripts
+AC_SUBST(PYTHON_OBJS_FROZENMAIN)
+PYTHON_OBJS_FROZENMAIN="Python/frozenmain.o"
+# MODULE_GETPATH - default sys.path calculations
+AC_SUBST(MODULE_GETPATH)
+MODULE_GETPATH=Modules/getpath.o
+case $host in
+  *-*-mingw*)
+    dnl "PC" is project sub-directory and we has to prepend user defined flags
+    CPPFLAGS="-I\$(srcdir)/Python -I\$(srcdir)/PC $CPPFLAGS"
+
+    # FIXME: why windows builds don't use PC/frozen_dllmain.o ?
+    PYTHON_OBJS_FROZENMAIN=""
+    # default sys.path calculations for windows platforms
+    MODULE_GETPATH=PC/getpathp.o
+    ;;
+esac
+
 AC_SUBST(SRCDIRS)
 SRCDIRS="Parser Grammar Objects Python Modules Mac"
+case $host in
+  *-*-mingw*) SRCDIRS="$SRCDIRS PC";;
+esac
 AC_MSG_CHECKING(for build directories)
 for dir in $SRCDIRS; do
     if test ! -d $dir; then
diff -urN a/Include/objimpl.h b/Include/objimpl.h
--- a/Include/objimpl.h	2013-05-12 04:32:41.000000000 +0100
+++ b/Include/objimpl.h	2013-05-17 23:57:26.929332576 +0100
@@ -256,6 +256,12 @@
         Py_ssize_t gc_refs;
     } gc;
     long double dummy;  /* force worst-case alignment */
+#if defined(__MINGW32__)
+/* FIXME: what about 64-bit platforms ?
+ * see http://mail.python.org/pipermail/python-dev/2009-July/090724.html
+ */
+	double dummy1;
+#endif
 } PyGC_Head;
 
 extern PyGC_Head *_PyGC_generation0;
diff -urN a/Include/pymath.h b/Include/pymath.h
--- a/Include/pymath.h	2013-05-12 04:32:41.000000000 +0100
+++ b/Include/pymath.h	2013-05-17 23:57:26.930332588 +0100
@@ -109,6 +109,8 @@
  *    non-infinite value v sitting in an 80-bit x87 register such that
  *    v becomes infinite when spilled from the register to 64-bit memory.
  * Note: PC/pyconfig.h defines Py_IS_INFINITY as _isinf
+ * FIXME: PC/pyconfig.h defines Py_IS_INFINITY as (!_finite(X) && !_isnan(X))
+ * so that above note isn't correct !!!
  */
 #ifndef Py_IS_INFINITY
 #  if defined HAVE_DECL_ISINF && HAVE_DECL_ISINF == 1
diff -urN a/Include/pyport.h b/Include/pyport.h
--- a/Include/pyport.h	2013-05-12 04:32:41.000000000 +0100
+++ b/Include/pyport.h	2013-05-17 23:57:26.930332588 +0100
@@ -693,6 +693,137 @@
 #endif /* 0 */
 
 
+#ifdef __MINGW32__
+/* FIXME: some of next definitions specific to gcc(mingw build) can be
+   generalized on definitions of _WIN32 or WIN32 and to be common for
+   all windows build instead explicitly to define only for non-autotools
+   based builds (see PC/pyconfig.h for details). */
+#if !defined(MS_WIN64) && defined(_WIN64)
+#  define MS_WIN64
+#endif
+#if !defined(MS_WIN32) && defined(_WIN32)
+#  define MS_WIN32
+#endif
+#if !defined(MS_WIN32) && defined(_WIN32)
+#  define MS_WIN32
+#endif
+#if !defined(MS_WINDOWS) && defined(MS_WIN32)
+#  define MS_WINDOWS
+#endif
+
+#ifndef PYTHONPATH
+#  define PYTHONPATH ".\\DLLs;.\\lib;.\\lib\\plat-win;.\\lib\\lib-tk"
+#endif
+
+/* python 2.6+ requires Windows 2000 or greater. */
+#define Py_WINVER 0x0500
+
+#if defined(Py_BUILD_CORE) || defined(Py_BUILD_CORE_MODULE)
+/* FIXME if NTDDI_xxx is in use by mingw (see PC/pyconfig.h) */
+#ifndef WINVER
+#  define WINVER Py_WINVER
+#endif
+#ifndef _WIN32_WINNT
+#  define _WIN32_WINNT Py_WINVER
+#endif
+#endif
+
+#ifdef PLATFORM
+/*NOTE: if compile getplatform.c PLATFORM is set to MACHDEP that is
+  "win" for mingw build (see respective comment in configure.in). */
+# undef PLATFORM
+#endif
+/* always set to "win32" - see PC/pyconfig.h */
+#define PLATFORM "win32"
+
+#if defined(MS_WIN64)
+#  define SIZEOF_HKEY 8
+#elif defined(MS_WIN32)
+#  define SIZEOF_HKEY 4
+#endif
+
+/*NOTE: mingw has isinf as macro defined in math.h.
+  Since PC/pyconfig.h define Py_IS_INFINITY(X) that cover HAVE_DECL_ISFINITE
+  here for Py_IS_INFINITY we define same as for MSVC build.
+  This makes HAVE_DECL_ISFINITE needless.
+  Also see commants in configure.in and pymath.h. */
+#define Py_IS_INFINITY(X) (!_finite(X) && !_isnan(X))
+
+#ifndef HAVE_LARGEFILE_SUPPORT
+/*
+  FIXME: on windows platforms:
+   - Python use PY_LONG_LONG(!) for Py_off_t (_fileio.c);
+   - HAVE_LARGEFILE_SUPPORT is defined in PC/pyconfig.h;
+   - PC/pyconfig.h define 4 for SIZEOF_OFF_T and 8 for SIZEOF_FPOS_T;
+   - If HAVE_LARGEFILE_SUPPORT isn't defined python will use off_t(!)
+   for Py_off_t (see fileobjects.c and bz2module.c).
+  Since for mingw configure detect 4 for size of "off_t" and 8 - for
+  "fpos_t" we has to define HAVE_LARGEFILE_SUPPORT too.
+  TODO: to test with AC_SYS_LARGEFILE and appropriate updates in
+  python code.
+*/
+#  define HAVE_LARGEFILE_SUPPORT
+#endif
+
+#if defined(Py_ENABLE_SHARED)
+#  define MS_COREDLL 1 /* deprecated old symbol, but still in use for windows code */
+#else
+#  define MS_NO_COREDLL 1
+#endif
+
+#if Py_UNICODE_SIZE == 2
+/* For mingw is 2 but FIXME: What about to raise error in configure if
+   unicode size isn't two ? Did python windows code support ucs4 ? */
+#  define Py_WIN_WIDE_FILENAMES
+#endif
+
+/* NOTE: Don't define HAVE_STDDEF_H.
+ * It is defined by PC/pyconfig.h and used by Include/Python.h
+ * (with comment For size_t?) but isn't required for mingw  */
+#define Py_SOCKET_FD_CAN_BE_GE_FD_SETSIZE
+
+/* All other defines from PC/pyconfig.h are in autoconf generated
+   pyconfig.h */
+#if 0
+/*FIXME:
+  MSDN:
+    "The getaddrinfo function was added to the ws2_32.dll on Windows XP
+    and later."
+  mingw:
+    getaddrinfo and getnameinfo is defined for WINVER >= 0x0501.
+  PC/pyconfig.h:
+    "Python 2.6+ requires Windows 2000 or greater"
+  So far so good but socketmodule.h define HAVE_GETADDRINFO and
+  HAVE_GETNAMEINFO under very specific condition :
+    # ifdef SIO_GET_MULTICAST_FILTER
+    #  include <MSTcpIP.h>
+  So the question is "Separate SDKs" required for w2k in MSVC build ?
+  TODO: resolve later, may by configure :-/. For now python code will
+  use fake implementation and if user define appropriate value for
+  WINVER - the functionas from C runtime.
+  For details see socketmodule.c .
+  */
+#ifndef HAVE_GETADDRINFO
+#  define HAVE_GETADDRINFO
+#endif
+#ifndef HAVE_GETNAMEINFO
+#  define HAVE_GETNAMEINFO
+#endif
+#endif
+
+/* Refer to <Modules/_math.h> .
+   For mingw host configure detect functions described as HAVE_XXX
+   in _math.h but as MSVC don't define them we will undefine HAVE_XXX
+   too to use _Py_* replacements same as MSVC build .
+ */
+#undef HAVE_ACOSH
+#undef HAVE_ASINH
+#undef HAVE_ATANH
+#undef HAVE_EXPM1
+#undef HAVE_LOG1P
+
+#endif /*def __MINGW32__*/
+
 /* On 4.4BSD-descendants, ctype functions serves the whole range of
  * wchar_t character set rather than single byte code points only.
  * This characteristic can break some operations of string object
@@ -746,12 +877,12 @@
 */
 
 /*
-  All windows ports, except cygwin, are handled in PC/pyconfig.h.
+  MSVC windows port is handled in PC/pyconfig.h.
 
-  BeOS and cygwin are the only other autoconf platform requiring special
-  linkage handling and both of these use __declspec().
+  BeOS, mingw32 and cygwin use autoconf and require special
+  linkage handling and all of these use __declspec().
 */
-#if defined(__CYGWIN__) || defined(__BEOS__)
+#if defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BEOS__)
 #       define HAVE_DECLSPEC_DLL
 #endif
 
@@ -774,9 +905,17 @@
         /* Under Cygwin, auto-import functions to prevent compilation */
         /* failures similar to those described at the bottom of 4.1: */
         /* http://docs.python.org/extending/windows.html#a-cookbook-approach */
-#                       if !defined(__CYGWIN__)
+#                       if !defined(__CYGWIN__) && !defined(__MINGW32__)
 #                               define PyAPI_FUNC(RTYPE) __declspec(dllimport) RTYPE
-#                       endif /* !__CYGWIN__ */
+#                       else
+#                               define PyAPI_FUNC(RTYPE) RTYPE
+#                       endif /* !__CYGWIN__  !__MINGW32__ */
+            /* NOTE: The issue3945 "compile error in _fileio.c (cygwin)"
+             * was resolved with modification of code.
+             * This issue was resolved for gcc(mingw) with enabling auto
+             * import feature. Since _fileio.c problem now disappear there
+             * is no more reasons to avoid dllimport for gcc(mingw).
+             */
 #                       define PyAPI_DATA(RTYPE) extern __declspec(dllimport) RTYPE
         /* module init functions outside the core must be exported */
 #                       if defined(__cplusplus)
diff -urN a/Lib/ctypes/test/test_as_parameter.py b/Lib/ctypes/test/test_as_parameter.py
--- a/Lib/ctypes/test/test_as_parameter.py	2013-05-12 04:32:42.000000000 +0100
+++ b/Lib/ctypes/test/test_as_parameter.py	2013-05-17 23:57:26.930332588 +0100
@@ -1,6 +1,7 @@
 import unittest
 from ctypes import *
 import _ctypes_test
+import sys
 
 dll = CDLL(_ctypes_test.__file__)
 
@@ -171,6 +172,10 @@
         s2h = dll.ret_2h_func(self.wrap(inp))
         self.assertEqual((s2h.x, s2h.y), (99*2, 88*3))
 
+    # This is known cdecl incompatibility between GCC
+    # and MSVC. It is addressed in GCC issue #36834.
+    # Python libffi detect it and complain.
+    @unittest.skipIf(sys.platform == "win32" and sys.version.find("GCC") >= 0, 'XFAIL GCC(mingw)')
     def test_struct_return_8H(self):
         class S8I(Structure):
             _fields_ = [("a", c_int),
diff -urN a/Lib/ctypes/test/test_functions.py b/Lib/ctypes/test/test_functions.py
--- a/Lib/ctypes/test/test_functions.py	2013-05-12 04:32:42.000000000 +0100
+++ b/Lib/ctypes/test/test_functions.py	2013-05-17 23:57:26.931332600 +0100
@@ -359,6 +359,10 @@
             s2h = windll.s_ret_2h_func(S2H(99, 88))
             self.assertEqual((s2h.x, s2h.y), (99*2, 88*3))
 
+    # This is known cdecl incompatibility between GCC
+    # and MSVC. It is addressed in GCC issue #36834.
+    # Python libffi detect it and complain.
+    @unittest.skipIf(sys.platform == "win32" and sys.version.find("GCC") >= 0, 'XFAIL GCC(mingw)')
     def test_struct_return_8H(self):
         class S8I(Structure):
             _fields_ = [("a", c_int),
diff -urN a/Lib/ctypes/util.py b/Lib/ctypes/util.py
--- a/Lib/ctypes/util.py	2013-05-12 04:32:42.000000000 +0100
+++ b/Lib/ctypes/util.py	2013-05-17 23:57:26.931332600 +0100
@@ -7,6 +7,11 @@
 if os.name == "nt":
 
     def _get_build_version():
+        #***********************************************************
+        # NOTE: As example for GCC(mingw) build sys.version return:
+        # '2.7a0 (trunk:<REVISION>M, <DATE>, <TIME>) \n[GCC 3.4.5 (mingw special)]'
+        # '2.7a0 (trunk:<REVISION>M, <DATE>, <TIME>) \n[GCC 4.4.0]'
+        #***********************************************************
         """Return the version of MSVC that was used to build Python.
 
         For Python 2.3 and up, the version number is included in
@@ -30,6 +35,15 @@
         return None
 
     def find_msvcrt():
+        #************************************************************
+        # FIXME: For GCC(mingw) runtime don't depend from compiler
+        # version ;). We may use -D__MSVCRT_VERSION__ to detect which
+        # verion is requested by user, but the name of the library
+        # to be default.
+        # As example WXP is with version 7.0 of msvcrt.dll.
+        # Anyway since _get_build_version return 6 in most(standard)
+        # cases this method will return msvcrt{d}. May be not so bad.
+        #************************************************************
         """Return the name of the VC runtime dll"""
         version = _get_build_version()
         if version is None:
diff -urN a/Lib/distutils/ccompiler.py b/Lib/distutils/ccompiler.py
--- a/Lib/distutils/ccompiler.py	2013-05-12 04:32:42.000000000 +0100
+++ b/Lib/distutils/ccompiler.py	2013-05-17 23:57:26.931332600 +0100
@@ -918,6 +918,8 @@
         osname = os.name
     if platform is None:
         platform = sys.platform
+    if osname == "nt" and sys.version.find('GCC') >= 0:
+        return 'mingw32'
     for pattern, compiler in _default_compilers:
         if re.match(pattern, platform) is not None or \
            re.match(pattern, osname) is not None:
diff -urN a/Lib/distutils/command/build_ext.py b/Lib/distutils/command/build_ext.py
--- a/Lib/distutils/command/build_ext.py	2013-05-12 04:32:42.000000000 +0100
+++ b/Lib/distutils/command/build_ext.py	2013-05-17 23:57:26.932332611 +0100
@@ -19,7 +19,8 @@
 from distutils.util import get_platform
 from distutils import log
 
-if os.name == 'nt':
+# GCC(mingw): os.name is "nt" but build system is posix
+if os.name == 'nt' and sys.version.find('GCC') < 0:
     from distutils.msvccompiler import get_build_version
     MSVC_VERSION = int(get_build_version())
 
@@ -179,7 +180,8 @@
         # for extensions under windows use different directories
         # for Release and Debug builds.
         # also Python's library directory must be appended to library_dirs
-        if os.name == 'nt':
+        # GCC(mingw): os.name is "nt" but build system is posix
+        if os.name == 'nt' and sys.version.find('GCC') < 0:
             # the 'libs' directory is for binary installs - we assume that
             # must be the *native* platform.  But we don't really support
             # cross-compiling via a binary install anyway, so we let it go.
@@ -221,7 +223,8 @@
 
         # for extensions under Cygwin and AtheOS Python's library directory must be
         # appended to library_dirs
-        if sys.platform[:6] == 'cygwin' or sys.platform[:6] == 'atheos':
+        if (sys.platform[:6] == 'cygwin' or sys.platform[:6] == 'atheos'
+            or (sys.platform == 'win32' and sys.version.find('GCC') >= 0)):
             if sys.executable.startswith(os.path.join(sys.exec_prefix, "bin")):
                 # building third party extensions
                 self.library_dirs.append(os.path.join(sys.prefix, "lib",
@@ -699,6 +702,34 @@
         # pyconfig.h that MSVC groks.  The other Windows compilers all seem
         # to need it mentioned explicitly, though, so that's what we do.
         # Append '_d' to the python import library on debug builds.
+
+        # FIXME: What is purpose of code below ?
+        # The posix build system khow requred libraries to build a module.
+        # The libraries are stored in config(Makefile) variables BLDLIBRARY,
+        # MODLIBS and SHLIBS. Note that some variables may contain linker
+        # flags.
+        # NOTE: For now we will check only GCC(mingw) compiler as is clear
+        # that we build for windows platfrom.
+        # The code for GCC(mingw) is not correct but this is distutils
+        # limitation - we has to pass variables to the linker as is
+        # instead only library names.
+        if self.compiler.compiler_type == 'mingw32':
+            from distutils import sysconfig
+            template = "python%s"
+            if self.debug:
+                template = template + '_d'
+            extra = [(template % (sysconfig.get_config_var('VERSION')))]
+            for lib in sysconfig.get_config_var('BLDLIBRARY').split():
+                if lib.startswith('-l'):
+                    extra.append(lib[2:])
+            for lib in sysconfig.get_config_var('MODLIBS').split():
+                if lib.startswith('-l'):
+                    extra.append(lib[2:])
+            for lib in sysconfig.get_config_var('SHLIBS').split():
+                if lib.startswith('-l'):
+                    extra.append(lib[2:])
+            return ext.libraries + extra
+
         if sys.platform == "win32":
             from distutils.msvccompiler import MSVCCompiler
             if not isinstance(self.compiler, MSVCCompiler):
diff -urN a/Lib/distutils/cygwinccompiler.py b/Lib/distutils/cygwinccompiler.py
--- a/Lib/distutils/cygwinccompiler.py	2013-05-12 04:32:42.000000000 +0100
+++ b/Lib/distutils/cygwinccompiler.py	2013-05-17 23:57:26.932332611 +0100
@@ -60,6 +60,18 @@
     """Include the appropriate MSVC runtime library if Python was built
     with MSVC 7.0 or later.
     """
+    # FIXME: next code is from issue870382
+    # MS C-runtime libraries never support backward compatibility.
+    # Linking to a different library without to specify correct runtime
+    # version for the headers will link renamed functions to msvcrt.
+    # See issue3308: this piece of code is python problem even
+    # with correct w32api headers.
+    # Issue: for MSVC compiler we can get the version and from version
+    # to determine mcvcrt as code below. But what about if python is
+    # build with GCC compiler?
+    # Output of sys.version is information for python build on first
+    # line, on the next line is information for the compiler and the
+    # output lack information for the C-runtime.
     msc_pos = sys.version.find('MSC v.')
     if msc_pos != -1:
         msc_ver = sys.version[msc_pos+6:msc_pos+10]
@@ -77,6 +89,8 @@
             return ['msvcr90']
         else:
             raise ValueError("Unknown MS Compiler version %s " % msc_ver)
+    else:
+        return []
 
 
 class CygwinCCompiler (UnixCCompiler):
@@ -85,6 +99,9 @@
     obj_extension = ".o"
     static_lib_extension = ".a"
     shared_lib_extension = ".dll"
+    # FIXME: dylib_... = ".dll.a" is not enought for binutils
+    # loader on win32 platform !!!
+    dylib_lib_extension = ".dll.a"
     static_lib_format = "lib%s%s"
     shared_lib_format = "%s%s"
     exe_extension = ".exe"
@@ -103,6 +120,10 @@
                 "Compiling may fail because of undefined preprocessor macros."
                 % details)
 
+        # Next line of code is problem for cross-compiled enviroment:
+        # NOTE: GCC cross-compiler is prefixed by the <hostarch>-<hostos>-
+        # and by default binaries are installed in same directory
+        # as native compiler.
         self.gcc_version, self.ld_version, self.dllwrap_version = \
             get_versions()
         self.debug_print(self.compiler_type + ": gcc %s, ld %s, dllwrap %s\n" %
@@ -127,6 +148,9 @@
         else:
             shared_option = "-mdll -static"
 
+        # FIXME:
+        # Hard-code may override unix-compiler settings and isn't
+        # possible to use Makefile variables to pass correct flags !
         # Hard-code GCC because that's what this is all about.
         # XXX optimization, warnings etc. should be customizable.
         self.set_executables(compiler='gcc -mcygwin -O -Wall',
@@ -271,12 +295,20 @@
         if output_dir is None: output_dir = ''
         obj_names = []
         for src_name in source_filenames:
-            # use normcase to make sure '.rc' is really '.rc' and not '.RC'
-            (base, ext) = os.path.splitext (os.path.normcase(src_name))
+            # FIXME: "bogus checks for suffix" - as example the commented
+            # by #BOGUS# code break valid assembler suffix ".S" !
+            #BOGUS## use normcase to make sure '.rc' is really '.rc' and not '.RC'
+            #BOGUS#base, ext = os.path.splitext(os.path.normcase(src_name))
+            base, ext = os.path.splitext (src_name)
+            ext_normcase = os.path.normcase(ext)
+            if ext_normcase in ['.rc','.res']:
+                ext = ext_normcase
             if ext not in (self.src_extensions + ['.rc','.res']):
                 raise UnknownFileError, \
                       "unknown file type '%s' (from '%s')" % \
                       (ext, src_name)
+            base = os.path.splitdrive(base)[1] # Chop off the drive
+            base = base[os.path.isabs(base):]  # If abs, chop off leading /
             if strip_dir:
                 base = os.path.basename (base)
             if ext == '.res' or ext == '.rc':
diff -urN a/Lib/distutils/sysconfig.py b/Lib/distutils/sysconfig.py
--- a/Lib/distutils/sysconfig.py	2013-05-12 04:32:42.000000000 +0100
+++ b/Lib/distutils/sysconfig.py	2013-05-17 23:57:26.932332611 +0100
@@ -77,19 +77,21 @@
     if prefix is None:
         prefix = plat_specific and EXEC_PREFIX or PREFIX
 
-    if os.name == "posix":
+    # GCC(mingw): os.name is "nt" but build system is posix
+    if os.name == "posix" or sys.version.find('GCC') >= 0:
         if python_build:
-            buildir = os.path.dirname(sys.executable)
+            # NOTE: sysconfig.py-20091210
+            # Assume the executable is in the build directory.  The
+            # pyconfig.h file should be in the same directory.  Since
+            # the build directory may not be the source directory, we
+            # must use "srcdir" from the makefile to find the "Include"
+            # directory.
+            base = os.path.dirname(os.path.abspath(sys.executable))
             if plat_specific:
-                # python.h is located in the buildir
-                inc_dir = buildir
+                return base
             else:
-                # the source dir is relative to the buildir
-                srcdir = os.path.abspath(os.path.join(buildir,
-                                         get_config_var('srcdir')))
-                # Include is located in the srcdir
-                inc_dir = os.path.join(srcdir, "Include")
-            return inc_dir
+                incdir = os.path.join(get_config_var('srcdir'), 'Include')
+                return os.path.normpath(incdir)
         return os.path.join(prefix, "include", "python" + get_python_version())
     elif os.name == "nt":
         return os.path.join(prefix, "include")
@@ -153,8 +155,18 @@
 
     Mainly needed on Unix, so we can plug in the information that
     varies across Unices and is stored in Python's Makefile.
+
+    NOTE: (known limitation of python build/install system)
+    In cross-build environment make macros like CC and LDSHARED
+    contain cross-compiler/linker instead of host compiler/linker.
     """
+    posix_build = None
     if compiler.compiler_type == "unix":
+       posix_build = True
+    elif compiler.compiler_type == "mingw32":
+        if sys.version.find('GCC') >= 0:
+            posix_build = True
+    if posix_build == True:
         if sys.platform == "darwin":
             # Perform first-time customization of compiler-related
             # config vars on OS X now that we know we need a compiler.
@@ -218,7 +230,8 @@
 def get_config_h_filename():
     """Return full pathname of installed pyconfig.h file."""
     if python_build:
-        if os.name == "nt":
+        # GCC(mingw): os.name is "nt" but build system is posix
+        if os.name == "nt" and sys.version.find('GCC') < 0:
             inc_dir = os.path.join(project_base, "PC")
         else:
             inc_dir = project_base
@@ -396,6 +409,11 @@
 
 def _init_nt():
     """Initialize the module as appropriate for NT"""
+    if sys.version.find('GCC') >= 0:
+        # GCC(mingw) use posix build system
+        # FIXME: may be modification has to be in get_config_vars ?
+        _init_posix()
+        return
     g = {}
     # set basic install directories
     g['LIBDEST'] = get_python_lib(plat_specific=0, standard_lib=1)
diff -urN a/Lib/distutils/tests/test_bdist_msi.py b/Lib/distutils/tests/test_bdist_msi.py
--- a/Lib/distutils/tests/test_bdist_msi.py	2013-05-12 04:32:42.000000000 +0100
+++ b/Lib/distutils/tests/test_bdist_msi.py	2013-05-17 23:57:26.933332623 +0100
@@ -10,6 +10,7 @@
                        support.LoggingSilencer,
                        unittest.TestCase):
 
+    @unittest.skip("Require bdist_msi")
     def test_minimal(self):
         # minimal test XXX need more tests
         from distutils.command.bdist_msi import bdist_msi
diff -urN a/Lib/distutils/tests/test_build_ext.py b/Lib/distutils/tests/test_build_ext.py
--- a/Lib/distutils/tests/test_build_ext.py	2013-05-12 04:32:42.000000000 +0100
+++ b/Lib/distutils/tests/test_build_ext.py	2013-05-17 23:57:26.933332623 +0100
@@ -60,6 +60,11 @@
             sys.stdout = StringIO()
         try:
             cmd.ensure_finalized()
+            #Broken after issue 7712(r78136) : add a temp_cwd context manager to test_support ...
+            #Without current working dir: "...cannot find -lpython27"
+            #NOTE: [py3k svn r85559] First (uncontroversial) part of issue 9807, barry.warsaw, 2010-10-16 :
+            #  new _fixup_command is bogus, so we will use own work-around
+            cmd.library_dirs.insert(0, test_support.SAVEDCWD)
             cmd.run()
         finally:
             sys.stdout = old_stdout
@@ -281,6 +286,12 @@
         # returns wrong result with --inplace
         other_tmp_dir = os.path.realpath(self.mkdtemp())
         old_wd = os.getcwd()
+        #Without current working dir: "...cannot find -lpython27"
+        #NOTE: After issue #7712(r78136) test cannot use old_wd !
+        #cmd.library_dirs.insert(0, old_wd)
+        #NOTE: [py3k svn r85559] First (uncontroversial) part of issue 9807, barry.warsaw, 2010-10-16 :
+        #  new _fixup_command is bogus, so we will use own work-around
+        cmd.library_dirs.insert(0, test_support.SAVEDCWD)
         os.chdir(other_tmp_dir)
         try:
             cmd.inplace = 1
diff -urN a/Lib/distutils/tests/test_config_cmd.py b/Lib/distutils/tests/test_config_cmd.py
--- a/Lib/distutils/tests/test_config_cmd.py	2013-05-12 04:32:42.000000000 +0100
+++ b/Lib/distutils/tests/test_config_cmd.py	2013-05-17 23:57:26.933332623 +0100
@@ -38,6 +38,7 @@
         self.assertEqual(len(self._logs), numlines+1)
 
     def test_search_cpp(self):
+        # TODO: mingw host ?
         if sys.platform == 'win32':
             return
         pkg_dir, dist = self.create_dist()
diff -urN a/Lib/distutils/tests/test_sysconfig.py b/Lib/distutils/tests/test_sysconfig.py
--- a/Lib/distutils/tests/test_sysconfig.py	2013-05-12 04:32:42.000000000 +0100
+++ b/Lib/distutils/tests/test_sysconfig.py	2013-05-17 23:57:26.933332623 +0100
@@ -43,9 +43,15 @@
         # This is not much of a test.  We make sure Python.h exists
         # in the directory returned by get_python_inc() but we don't know
         # it is the correct file.
+        #Broken after issue 7712(r78136) : add a temp_cwd context manager to test_support ...
+        #NOTE: Its fail on platforms without root directory support(like windows)
+        #where temp and current working directories may stay on different drivers.
+        old_wd = os.getcwd()
+        os.chdir(SAVEDCWD)
         self.assertTrue(os.path.isdir(inc_dir), inc_dir)
         python_h = os.path.join(inc_dir, "Python.h")
         self.assertTrue(os.path.isfile(python_h), python_h)
+        os.chdir(old_wd)
 
     def test_parse_makefile_base(self):
         self.makefile = test.test_support.TESTFN
diff -urN a/Lib/distutils/tests/test_unixccompiler.py b/Lib/distutils/tests/test_unixccompiler.py
--- a/Lib/distutils/tests/test_unixccompiler.py	2013-05-12 04:32:42.000000000 +0100
+++ b/Lib/distutils/tests/test_unixccompiler.py	2013-05-17 23:57:26.934332635 +0100
@@ -120,7 +120,7 @@
         def gcv(v):
             return 'xxx'
         sysconfig.get_config_var = gcv
-        self.assertEqual(self.cc.rpath_foo(), '-R/foo')
+        self.assertEqual(self.cc.rpath_foo(), '-blibpath:/foo')
 
 
 def test_suite():
diff -urN a/Lib/distutils/unixccompiler.py b/Lib/distutils/unixccompiler.py
--- a/Lib/distutils/unixccompiler.py	2013-05-12 04:32:42.000000000 +0100
+++ b/Lib/distutils/unixccompiler.py	2013-05-17 23:57:26.934332635 +0100
@@ -234,6 +234,8 @@
             return ["+s", "-L" + dir]
         elif sys.platform[:7] == "irix646" or sys.platform[:6] == "osf1V5":
             return ["-rpath", dir]
+        elif sys.platform[:3] == "aix":
+            return "-blibpath:" + dir
         elif self._is_gcc(compiler):
             return "-Wl,-R" + dir
         else:
diff -urN a/Lib/sysconfig.py b/Lib/sysconfig.py
--- a/Lib/sysconfig.py	2013-05-12 04:32:45.000000000 +0100
+++ b/Lib/sysconfig.py	2013-05-17 23:57:26.934332635 +0100
@@ -130,8 +130,13 @@
 
 if _PYTHON_BUILD:
     for scheme in ('posix_prefix', 'posix_home'):
-        _INSTALL_SCHEMES[scheme]['include'] = '{projectbase}/Include'
-        _INSTALL_SCHEMES[scheme]['platinclude'] = '{srcdir}'
+        _INSTALL_SCHEMES[scheme]['include'] = '{srcdir}/Include'
+        _INSTALL_SCHEMES[scheme]['platinclude'] = '{projectbase}'
+
+    # GCC(mingw) use posix build system
+    if os.name == "nt" and sys.version.find('GCC') >= 0:
+        _INSTALL_SCHEMES['nt']['include'] = '{srcdir}/Include'
+        _INSTALL_SCHEMES['nt']['platinclude'] = '{projectbase}'
 
 def _subst_vars(s, local_vars):
     try:
@@ -400,7 +405,8 @@
 def get_config_h_filename():
     """Returns the path of pyconfig.h."""
     if _PYTHON_BUILD:
-        if os.name == "nt":
+        # GCC(mingw): os.name is "nt" but build system is posix
+        if os.name == "nt" and sys.version.find('GCC') < 0:
             inc_dir = os.path.join(_PROJECT_BASE, "PC")
         else:
             inc_dir = _PROJECT_BASE
@@ -462,9 +468,19 @@
         _CONFIG_VARS['platbase'] = _EXEC_PREFIX
         _CONFIG_VARS['projectbase'] = _PROJECT_BASE
 
-        if os.name in ('nt', 'os2'):
-            _init_non_posix(_CONFIG_VARS)
+        # GCC(mingw) use posix build system
+        posix_build = None
         if os.name == 'posix':
+            posix_build = True
+        else:
+            if os.name in ('nt', 'os2'):
+                if sys.version.find('GCC') >= 0:
+                    posix_build = True
+                else:
+                    posix_build = False
+        if posix_build == False:
+            _init_non_posix(_CONFIG_VARS)
+        if posix_build == True:
             _init_posix(_CONFIG_VARS)
 
         # Setting 'userbase' is done below the call to the
@@ -479,7 +495,7 @@
         # Normally it is relative to the build directory.  However, during
         # testing, for example, we might be running a non-installed python
         # from a different directory.
-        if _PYTHON_BUILD and os.name == "posix":
+        if _PYTHON_BUILD and posix_build == True:
             base = _PROJECT_BASE
             try:
                 cwd = os.getcwd()
diff -urN a/Lib/test/regrtest.py b/Lib/test/regrtest.py
--- a/Lib/test/regrtest.py	2013-05-12 04:32:45.000000000 +0100
+++ b/Lib/test/regrtest.py	2013-05-17 23:57:26.934332635 +0100
@@ -389,7 +389,7 @@
             found_garbage = []
 
     if single:
-        filename = os.path.join(TEMPDIR, 'pynexttest')
+        filename = os.path.join(tempfile.gettempdir(), 'pynexttest')
         try:
             fp = open(filename, 'r')
             next_test = fp.read().strip()
@@ -1542,8 +1542,7 @@
     # to keep the test files in a subfolder.  It eases the cleanup of leftover
     # files using command "make distclean".
     if sysconfig.is_python_build():
-        TEMPDIR = os.path.join(sysconfig.get_config_var('srcdir'), 'build')
-        TEMPDIR = os.path.abspath(TEMPDIR)
+        TEMPDIR = os.path.abspath('build')
         if not os.path.exists(TEMPDIR):
             os.mkdir(TEMPDIR)
 
diff -urN a/Lib/test/test_curses.py b/Lib/test/test_curses.py
--- a/Lib/test/test_curses.py	2013-05-12 04:32:46.000000000 +0100
+++ b/Lib/test/test_curses.py	2013-05-17 23:57:26.935332647 +0100
@@ -167,11 +167,16 @@
     curses.delay_output(1)
     curses.echo() ; curses.echo(1)
 
-    f = tempfile.TemporaryFile()
+    fx = tempfile.TemporaryFile()
+    # cf tempfile.py TemporaryFile vs NamedTemporaryFile
+    if os.name != 'posix' or os.sys.platform == 'cygwin':
+        f = fx.file
+    else:
+        f = fx
     stdscr.putwin(f)
     f.seek(0)
     curses.getwin(f)
-    f.close()
+    fx.close()
 
     curses.halfdelay(1)
     curses.intrflush(1)
diff -urN a/Lib/test/test_os.py b/Lib/test/test_os.py
--- a/Lib/test/test_os.py	2013-05-12 04:32:47.000000000 +0100
+++ b/Lib/test/test_os.py	2013-05-17 23:57:26.935332647 +0100
@@ -325,7 +325,11 @@
 
             def test_large_time(self):
                 t1 = 5000000000 # some day in 2128
-                os.utime(self.fname, (t1, t1))
+                try:
+                    #Note fail if time_t is 32 bit
+                    os.utime(self.fname, (t1, t1))
+                except OverflowError:
+                    self.skipTest("requires at least 64-bit time_t")
                 self.assertEqual(os.stat(self.fname).st_mtime, t1)
 
         def test_1686475(self):
diff -urN a/Lib/test/test_sundry.py b/Lib/test/test_sundry.py
--- a/Lib/test/test_sundry.py	2013-05-12 04:32:47.000000000 +0100
+++ b/Lib/test/test_sundry.py	2013-05-17 23:57:26.935332647 +0100
@@ -27,7 +27,11 @@
 
             import distutils.command.bdist_dumb
             if sys.platform.startswith('win'):
-                import distutils.command.bdist_msi
+                try:
+                    import distutils.command.bdist_msi # if msi module is not build
+                except ImportError:
+                    if test_support.verbose:
+                        print "skipping bdist_msi"
             import distutils.command.bdist
             import distutils.command.bdist_rpm
             import distutils.command.bdist_wininst
diff -urN a/Makefile.pre.in b/Makefile.pre.in
--- a/Makefile.pre.in	2013-05-12 04:32:49.000000000 +0100
+++ b/Makefile.pre.in	2013-05-17 23:57:26.936332659 +0100
@@ -207,7 +207,7 @@
 # Modules
 MODULE_OBJS=	\
 		Modules/config.o \
-		Modules/getpath.o \
+		@MODULE_GETPATH@ \
 		Modules/main.o \
 		Modules/gcmodule.o
 
@@ -304,7 +304,7 @@
 		Python/codecs.o \
 		Python/errors.o \
 		Python/frozen.o \
-		Python/frozenmain.o \
+		@PYTHON_OBJS_FROZENMAIN@ \
 		Python/future.o \
 		Python/getargs.o \
 		Python/getcompiler.o \
@@ -573,6 +573,7 @@
 	      -DHGBRANCH="\"`LC_ALL=C $(HGBRANCH)`\"" \
 	      -o $@ $(srcdir)/Modules/getbuildinfo.c
 
+# default sys.path calculations
 Modules/getpath.o: $(srcdir)/Modules/getpath.c Makefile
 	$(CC) -c $(PY_CFLAGS) -DPYTHONPATH='"$(PYTHONPATH)"' \
 		-DPREFIX='"$(prefix)"' \
@@ -581,6 +582,10 @@
 		-DVPATH='"$(VPATH)"' \
 		-o $@ $(srcdir)/Modules/getpath.c
 
+# default sys.path calculations for windows platforms
+PC/getpathp.o: $(srcdir)/PC/getpathp.c
+	$(CC) -c $(PY_CFLAGS) -o $@ $(srcdir)/PC/getpathp.c
+
 Modules/python.o: $(srcdir)/Modules/python.c
 	$(MAINCC) -c $(PY_CFLAGS) -o $@ $(srcdir)/Modules/python.c
 
diff -urN a/Modules/_ctypes/_ctypes.c b/Modules/_ctypes/_ctypes.c
--- a/Modules/_ctypes/_ctypes.c	2013-05-12 04:32:49.000000000 +0100
+++ b/Modules/_ctypes/_ctypes.c	2013-05-17 23:57:26.936332659 +0100
@@ -3166,11 +3166,27 @@
     mangled_name = alloca(strlen(name) + 1 + 1 + 1 + 3); /* \0 _ @ %d */
     if (!mangled_name)
         return NULL;
+    /* FIXME: for stdcall decorated export functions MSVC compiler add
+     * underscore, but GCC compiler create them without.
+     * As well functions from system libraries are without underscore.
+     * This is visible by example for _ctypes_test.pyd module.
+     * Solutions:
+     * - If a python module is build with gcc option --add-stdcall-alias
+     * the module will contain XXX as alias for function XXX@ as result
+     * first search in this method will succeed.
+     * - Distutil may use compiler to create def-file, to modify it as
+     * add underscore alias and with new def file to create module.
+     * - Or may be just to search for function without underscore.
+     */
     for (i = 0; i < 32; ++i) {
         sprintf(mangled_name, "_%s@%d", name, i*4);
         address = (PPROC)GetProcAddress(handle, mangled_name);
         if (address)
             return address;
+        sprintf(mangled_name, "%s@%d", name, i*4);
+        address = (PPROC)GetProcAddress(handle, mangled_name);
+        if (address)
+            return address;
     }
     return NULL;
 #endif
diff -urN a/Modules/_ctypes/libffi_msvc/win32.S b/Modules/_ctypes/libffi_msvc/win32.S
--- a/Modules/_ctypes/libffi_msvc/win32.S	1970-01-01 01:00:00.000000000 +0100
+++ b/Modules/_ctypes/libffi_msvc/win32.S	2013-05-17 23:57:26.937332670 +0100
@@ -0,0 +1,154 @@
+/* -----------------------------------------------------------------------
+   win32.S - Copyright (c) 1996, 1998, 2001, 2002  Red Hat, Inc.
+	     Copyright (c) 2001  John Beniton
+	     Copyright (c) 2002  Ranjit Mathew
+
+
+   X86 Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+   IN NO EVENT SHALL CYGNUS SOLUTIONS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+   OTHER DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+.text
+
+.globl ffi_prep_args
+
+        # This assumes we are using gas.
+        .balign 16
+.globl _ffi_call_x86
+
+_ffi_call_x86:
+        pushl %ebp
+        movl  %esp,%ebp
+
+	#THe: save previous %esi, and store the current stack pointer in %esi
+	pushl %esi
+	movl %esp,%esi
+
+        # Make room for all of the new args.
+        movl  16(%ebp),%ecx
+        subl  %ecx,%esp
+
+        movl  %esp,%eax
+
+        # Place all of the ffi_prep_args in position
+        pushl 12(%ebp)
+        pushl %eax
+        call  *8(%ebp)
+
+        # Return stack to previous state and call the function
+        addl  $8,%esp
+
+        # FIXME: Align the stack to a 128-bit boundary to avoid
+        # potential performance hits.
+
+	call  *28(%ebp)
+
+	# Load ecif->cif->abi
+#masm#	mov ecx, [ebp + 12]
+        movl  12(%ebp),%ecx
+#masm#	mov ecx, [ecx]ecif.cif
+	movl  (%ecx),%ecx
+#masm#	mov ecx, [ecx]ecif.cif.abi
+	movl  (%ecx),%ecx
+#masm#	cmp ecx, FFI_STDCALL
+        cmpl  $2,%ecx
+        je   noclean
+
+	# STDCALL: Remove the space we pushed for the args
+        movl  16(%ebp),%ecx
+        addl  %ecx,%esp
+
+	# CDECL: Caller has already cleaned the stack
+noclean:
+	# Check that esp has the same value as before!
+	sub %esp,%esi # calculate stack pointer difference
+
+        # Load %ecx with the return type code
+        movl  20(%ebp),%ecx
+
+        # If the return value pointer is NULL, assume no return value.
+        cmpl  $0,24(%ebp)
+        jne   retint
+
+        # Even if there is no space for the return value, we are
+        # obliged to handle floating-point values.
+        cmpl  $FFI_TYPE_FLOAT,%ecx
+        jne   noretval
+        fstp  %st(0)
+
+        jmp   epilogue
+
+retint:
+        cmpl  $FFI_TYPE_INT,%ecx
+        jne   retfloat
+        # Load %ecx with the pointer to storage for the return value
+        movl  24(%ebp),%ecx
+        movl  %eax,0(%ecx)
+        jmp   epilogue
+
+retfloat:
+        cmpl  $FFI_TYPE_FLOAT,%ecx
+        jne   retdouble
+         # Load %ecx with the pointer to storage for the return value
+        movl  24(%ebp),%ecx
+        fstps (%ecx)
+        jmp   epilogue
+
+retdouble:
+        cmpl  $FFI_TYPE_DOUBLE,%ecx
+        jne   retlongdouble
+        # Load %ecx with the pointer to storage for the return value
+        movl  24(%ebp),%ecx
+        fstpl (%ecx)
+        jmp   epilogue
+
+retlongdouble:
+        cmpl  $FFI_TYPE_LONGDOUBLE,%ecx
+        jne   retint64
+        # Load %ecx with the pointer to storage for the return value
+        movl  24(%ebp),%ecx
+        fstpt (%ecx)
+        jmp   epilogue
+
+retint64:
+        cmpl  $FFI_TYPE_SINT64,%ecx
+        jne   retstruct
+        # Load %ecx with the pointer to storage for the return value
+        movl  24(%ebp),%ecx
+        movl  %eax,0(%ecx)
+        movl  %edx,4(%ecx)
+
+retstruct:
+        # Nothing to do!
+
+noretval:
+epilogue:
+	movl %esi,%eax # return the stack pointer detlta in %eax
+	popl %esi # restore previous %esi
+        movl %ebp,%esp
+        popl %ebp
+        ret
+
+.ffi_call_x86_end:
diff -urN a/Modules/getaddrinfo.c b/Modules/getaddrinfo.c
--- a/Modules/getaddrinfo.c	2013-05-12 04:32:51.000000000 +0100
+++ b/Modules/getaddrinfo.c	2013-05-17 23:57:26.937332670 +0100
@@ -232,6 +232,9 @@
     return YES;
 }
 
+#ifndef EAI_BADHINTS
+#  define EAI_BADHINTS EAI_BADFLAGS
+#endif
 int
 getaddrinfo(const char*hostname, const char*servname,
             const struct addrinfo *hints, struct addrinfo **res)
diff -urN a/Modules/getnameinfo.c b/Modules/getnameinfo.c
--- a/Modules/getnameinfo.c	2013-05-12 04:32:51.000000000 +0100
+++ b/Modules/getnameinfo.c	2013-05-17 23:57:26.937332670 +0100
@@ -48,6 +48,14 @@
 #include "addrinfo.h"
 #endif
 
+#ifndef IN_EXPERIMENTAL
+#define IN_EXPERIMENTAL(i)  (((i) & 0xe0000000U) == 0xe0000000U)
+#endif
+
+#ifndef IN_LOOPBACKNET
+#define IN_LOOPBACKNET	    127
+#endif
+
 #define SUCCESS 0
 #define YES 1
 #define NO  0
diff -urN a/Modules/_io/fileio.c b/Modules/_io/fileio.c
--- a/Modules/_io/fileio.c	2013-05-12 04:32:50.000000000 +0100
+++ b/Modules/_io/fileio.c	2013-05-17 23:57:26.938332682 +0100
@@ -29,7 +29,9 @@
 
 #ifdef MS_WINDOWS
 /* can simulate truncate with Win32 API functions; see file_truncate */
+#ifndef HAVE_FTRUNCATE
 #define HAVE_FTRUNCATE
+#endif
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
 #endif
diff -urN a/Modules/_localemodule.c b/Modules/_localemodule.c
--- a/Modules/_localemodule.c	2013-05-12 04:32:50.000000000 +0100
+++ b/Modules/_localemodule.c	2013-05-17 23:57:26.938332682 +0100
@@ -10,6 +10,13 @@
 ******************************************************************/
 
 #include "Python.h"
+#ifdef __MINGW32__
+/* The header libintl.h and library libintl may exist on mingw host.
+ * To be compatible with MSVC build we has to undef some defines.
+ */
+#undef HAVE_LIBINTL_H
+#undef HAVE_BIND_TEXTDOMAIN_CODESET
+#endif
 
 #include <stdio.h>
 #include <locale.h>
diff -urN a/Modules/_math.c b/Modules/_math.c
--- a/Modules/_math.c	2013-05-12 04:32:50.000000000 +0100
+++ b/Modules/_math.c	2013-05-17 23:57:26.938332682 +0100
@@ -5,6 +5,29 @@
 #include <float.h>
 #include "_math.h"
 
+#if defined(__MINGW32__)
+#  define USE_MINGWEX_MATH
+#endif
+
+#ifdef USE_MINGWEX_MATH
+/* To avoid problems with many MSVCRT implementations we will
+ * use a work-around
+ */
+#define MAXLOG 7.09782712893383996843E2
+#define MINLOG -7.45133219101941108420E2
+
+static double fake_exp (double x) {
+  if (isnan(x)) { return(x); }
+  if (isinf(x)) { return(x > 0.0 ? x : 0.0); }
+  if (x > MAXLOG) { errno = ERANGE; return(INFINITY); }
+/* the correct code is to set ERANGE but why windows build bot don't fail ? */
+  if (x < MINLOG) { errno = ERANGE; return(0.0); }
+
+  return(exp(x));
+}
+#define exp	fake_exp
+#endif /*def USE_MINGWEX_MATH*/
+
 /* The following copyright notice applies to the original
    implementations of acosh, asinh and atanh. */
 
@@ -179,9 +202,28 @@
         if (u == 1.0)
             return x;
         else
+#if 0
             return (u - 1.0) * x / log(u);
+#else
+        {   /* avoid precision error */
+            double r;
+            r = x / log(u);
+            return((u - 1.0) * r);
+        }
+#endif
     }
     else
+#ifdef USE_MINGWEX_MATH
+/* to avout errors with correct fake_exp:
+  expm10211:expm1(-1420.0): expected -1.0, got 'OverflowError'
+  expm10212:expm1(-1450.0): expected -1.0, got 'OverflowError'
+  expm10213:expm1(-1500.0): expected -1.0, got 'OverflowError'
+  expm10214:expm1(-1e+50): expected -1.0, got 'OverflowError'
+  expm10215:expm1(-1.79e+308): expected -1.0, got 'OverflowError'
+*/
+        if (x < MINLOG) { return(-1.0); }
+        else
+#endif
         return exp(x) - 1.0;
 }
 
diff -urN a/Modules/mathmodule.c b/Modules/mathmodule.c
--- a/Modules/mathmodule.c	2013-05-12 04:32:51.000000000 +0100
+++ b/Modules/mathmodule.c	2013-05-17 23:57:26.938332682 +0100
@@ -60,6 +60,30 @@
 extern double copysign(double, double);
 #endif
 
+#if defined(__MINGW32__)
+#  define USE_MINGWEX_MATH
+#endif
+
+#ifdef USE_MINGWEX_MATH
+/* Since ldexp() is broken on many MSVCRT implementations and mingwex
+ * library provide a long double version we will use it as work-around.
+ * As example broken ldexp return for ldexp(1., INT_MAX) 0(zero) instead inf.
+ * With this work-around math test testLdexp pass.
+ */
+static double fake_ldexp (double x, int expn) { return ldexpl (x, expn); }
+#define ldexp	fake_ldexp
+
+/* Since pow() is broken on many MSVCRT implementations and library
+ * mingwex provide a long double version we will use it as work-around.
+ * As example broken pow return for pow(132.97585637020967, 126.95117632943295)
+ * 4.1252919849060512e+269 instead 4.1252919849057403e+269.
+ * With this work-around math test test_mtestfile pass for gamma.
+ */
+static double fake_pow (double x, double y) { return powl (x, y); }
+#define pow	fake_pow
+
+#endif /*def USE_MINGWEX_MATH*/
+
 /*
    sin(pi*x), giving accurate results for all finite x (especially x
    integral or close to an integer).  This is here for use in the
diff -urN a/Modules/_multiprocessing/multiprocessing.c b/Modules/_multiprocessing/multiprocessing.c
--- a/Modules/_multiprocessing/multiprocessing.c	2013-05-12 04:32:50.000000000 +0100
+++ b/Modules/_multiprocessing/multiprocessing.c	2013-05-17 23:57:26.939332694 +0100
@@ -332,6 +332,12 @@
         Py_DECREF(temp); Py_DECREF(value); return; }              \
     Py_DECREF(value)
 
+#ifndef MS_WINDOWS
+/* GCC(mingw) 4.4+ require and use posix threads(pthreads-w32)
+ * Also system may contain installed pthreads-w32.
+ * As multiprocessing is based on windows methods we must
+ * comment all those flags
+ */
 #if defined(HAVE_SEM_OPEN) && !defined(POSIX_SEMAPHORES_NOT_ENABLED)
     ADD_FLAG(HAVE_SEM_OPEN);
 #endif
@@ -345,8 +351,10 @@
     ADD_FLAG(HAVE_BROKEN_SEM_GETVALUE);
 #endif
 #ifdef HAVE_BROKEN_SEM_UNLINK
+/* FIXME: why use this? Note before was for cygwin and darwin ? */
     ADD_FLAG(HAVE_BROKEN_SEM_UNLINK);
 #endif
+#endif /*ndef MS_WINDOWS*/
     if (PyModule_AddObject(module, "flags", temp) < 0)
         return;
 }
diff -urN a/Modules/posixmodule.c b/Modules/posixmodule.c
--- a/Modules/posixmodule.c	2013-05-12 04:32:51.000000000 +0100
+++ b/Modules/posixmodule.c	2013-05-17 23:57:26.940332706 +0100
@@ -131,6 +131,16 @@
 #define HAVE_CWAIT      1
 #define HAVE_FSYNC      1
 #define fsync _commit
+#elif defined(__MINGW32__)	/* GCC (mingw special) compiler */
+/*#define HAVE_GETCWD	1 - detected by configure*/
+#define HAVE_SPAWNV	1
+/*#define HAVE_EXECV	1 - detected by configure*/
+#define HAVE_PIPE	1
+#define HAVE_POPEN	1
+#define HAVE_SYSTEM	1
+#define HAVE_CWAIT	1
+#define HAVE_FSYNC	1
+#define fsync _commit
 #else
 #if defined(PYOS_OS2) && defined(PYCC_GCC) || defined(__VMS)
 /* Everything needed is defined in PC/os2emx/pyconfig.h or vms/pyconfig.h */
@@ -259,7 +269,7 @@
 #endif
 #endif
 
-#ifdef _MSC_VER
+#if defined(_MSC_VER) || defined(__MINGW32__)
 #ifdef HAVE_DIRECT_H
 #include <direct.h>
 #endif
@@ -275,7 +285,7 @@
 #include <shellapi.h>   /* for ShellExecute() */
 #define popen   _popen
 #define pclose  _pclose
-#endif /* _MSC_VER */
+#endif /* _MSC_VER || __MINGW32__ */
 
 #if defined(PYCC_VACPP) && defined(PYOS_OS2)
 #include <io.h>
@@ -575,7 +585,7 @@
 */
 #include <crt_externs.h>
 static char **environ;
-#elif !defined(_MSC_VER) && ( !defined(__WATCOMC__) || defined(__QNX__) )
+#elif !defined(_MSC_VER) && !defined(__MINGW32__) && ( !defined(__WATCOMC__) || defined(__QNX__) )
 extern char **environ;
 #endif /* !_MSC_VER */
 
@@ -1515,6 +1525,13 @@
 }
 
 #ifdef MS_WINDOWS
+#ifdef __MINGW32__
+/* NOTE: All sample MSDN wincrypt programs include this header.
+ * It is required if we use mingw w32api.
+ * Why MSVC builds don't include it ?
+ */
+#  include <wincrypt.h>
+#endif
 
 /* IsUNCRoot -- test whether the supplied path is of the form \\SERVER\SHARE\,
    where / can be used in place of \ and the trailing slash is optional.
@@ -9332,7 +9349,7 @@
 }
 
 
-#if (defined(_MSC_VER) || defined(__WATCOMC__) || defined(__BORLANDC__)) && !defined(__QNX__)
+#if (defined(_MSC_VER) || defined (__MINGW32__) || defined(__WATCOMC__) || defined(__BORLANDC__)) && !defined(__QNX__)
 #define INITFUNC initnt
 #define MODNAME "nt"
 
diff -urN a/Modules/readline.c b/Modules/readline.c
--- a/Modules/readline.c	2013-05-12 04:32:51.000000000 +0100
+++ b/Modules/readline.c	2013-05-17 23:57:26.976333131 +0100
@@ -11,6 +11,11 @@
 #include <errno.h>
 #include <sys/time.h>
 
+#ifdef MS_WINDOWS
+/* on windows select don't work on files */
+#undef HAVE_SELECT
+#endif
+
 #if defined(HAVE_SETLOCALE)
 /* GNU readline() mistakenly sets the LC_CTYPE locale.
  * This is evil.  Only the user or the app's main() should do this!
@@ -892,6 +897,10 @@
     /* Allow $if term= in .inputrc to work */
     rl_terminal_name = getenv("TERM");
 #endif
+#ifdef MS_WINDOWS
+    /* FIXME: need more test before to skip this hack */
+    rl_terminal_name = "dumb";
+#endif
     /* Force rebind of TAB to insert-tab */
     rl_bind_key('\t', rl_insert);
     /* Bind both ESC-TAB and ESC-ESC to the completion function */
@@ -1150,6 +1159,9 @@
     if (m == NULL)
         return;
 
+#ifndef MS_WINDOWS
+    /* FIXME: windows readline(prompt) may not work ? */
     PyOS_ReadlineFunctionPointer = call_readline;
+#endif
     setup_readline();
 }
diff -urN a/Modules/selectmodule.c b/Modules/selectmodule.c
--- a/Modules/selectmodule.c	2013-05-12 04:32:51.000000000 +0100
+++ b/Modules/selectmodule.c	2013-05-17 23:57:26.978333154 +0100
@@ -108,9 +108,10 @@
         v = PyObject_AsFileDescriptor( o );
         if (v == -1) goto finally;
 
-#if defined(_MSC_VER)
+#if defined(_MSC_VER) || defined(__MINGW32__)
+/* FIXME: why not #ifdef Py_SOCKET_FD_CAN_BE_GE_FD_SETSIZE ? */
         max = 0;                             /* not used for Win32 */
-#else  /* !_MSC_VER */
+#else  /* !_MSC_VER & !__MINGW32__ */
         if (!_PyIsSelectable_fd(v)) {
             PyErr_SetString(PyExc_ValueError,
                         "filedescriptor out of range in select()");
@@ -118,7 +119,7 @@
         }
         if (v > max)
             max = v;
-#endif /* _MSC_VER */
+#endif /* _MSC_VER, __MINGW32__ */
         FD_SET(v, set);
 
         /* add object and its file descriptor to the list */
diff -urN a/Modules/Setup.config.in b/Modules/Setup.config.in
--- a/Modules/Setup.config.in	2013-05-12 04:32:49.000000000 +0100
+++ b/Modules/Setup.config.in	2013-05-17 23:57:26.979333166 +0100
@@ -3,11 +3,22 @@
 # The purpose of this file is to conditionally enable certain modules
 # based on configure-time options.
 
+# init system calls(posix/nt/...) for INITFUNC (used by makesetup)
+@INITSYS@ posixmodule.c
+
 # Threading
 @USE_THREAD_MODULE@thread threadmodule.c
 
 # The signal module
 @USE_SIGNAL_MODULE@signal signalmodule.c
 
+# On win32 host(mingw build in MSYS environment) show that site.py
+# fail to load if some modules are not build-in:
+@BUILDIN_WIN32_MODULE@_functools _functoolsmodule.c	# Tools for working with functions and callable objects
+@BUILDIN_WIN32_MODULE@operator operator.c	# operator.add() and similar goodies
+@BUILDIN_WIN32_MODULE@_locale _localemodule.c	# -lintl
+@BUILDIN_WIN32_MODULE@_winreg ../PC/_winreg.c
+
+
 # The rest of the modules previously listed in this file are built
 # by the setup.py script in Python 2.1 and later.
diff -urN a/Modules/Setup.dist b/Modules/Setup.dist
--- a/Modules/Setup.dist	2013-05-12 04:32:49.000000000 +0100
+++ b/Modules/Setup.dist	2013-05-17 23:57:26.979333166 +0100
@@ -112,9 +112,10 @@
 # This only contains the minimal set of modules required to run the 
 # setup.py script in the root of the Python source tree.
 
-posix posixmodule.c		# posix (UNIX) system calls
 errno errnomodule.c		# posix (UNIX) errno values
-pwd pwdmodule.c			# this is needed to find out the user's home dir
+#FIXME: setup.py detect this module along with grp and spwd.
+#FIXME: what about to comment ?
+#pwd pwdmodule.c			# this is needed to find out the user's home dir
 				# if $HOME is not set
 _sre _sre.c			# Fredrik Lundh's new regular expressions
 _codecs _codecsmodule.c		# access to the builtin codecs and codec registry
diff -urN a/Modules/signalmodule.c b/Modules/signalmodule.c
--- a/Modules/signalmodule.c	2013-05-12 04:32:51.000000000 +0100
+++ b/Modules/signalmodule.c	2013-05-17 23:57:26.979333166 +0100
@@ -7,7 +7,7 @@
 #include "intrcheck.h"
 
 #ifdef MS_WINDOWS
-#include <Windows.h>
+#include <windows.h>
 #ifdef HAVE_PROCESS_H
 #include <process.h>
 #endif
diff -urN a/Modules/socketmodule.c b/Modules/socketmodule.c
--- a/Modules/socketmodule.c	2013-05-12 04:32:51.000000000 +0100
+++ b/Modules/socketmodule.c	2013-05-17 23:57:26.980333178 +0100
@@ -91,6 +91,15 @@
 #endif
 
 #include "Python.h"
+#ifndef HAVE_GETPEERNAME
+/* FIXME: see comments in configure.in. Also PC/pyconfig.h define it.
+ * Since only this module use getpeername why don't remove declaration
+ * from PC/pyconfig.h and define here if is defined MS_WIN32 ?
+ */
+#ifdef __MINGW32__
+#  define HAVE_GETPEERNAME
+#endif
+#endif /* ndef HAVE_GETPEERNAME */
 #include "structmember.h"
 #include "timefuncs.h"
 
@@ -313,6 +322,35 @@
   /* Do not include addrinfo.h for MSVC7 or greater. 'addrinfo' and
    * EAI_* constants are defined in (the already included) ws2tcpip.h.
    */
+#elif defined(__MINGW32__)
+/* FIXME: getaddrinfo(HAVE_GETADDRINFO) depend from WINVER
+   TODO: resolve later(see comments in pyport.h) */
+#if 0
+/* To use getaddrinfo/getnameinfo from runtime for version before 0x0501
+   we has to define those functions (see below).
+   In all cases mingw linker succeed to link binaries.
+   If you enable this code the load of module will fail on w2k
+   with message like this one:
+   "The specified procedure could not be found" */
+#  if (_WIN32_WINNT < 0x0501)
+void WSAAPI freeaddrinfo (struct addrinfo*);
+int WSAAPI getaddrinfo (const char*,const char*,const struct addrinfo*,
+		        struct addrinfo**);
+int WSAAPI getnameinfo(const struct sockaddr*,socklen_t,char*,DWORD,
+		       char*,DWORD,int);
+#  endif
+#  define HAVE_GETADDRINFO
+#  define HAVE_GETNAMEINFO
+#else
+#  if (_WIN32_WINNT < 0x0501)
+   /* Internal implemetation that has to work on w2k and latest. */
+#    define EAI_ADDRFAMILY
+#    include "addrinfo.h"
+#  else
+#    define HAVE_GETADDRINFO
+#    define HAVE_GETNAMEINFO
+#  endif
+#endif
 #else
 #  include "addrinfo.h"
 #endif
@@ -350,6 +388,16 @@
 #if !defined(HAVE_GETADDRINFO)
 /* avoid clashes with the C library definition of the symbol. */
 #define getaddrinfo fake_getaddrinfo
+#ifdef __MINGW32__
+#ifdef gai_strerror
+/* NOTE: Mingw w32api always define gai_strerror to gai_strerror{A|W}
+   but getaddrinfo is defined if _WIN32_WINNT >= 0x0501.
+   MSDN say that gai_strerror() exist for w95 and later and
+   getaddrinfo()/getnameinfo() for wxp and later.
+   Since we use fake function to suppress warnign we has to undef. */
+#  undef gai_strerror
+#endif
+#endif /*def __MINGW32__*/
 #define gai_strerror fake_gai_strerror
 #define freeaddrinfo fake_freeaddrinfo
 #include "getaddrinfo.c"
@@ -2986,7 +3034,31 @@
 Shut down the reading side of the socket (flag == SHUT_RD), the writing side\n\
 of the socket (flag == SHUT_WR), or both ends (flag == SHUT_RDWR).");
 
+#ifndef SIO_RCVALL
+#ifdef __MINGW32__
+/* MSDN: SIO_RCVALL defined on w2k and later */
+/* note "Separate SDKs" required for w2k    */
+/* 0x98000001 = _WSAIOW(IOC_VENDOR,1)       */
+#  define SIO_RCVALL	0x98000001
+#  define RCVALL_OFF	0
+#  define RCVALL_ON	1
+   /* NOTE: MSDN - this feature is not implemented */
+#  define RCVALL_SOCKETLEVELONLY	2
+
+/* 0x98000004 = _WSAIOW(IOC_VENDOR,4) */
+#  define SIO_KEEPALIVE_VALS	0x98000004
+struct tcp_keepalive {
+    u_long onoff;
+    u_long keepalivetime;
+    u_long keepaliveinterval;
+};
+#endif /* def __MINGW32__ */
+#endif /* ndef SIO_RCVALL */
+
 #if defined(MS_WINDOWS) && defined(SIO_RCVALL)
+/* If isn't defined test_socket.py fail with:
+AttributeError: type object '_socket.socket' has no attribute 'ioctl'
+*/
 static PyObject*
 sock_ioctl(PySocketSockObject *s, PyObject *arg)
 {
diff -urN a/Modules/socketmodule.h b/Modules/socketmodule.h
--- a/Modules/socketmodule.h	2013-05-12 04:32:51.000000000 +0100
+++ b/Modules/socketmodule.h	2013-05-17 23:57:26.980333178 +0100
@@ -13,6 +13,13 @@
 # endif
 
 #else /* MS_WINDOWS */
+#ifdef socklen_t
+/* Configure script define to int on windows for GCC compiler.
+   Avoid GCC 4.4+ error (two or more data types in declaration specifiers)
+   as undef it first.
+ */
+# undef socklen_t
+#endif
 # include <winsock2.h>
 # include <ws2tcpip.h>
 /* VC6 is shipped with old platform headers, and does not have MSTcpIP.h
diff -urN a/Objects/fileobject.c b/Objects/fileobject.c
--- a/Objects/fileobject.c	2013-05-12 04:32:52.000000000 +0100
+++ b/Objects/fileobject.c	2013-05-17 23:57:26.981333190 +0100
@@ -9,9 +9,17 @@
 #endif /* HAVE_SYS_TYPES_H */
 
 #ifdef MS_WINDOWS
+#if !defined(__MINGW32__)
+/* avoid 'warning: "fileno" redefined' */
 #define fileno _fileno
+#endif
 /* can simulate truncate with Win32 API functions; see file_truncate */
+#ifndef HAVE_FTRUNCATE
+/* NOTE: autotool based build check and set it
+   FIXME: why isn't defined in PC/pyconfig.h ?
+ */
 #define HAVE_FTRUNCATE
+#endif
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
 #endif
diff -urN a/PC/msvcrtmodule.c b/PC/msvcrtmodule.c
--- a/PC/msvcrtmodule.c	2013-05-12 04:32:52.000000000 +0100
+++ b/PC/msvcrtmodule.c	2013-05-17 23:57:26.981333190 +0100
@@ -22,6 +22,31 @@
 #include <conio.h>
 #include <sys/locking.h>
 
+#if defined(__MINGW32__)
+#if __MSVCRT_VERSION__ >= 0x0700
+# define _WCONIO_DEFINED
+/* NOTE: Up to version ?.?? mingw don't define functions
+ * listed below. Also it require module to be linked with
+ * ms-vcrt at least verion 7.
+ * To build with different runtimes see:
+ *  http://www.mingw.org/wiki/HOWTO_Use_the_GCC_specs_file
+ *
+ * Also note that NT5.1(XP), shiped with msvcrt version 7.0,
+ * contain all those functions, but library name is msvcrt.dll.
+ * So if you like module to run on w2k as is you must define
+ * appropriate __MSVCRT_VERSION__ .
+ * If you like those functions even on w2k you must link
+ * with appropriate runtime and to pack it in distributions.
+ * This is what MSVC build do - it is build and packed
+ * with version 9.0 of Microsoft C-runtime.
+ */
+_CRTIMP wint_t __cdecl __MINGW_NOTHROW	_getwch (void);
+_CRTIMP wint_t __cdecl __MINGW_NOTHROW	_getwche (void);
+_CRTIMP wint_t __cdecl __MINGW_NOTHROW	_putwch (wchar_t);
+_CRTIMP wint_t __cdecl __MINGW_NOTHROW	_ungetwch(wint_t);
+#endif /* __MSVCRT_VERSION__ >= 0x0700 */
+#endif
+
 #ifdef _MSC_VER
 #if _MSC_VER >= 1500 && _MSC_VER < 1600
 #include <crtassem.h>
@@ -346,6 +371,7 @@
     if (!PyArg_ParseTuple(args, "u:ungetwch", &ch))
         return NULL;
 
+    /* FIXME: why _ungetch is called instead _ungetwch */
     if (_ungetch(ch) == EOF)
         return PyErr_SetFromErrno(PyExc_IOError);
     Py_INCREF(Py_None);
diff -urN a/PC/_winreg.c b/PC/_winreg.c
--- a/PC/_winreg.c	2013-05-12 04:32:52.000000000 +0100
+++ b/PC/_winreg.c	2013-05-17 23:57:26.982333202 +0100
@@ -17,6 +17,18 @@
 #include "malloc.h" /* for alloca */
 #include "windows.h"
 
+#if defined(__MINGW32__)
+_CRTIMP size_t __cdecl __MINGW_NOTHROW _mbstrlen(const char *s);
+#endif
+
+#if !defined(REG_LEGAL_CHANGE_FILTER)
+#define REG_LEGAL_CHANGE_FILTER                 \
+                (REG_NOTIFY_CHANGE_NAME          |\
+                 REG_NOTIFY_CHANGE_ATTRIBUTES    |\
+                 REG_NOTIFY_CHANGE_LAST_SET      |\
+                 REG_NOTIFY_CHANGE_SECURITY)
+#endif
+
 static BOOL PyHKEY_AsHKEY(PyObject *ob, HKEY *pRes, BOOL bNoneOK);
 static PyObject *PyHKEY_FromHKEY(HKEY h);
 static BOOL PyHKEY_Close(PyObject *obHandle);
@@ -1088,6 +1100,15 @@
 static PyObject *
 PyDeleteKeyEx(PyObject *self, PyObject *args)
 {
+#ifndef KEY_WOW64_64KEY
+/* KEY_WOW64_64KEY is defined for _WIN32_WINNT >= 0x0502,
+  i.e. Windows Server 2003 with SP1, Windows XP with SP2
+  and not supported on w2k
+ */
+    PyErr_SetString(PyExc_NotImplementedError,
+                    "not implemented on this platform");
+    return NULL;
+#else /*def KEY_WOW64_64KEY*/
     HKEY hKey;
     PyObject *obKey;
     HMODULE hMod;
@@ -1123,6 +1144,7 @@
         return PyErr_SetFromWindowsErrWithFunction(rc, "RegDeleteKeyEx");
     Py_INCREF(Py_None);
     return Py_None;
+#endif
 }
 
 static PyObject *
diff -urN a/pyconfig.h.in b/pyconfig.h.in
--- a/pyconfig.h.in	2013-05-12 04:32:54.000000000 +0100
+++ b/pyconfig.h.in	2013-05-17 23:57:26.982333202 +0100
@@ -49,7 +49,7 @@
 /* Define to 1 if you have the `acosh' function. */
 #undef HAVE_ACOSH
 
-/* struct addrinfo (netdb.h) */
+/* struct addrinfo */
 #undef HAVE_ADDRINFO
 
 /* Define to 1 if you have the `alarm' function. */
@@ -900,6 +900,9 @@
 /* Define to 1 if you have the `wcscoll' function. */
 #undef HAVE_WCSCOLL
 
+/* Define to 1 if you have the <winsock2.h> header file. */
+#undef HAVE_WINSOCK2_H
+
 /* Define if tzset() actually switches the local timezone in a meaningful way.
    */
 #undef HAVE_WORKING_TZSET
@@ -927,6 +930,9 @@
 /* Define if mvwdelch in curses.h is an expression. */
 #undef MVWDELCH_IS_EXPRESSION
 
+/* Define to 1 if you want to use native NT threads */
+#undef NT_THREADS
+
 /* Define to the address where bug reports for this package should be sent. */
 #undef PACKAGE_BUGREPORT
 
diff -urN a/Python/dynload_win.c b/Python/dynload_win.c
--- a/Python/dynload_win.c	2013-05-12 04:32:53.000000000 +0100
+++ b/Python/dynload_win.c	2013-05-17 23:57:26.982333202 +0100
@@ -11,9 +11,11 @@
 #include "importdl.h"
 #include <windows.h>
 
-// "activation context" magic - see dl_nt.c...
+#ifdef Py_ENABLE_SHARED
+/* "activation context" magic - see dl_nt.c... */
 extern ULONG_PTR _Py_ActivateActCtx();
 void _Py_DeactivateActCtx(ULONG_PTR cookie);
+#endif
 
 const struct filedescr _PyImport_DynLoadFiletab[] = {
 #ifdef _DEBUG
@@ -25,6 +27,12 @@
 };
 
 
+#if defined(__MINGW32__)
+/* NOTE strcasecmp fail to compile with GCC for windows hosts
+ * with  error: conflicting types for 'strcasecmp'
+ */
+#  define strcasecmp fake_strcasecmp
+#endif
 /* Case insensitive string compare, to avoid any dependencies on particular
    C RTL implementations */
 
@@ -190,11 +198,15 @@
                             sizeof(pathbuf),
                             pathbuf,
                             &dummy)) {
+#ifdef Py_ENABLE_SHARED
             ULONG_PTR cookie = _Py_ActivateActCtx();
+#endif
             /* XXX This call doesn't exist in Windows CE */
             hDLL = LoadLibraryEx(pathname, NULL,
                                  LOAD_WITH_ALTERED_SEARCH_PATH);
+#ifdef Py_ENABLE_SHARED
             _Py_DeactivateActCtx(cookie);
+#endif
         }
 
         /* restore old error mode settings */
diff -urN a/Python/fileblocks.c b/Python/fileblocks.c
--- a/Python/fileblocks.c	1970-01-01 01:00:00.000000000 +0100
+++ b/Python/fileblocks.c	2013-05-17 23:57:26.983333213 +0100
@@ -0,0 +1,17 @@
+/*
+-- Macro: AC_STRUCT_ST_BLOCKS
+    If `struct stat' contains an `st_blocks' member, define
+    `HAVE_STRUCT_STAT_ST_BLOCKS'.  Otherwise, require an `AC_LIBOBJ'
+    replacement of `fileblocks'.
+*/
+
+#if !HAVE_STRUCT_STAT_ST_BLOCKS
+/* If necessary you may see gnulib for replacement function:
+off_t st_blocks (off_t size)
+You may found code available under GPL2 or GPL3.
+*/
+#else
+/* This declaration is solely to ensure that after preprocessing
+   this file is never empty.  */
+typedef int textutils_fileblocks_unused;
+#endif
diff -urN a/Python/thread.c b/Python/thread.c
--- a/Python/thread.c	2013-05-12 04:32:53.000000000 +0100
+++ b/Python/thread.c	2013-05-17 23:57:26.983333213 +0100
@@ -7,6 +7,16 @@
 
 #include "Python.h"
 
+#ifdef __MINGW32__
+/* GCC 4.4+ (mingw) support posix threads!
+  Note: macro __MINGW_GCC is defined for GCC 4.4+ but
+  not for GCC 3.4.5 (last stable from 3.x )
+  Instead to use __MINGW_GCC we will use more common
+  __MINGW32__ to prevent case when in GCC 3.4.5 build
+  envirionment is installed posix thread package.
+ */
+# undef HAVE_PTHREAD_H
+#endif
 
 #ifndef _POSIX_THREADS
 /* This means pthreads are not implemented in libc headers, hence the macro
diff -urN a/setup.py b/setup.py
--- a/setup.py	2013-05-12 04:32:54.000000000 +0100
+++ b/setup.py	2013-05-17 23:57:26.984333225 +0100
@@ -179,7 +179,7 @@
         # with Modules/ and adding Python's include directory to the path.
         (srcdir,) = sysconfig.get_config_vars('srcdir')
         if not srcdir:
-            # Maybe running on Windows but not using CYGWIN?
+            # Maybe running on Windows but not using posix build?
             raise ValueError("No source directory; cannot proceed.")
         srcdir = os.path.abspath(srcdir)
         moddirlist = [os.path.join(srcdir, 'Modules')]
@@ -246,8 +246,38 @@
         if compiler is not None:
             (ccshared,cflags) = sysconfig.get_config_vars('CCSHARED','CFLAGS')
             args['compiler_so'] = compiler + ' ' + ccshared + ' ' + cflags
+
+        # FIXME: Is next correct ?
+        # To link modules we need LDSHARED passed to setup.py otherwise
+        # distutils will use linker from build system if cross-compiling.
+        linker_so = os.environ.get('LDSHARED')
+        if linker_so is not None:
+            args['linker_so'] = linker_so
+
         self.compiler.set_executables(**args)
 
+        if host_platform == 'win32':
+            # FIXME: best way to pass just build python library to the modules
+            self.compiler.library_dirs.insert(0, '.')
+            data = open('pyconfig.h').read()
+            m = re.search(r"#s*define\s+Py_DEBUG\s+1\s*", data)
+            if m is not None:
+                self.compiler.libraries.append("python" + str(sysconfig.get_config_var('VERSION')) + "_d")
+            else:
+                self.compiler.libraries.append("python" + str(sysconfig.get_config_var('VERSION')))
+
+        if host_platform == 'win32':
+            # NOTE: See comment for SHLIBS in configure.in .
+            # Although it look obsolete since setup.py add module
+            # required libraries we will pass list too.
+            # As example this will allow us to propage static
+            # libraries like mingwex to modules.
+            for lib in sysconfig.get_config_var('SHLIBS').split():
+                if lib.startswith('-l'):
+                    self.compiler.libraries.append(lib[2:])
+                else:
+                    self.compiler.libraries.append(lib)
+
         build_ext.build_extensions(self)
 
         longest = max([len(e.name) for e in self.extensions])
@@ -482,6 +512,8 @@
             # (PYTHONFRAMEWORK is set) to avoid # linking problems when
             # building a framework with different architectures than
             # the one that is currently installed (issue #7473)
+            # NOTE: revision 25103:[ #420565 ] add search in sys.prefix
+            # before current source tree !?!?!?! No comment!
             add_dir_to_list(self.compiler.library_dirs,
                             sysconfig.get_config_var("LIBDIR"))
             add_dir_to_list(self.compiler.include_dirs,
@@ -537,6 +569,7 @@
             #   NOTE: using shlex.split would technically be more correct, but
             # also gives a bootstrap problem. Let's hope nobody uses directories
             # with whitespace in the name to store libraries.
+            # FIXME: Why LDFLAGS again ?
             cflags, ldflags = sysconfig.get_config_vars(
                     'CFLAGS', 'LDFLAGS')
             for item in cflags.split():
@@ -549,7 +582,7 @@
 
         # Check for MacOS X, which doesn't need libm.a at all
         math_libs = ['m']
-        if host_platform in ['darwin', 'beos']:
+        if host_platform in ['darwin', 'beos', 'mingw', 'win32']:
             math_libs = []
 
         # XXX Omitted modules: gl, pure, dl, SGI-specific modules
@@ -593,14 +626,20 @@
         # heapq
         exts.append( Extension("_heapq", ["_heapqmodule.c"]) )
         # operator.add() and similar goodies
-        exts.append( Extension('operator', ['operator.c']) )
+        # On win32 host(mingw build in MSYS environment) show that site.py
+        # fail to load if some modules are not build-in:
+        if host_platform not in ['mingw', 'win32']:
+            exts.append( Extension('operator', ['operator.c']) )
         # Python 3.1 _io library
         exts.append( Extension("_io",
             ["_io/bufferedio.c", "_io/bytesio.c", "_io/fileio.c",
              "_io/iobase.c", "_io/_iomodule.c", "_io/stringio.c", "_io/textio.c"],
-             depends=["_io/_iomodule.h"], include_dirs=["Modules/_io"]))
+             depends=["_io/_iomodule.h"], include_dirs=[os.path.join(srcdir,"Modules/_io")]))
         # _functools
-        exts.append( Extension("_functools", ["_functoolsmodule.c"]) )
+        # On win32 host(mingw build in MSYS environment) show that site.py
+        # fail to load if some modules are not build-in:
+        if host_platform not in ['mingw', 'win32']:
+            exts.append( Extension("_functools", ["_functoolsmodule.c"]) )
         # _json speedups
         exts.append( Extension("_json", ["_json.c"]) )
         # Python C API test module
@@ -627,7 +666,10 @@
             locale_extra_link_args = []
 
 
-        exts.append( Extension('_locale', ['_localemodule.c'],
+        # On win32 host(mingw build in MSYS environment) show that site.py
+        # fail to load if some modules are not build-in:
+        if host_platform not in ['mingw', 'win32']:
+            exts.append( Extension('_locale', ['_localemodule.c'],
                                libraries=locale_libs,
                                extra_link_args=locale_extra_link_args) )
 
@@ -636,24 +678,35 @@
         # supported...)
 
         # fcntl(2) and ioctl(2)
-        libs = []
-        if (config_h_vars.get('FLOCK_NEEDS_LIBBSD', False)):
-            # May be necessary on AIX for flock function
-            libs = ['bsd']
-        exts.append( Extension('fcntl', ['fcntlmodule.c'], libraries=libs) )
-        # pwd(3)
-        exts.append( Extension('pwd', ['pwdmodule.c']) )
-        # grp(3)
-        exts.append( Extension('grp', ['grpmodule.c']) )
-        # spwd, shadow passwords
-        if (config_h_vars.get('HAVE_GETSPNAM', False) or
-                config_h_vars.get('HAVE_GETSPENT', False)):
-            exts.append( Extension('spwd', ['spwdmodule.c']) )
+        if host_platform not in ['mingw', 'win32']:
+            libs = []
+            if (config_h_vars.get('FLOCK_NEEDS_LIBBSD', False)):
+                # May be necessary on AIX for flock function
+                libs = ['bsd']
+            exts.append( Extension('fcntl', ['fcntlmodule.c'], libraries=libs) )
+        else:
+            missing.append('fcntl')
+        if host_platform not in ['mingw', 'win32']:
+            # pwd(3)
+            exts.append( Extension('pwd', ['pwdmodule.c']) )
+            # grp(3)
+            exts.append( Extension('grp', ['grpmodule.c']) )
+            # spwd, shadow passwords
+            if (config_h_vars.get('HAVE_GETSPNAM', False) or
+                    config_h_vars.get('HAVE_GETSPENT', False)):
+                exts.append( Extension('spwd', ['spwdmodule.c']) )
+            else:
+                missing.append('spwd')
         else:
-            missing.append('spwd')
+            missing.extend(['pwd', 'grp', 'spwd'])
 
         # select(2); not on ancient System V
-        exts.append( Extension('select', ['selectmodule.c']) )
+        if host_platform == 'win32':
+            select_libs = ['ws2_32']
+        else:
+            select_libs = []
+        exts.append( Extension('select', ['selectmodule.c'],
+                               libraries=select_libs) )
 
         # Fred Drake's interface to the Python parser
         exts.append( Extension('parser', ['parsermodule.c']) )
@@ -669,8 +722,11 @@
             missing.append('mmap')
 
         # Lance Ellinghaus's syslog module
-        # syslog daemon interface
-        exts.append( Extension('syslog', ['syslogmodule.c']) )
+        if host_platform not in ['mingw', 'win32']:
+            # syslog daemon interface
+            exts.append( Extension('syslog', ['syslogmodule.c']) )
+        else:
+            missing.append('syslog')
 
         # George Neville-Neil's timing module:
         # Deprecated in PEP 4 http://www.python.org/peps/pep-0004.html
@@ -772,15 +828,19 @@
             libs = ['crypt']
         else:
             libs = []
-        exts.append( Extension('crypt', ['cryptmodule.c'], libraries=libs) )
+        if libs != [] or host_platform not in ['mingw', 'win32']:
+            exts.append( Extension('crypt', ['cryptmodule.c'], libraries=libs) )
 
         # CSV files
         exts.append( Extension('_csv', ['_csv.c']) )
 
         # socket(2)
+        _socket_libs = math_libs
+        if host_platform == 'win32':
+            _socket_libs.append('ws2_32')
         exts.append( Extension('_socket', ['socketmodule.c', 'timemodule.c'],
                                depends=['socketmodule.h'],
-                               libraries=math_libs) )
+                               libraries=_socket_libs) )
         # Detect SSL support for the socket module (via _ssl)
         search_for_ssl_incs_in = [
                               '/usr/local/ssl/include',
@@ -801,10 +861,13 @@
 
         if (ssl_incs is not None and
             ssl_libs is not None):
+            _ssl_libs = ['ssl', 'crypto']
+            if host_platform in ('mingw', 'win32'):
+                _ssl_libs.append('ws2_32')
             exts.append( Extension('_ssl', ['_ssl.c'],
                                    include_dirs = ssl_incs,
                                    library_dirs = ssl_libs,
-                                   libraries = ['ssl', 'crypto'],
+                                   libraries = _ssl_libs,
                                    depends = ['socketmodule.h']), )
         else:
             missing.append('_ssl')
@@ -840,14 +903,17 @@
             if have_usable_openssl:
                 # The _hashlib module wraps optimized implementations
                 # of hash functions from the OpenSSL library.
+                # NOTE: _hashlib require only OpenSSL crypto library !
                 exts.append( Extension('_hashlib', ['_hashopenssl.c'],
                                        include_dirs = ssl_incs,
                                        library_dirs = ssl_libs,
-                                       libraries = ['ssl', 'crypto']) )
+                                       libraries = ['crypto']) )
             else:
                 print ("warning: openssl 0x%08x is too old for _hashlib" %
                        openssl_ver)
                 missing.append('_hashlib')
+        # NOTE: MSVC build alwais include _md5 and _sha modules
+        # as build-in modules
         if COMPILED_WITH_PYDEBUG or not have_usable_openssl:
             # The _sha module implements the SHA1 hash algorithm.
             exts.append( Extension('_sha', ['shamodule.c']) )
@@ -883,6 +949,29 @@
         min_db_ver = (4, 3)
         db_setup_debug = False   # verbose debug prints from this script?
 
+        # Modules with some Windows dependencies:
+        if host_platform == 'win32':
+            srcdir = sysconfig.get_config_var('srcdir')
+            pc_srcdir = os.path.abspath(os.path.join(srcdir, 'PC'))
+
+            exts.append( Extension('msvcrt', [os.path.join(pc_srcdir, p)
+                for p in ['msvcrtmodule.c']]) )
+
+            exts.append( Extension('_msi', [os.path.join(pc_srcdir, p)
+                for p in ['_msi.c']]) )
+
+            exts.append( Extension('_subprocess', [os.path.join(pc_srcdir, p)
+                for p in ['_subprocess.c']]) )
+
+            # On win32 host(mingw build in MSYS environment) show that site.py
+            # fail to load if some modules are not build-in:
+            #exts.append( Extension('_winreg', [os.path.join(pc_srcdir, p)
+            #    for p in ['_winreg.c']]) )
+
+            exts.append( Extension('winsound', [os.path.join(pc_srcdir, p)
+                for p in ['winsound.c']],
+                libraries=['winmm']) )
+
         def allow_db_ver(db_ver):
             """Returns a boolean if the given BerkeleyDB version is acceptable.
 
@@ -1162,6 +1251,7 @@
                 '_sqlite/util.c', ]
 
             sqlite_defines = []
+            #NOTE: don't add mingw here
             if host_platform != "win32":
                 sqlite_defines.append(('MODULE_NAME', '"sqlite3"'))
             else:
@@ -1304,7 +1394,8 @@
                 missing.append('dbm')
 
         # Anthony Baxter's gdbm module.  GNU dbm(3) will require -lgdbm:
-        if ('gdbm' in dbm_order and
+        if (host_platform not in ['mingw', 'win32'] and
+            'gdbm' in dbm_order and
             self.compiler.find_library_file(lib_dirs, 'gdbm')):
             exts.append( Extension('gdbm', ['gdbmmodule.c'],
                                    libraries = ['gdbm'] ) )
@@ -1312,7 +1403,7 @@
             missing.append('gdbm')
 
         # Unix-only modules
-        if host_platform not in ['win32']:
+        if host_platform not in ['mingw', 'win32']:
             # Steen Lumholt's termios module
             exts.append( Extension('termios', ['termios.c']) )
             # Jeremy Hylton's rlimit interface
@@ -1518,7 +1609,7 @@
         if sys.maxint == 0x7fffffff:
             # This requires sizeof(int) == sizeof(long) == sizeof(char*)
             dl_inc = find_file('dlfcn.h', [], inc_dirs)
-            if (dl_inc is not None) and (host_platform not in ['atheos']):
+            if (dl_inc is not None) and (host_platform not in ['atheos', 'mingw', 'win32']):
                 exts.append( Extension('dl', ['dlmodule.c']) )
             else:
                 missing.append('dl')
@@ -1529,7 +1620,7 @@
         self.detect_ctypes(inc_dirs, lib_dirs)
 
         # Richard Oudkerk's multiprocessing module
-        if host_platform == 'win32':             # Windows
+        if host_platform == 'win32':  # Windows
             macros = dict()
             libraries = ['ws2_32']
 
@@ -1557,7 +1648,9 @@
 
         else:                                   # Linux and other unices
             macros = dict()
-            libraries = ['rt']
+            # NOTE: line below is never used before to add MINGW platform
+            #libraries = ['rt']
+            libraries = []
 
         if host_platform == 'win32':
             multiprocessing_srcs = [ '_multiprocessing/multiprocessing.c',
@@ -1576,7 +1669,9 @@
                 multiprocessing_srcs.append('_multiprocessing/semaphore.c')
 
         if sysconfig.get_config_var('WITH_THREAD'):
+            #FIXME: why above set libraries aren't used ?
             exts.append ( Extension('_multiprocessing', multiprocessing_srcs,
+                                    libraries=libraries,
                                     define_macros=macros.items(),
                                     include_dirs=["Modules/_multiprocessing"]))
         else:
@@ -1617,6 +1712,7 @@
         if host_platform == 'darwin' and ("--disable-toolbox-glue" not in
                 sysconfig.get_config_var("CONFIG_ARGS")):
 
+            #FIXME: next fail in cross-compilation environment
             if int(os.uname()[2].split('.')[0]) >= 8:
                 # We're on Mac OS X 10.4 or later, the compiler should
                 # support '-Wno-deprecated-declarations'. This will
@@ -1862,6 +1958,9 @@
         if host_platform == 'sunos5':
             include_dirs.append('/usr/openwin/include')
             added_lib_dirs.append('/usr/openwin/lib')
+        elif host_platform == 'win32':
+            # mingw&win32 don't use X11 headers and libraries
+            pass
         elif os.path.exists('/usr/X11R6/include'):
             include_dirs.append('/usr/X11R6/include')
             added_lib_dirs.append('/usr/X11R6/lib64')
@@ -1897,8 +1996,8 @@
         if host_platform in ['aix3', 'aix4']:
             libs.append('ld')
 
-        # Finally, link with the X11 libraries (not appropriate on cygwin)
-        if host_platform != "cygwin":
+        # Finally, link with the X11 libraries (not appropriate on cygwin, mingw)
+        if not host_platform in ['cygwin', 'mingw', 'win32']:
             libs.append('X11')
 
         ext = Extension('_tkinter', ['_tkinter.c', 'tkappinit.c'],
@@ -1949,6 +2048,38 @@
         return True
 
     def configure_ctypes(self, ext):
+        if host_platform == 'win32':
+            # win32 platform use own sources and includes
+            # from Modules/_ctypes/libffi_msvc/
+            srcdir = sysconfig.get_config_var('srcdir')
+
+            ffi_srcdir = os.path.abspath(os.path.join(srcdir, 'Modules',
+                                         '_ctypes'))
+            sources = [os.path.join(ffi_srcdir, p)
+                for p in ['malloc_closure.c',
+                         ]]
+            ext.sources.extend(sources)
+
+            ffi_srcdir = os.path.abspath(os.path.join(srcdir, 'Modules',
+                                         '_ctypes', 'libffi_msvc'))
+            #FIXME: _ctypes/libffi_msvc/win64.asm ?
+            sources = [os.path.join(ffi_srcdir, p)
+                for p in ['ffi.c',
+                          'prep_cif.c',
+                          'win32.S',
+                         ]]
+            # NOTE: issue2942 don't resolve problem with assembler code.
+            # It seems to me that python refuse to build an extension
+            # if exist a source with unknown suffix.
+            self.compiler.src_extensions.append('.s')
+            self.compiler.src_extensions.append('.S')
+            ext.include_dirs.append(ffi_srcdir)
+            ext.sources.extend(sources)
+            ext.libraries.extend(['ole32', 'oleaut32', 'uuid'])
+            #AdditionalOptions="/EXPORT:DllGetClassObject,PRIVATE /EXPORT:DllCanUnloadNow,PRIVATE"
+            ext.export_symbols.extend(['DllGetClassObject PRIVATE',
+                                       'DllCanUnloadNow PRIVATE'])
+            return True
         if not self.use_system_libffi:
             if host_platform == 'darwin':
                 return self.configure_ctypes_darwin(ext)
@@ -1999,6 +2130,11 @@
                                fficonfig['ffi_sources'])
             ext.include_dirs.extend(include_dirs)
             ext.extra_compile_args.extend(extra_compile_args)
+            if host_platform == 'win32':
+                ext.libraries.extend(['ole32', 'oleaut32', 'uuid'])
+                #AdditionalOptions="/EXPORT:DllGetClassObject,PRIVATE /EXPORT:DllCanUnloadNow,PRIVATE"
+                ext.export_symbols.extend(['DllGetClassObject PRIVATE',
+                                           'DllCanUnloadNow PRIVATE'])
         return True
 
     def detect_ctypes(self, inc_dirs, lib_dirs):
@@ -2042,7 +2178,12 @@
                         libraries=[],
                         sources=sources,
                         depends=depends)
+        if host_platform == 'win32':
+            ctypes_test_libs = ['oleaut32']
+        else:
+            ctypes_test_libs = []
         ext_test = Extension('_ctypes_test',
+                             libraries=ctypes_test_libs,
                              sources=['_ctypes/_ctypes_test.c'])
         self.extensions.extend([ext, ext_test])
 
